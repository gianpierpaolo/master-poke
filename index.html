<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaccia Gioco di Carte Pokémon</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter (o un font più "gamey" se disponibile e adatto) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Manteniamo Inter, ma puoi cambiarlo per un font pixelato se preferisci */
            margin: 0;
            /* Sfondo a tema Pokémon (es. verde erba scuro, blu cielo, ecc.) */
            background: linear-gradient(to bottom right, #4CAF50, #2E7D32); /* Verde scuro/erba */
            color: #E0E0E0; /* Testo chiaro */
        }
        /* Stile per la modale della fotocamera */
        .camera-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .camera-modal-content {
            background-color: #333;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        /* Nuovo stile per il contenitore del video e l'overlay di inquadratura */
        .camera-video-container {
            position: relative;
            width: 100%;
            max-width: 400px; /* Max width for the video stream */
            padding-top: calc(4 / 3 * 100%); /* Proporzioni 3:4 (altezza = 4/3 di larghezza) */
            height: 0; /* Set height to 0 to use padding-top for aspect ratio */
            overflow: hidden;
            background-color: black;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assicura che il video riempia il contenitore */
            transform: scaleX(-1); /* Specchia il video se è una fotocamera frontale */
        }

        .capture-frame-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 192px; /* Larghezza target della carta */
            height: 256px; /* Altezza target della carta (proporzione 3:4) */
            border: 3px dashed rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Permette il click attraverso l'overlay */
            z-index: 10;
        }

        /* Nasconde la canvas utilizzata per catturare l'immagine */
        .camera-canvas {
            display: none;
        }

        /* Stili aggiuntivi per i pulsanti tematici */
        .btn-theme {
            padding: 0.75rem 1.5rem; /* Aumentato padding */
            border-radius: 9999px; /* Completamente arrotondato */
            font-weight: 700; /* Bold */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3); /* Ombra testo */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); /* Ombra più pronunciata */
            transition: all 0.2s ease-in-out;
            border: 2px solid;
            background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
        }
        .btn-theme:hover {
            transform: translateY(-2px); /* Effetto sollevamento */
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .btn-theme:active {
            transform: translateY(1px); /* Effetto click */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn-red {
            --tw-gradient-stops: #EF4444, #DC2626; /* from-red-500 to-red-700 */
            border-color: #B91C1C; /* border-red-800 */
            color: white;
        }
        .btn-green {
            --tw-gradient-stops: #22C55E, #16A34A; /* from-green-500 to-green-700 */
            border-color: #15803D; /* border-green-800 */
            color: white;
        }
        .btn-blue {
            --tw-gradient-stops: #3B82F6, #2563EB; /* from-blue-500 to-blue-700 */
            border-color: #1D4ED8; /* border-blue-800 */
            color: white;
        }
        .btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA; /* from-purple-500 to-purple-700 */
            border-color: #7E22CE; /* border-purple-800 */
            color: white;
        }
        .btn-yellow {
            --tw-gradient-stops: #FACC15, #EAB308; /* from-yellow-400 to-yellow-600 */
            border-color: #CA8A04; /* border-yellow-700 */
            color: #333; /* Testo scuro per il giallo */
        }
        .btn-orange {
            --tw-gradient-stops: #F97316, #EA580C; /* from-orange-500 to-orange-700 */
            border-color: #C2410C; /* border-orange-800 */
            color: white;
        }
        .btn-gray {
            --tw-gradient-stops: #6B7280, #4B5563; /* from-gray-500 to-gray-700 */
            border-color: #374151; /* border-gray-800 */
            color: white;
        }
        .btn-cyan {
            --tw-gradient-stops: #22D3EE, #06B6D4; /* from-cyan-400 to-cyan-600 */
            border-color: #0891B2; /* border-cyan-700 */
            color: white;
        }

        /* Stili per le label dei contatori */
        .counter-label {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #F0F0F0; /* Light gray */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
        }
        /* Stili per i valori dei contatori */
        .counter-value {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 800; /* font-extrabold */
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
        }

        /* Stili per i pulsanti icona */
        .icon-btn {
            @apply flex items-center justify-center w-12 h-12 rounded-full text-2xl shadow-md transition-all duration-200 ease-in-out border-2;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
        }
        .icon-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }
        .icon-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .icon-btn.btn-blue {
             --tw-gradient-stops: #3B82F6, #2563EB; /* from-blue-500 to-blue-700 */
            border-color: #1D4ED8; /* border-blue-800 */
            color: white;
        }
        .icon-btn.btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA; /* from-purple-500 to-purple-700 */
            border-color: #7E22CE; /* border-purple-800 */
            color: white;
        }

        /* Stili per i segnalini medaglia */
        .medal-icon {
            @apply w-10 h-10 rounded-full flex items-center justify-center text-3xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md; /* Changed to text-3xl for uniformity */
        }
        .medal-icon.active {
            @apply scale-110 ring-2 ring-offset-2 ring-offset-green-700;
        }

        /* Stili per i segnalini Superquattro */
        .elite-four-icon {
            @apply w-10 h-10 rounded-full flex items-center justify-center text-3xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md; /* Changed to text-3xl for uniformity */
            background: linear-gradient(to bottom, #4A5568, #2D3748); /* gray-700 to gray-800 */
            color: #CBD5E0; /* text-gray-300 */
        }
        .elite-four-icon.active {
            @apply scale-110 ring-2 ring-offset-2 ring-offset-yellow-400;
            background: linear-gradient(to bottom, #FACC15, #EAB308); /* yellow-400 to yellow-600 */
            color: #333; /* Dark text for active */
        }


        /* Nasconde le frecce (spinner) dagli input di tipo number */
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type='number'] {
            -moz-appearance: textfield; /* Per Firefox */
        }

        /* Animazione per il banner della moneta */
        @keyframes fadeInOutCoin {
            0% { opacity: 0; transform: translateY(-50%) translateX(20px); }
            10% { opacity: 1; transform: translateY(-50%) translateX(0); }
            90% { opacity: 1; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(20px); }
        }
        .animate-fade-in-out-coin {
            animation: fadeInOutCoin 3s ease-in-out forwards;
        }

        /* Animazione per il banner di confusione (opzionale, per distinguere) */
        @keyframes fadeInOutConfusion {
            0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
            10% { opacity: 1; transform: translateY(-50%) scale(1); }
            90% { opacity: 1; transform: translateY(-50%) scale(1); }
            100% { opacity: 0; transform: translateY(-50%) scale(0.8); }
        }
        .animate-fade-in-out-confusion {
            animation: fadeInOutConfusion 3s ease-in-out forwards;
        }
        /* Animazione per il banner dado movimento */
        @keyframes fadeInOutMovementDice {
            0% { opacity: 0; transform: scale(0.5); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        .animate-fade-in-out-movement-dice {
            animation: fadeInOutMovementDice 5s ease-out forwards;
        }

        /* Stili per i pallini EXP */
        .exp-dot {
            width: 1rem; /* 16px */
            height: 1rem; /* 16px */
            border-radius: 50%;
            background-color: #4B5563; /* gray-600, inactive */
            border: 2px solid #374151; /* gray-700 */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
        }
        .exp-dot.active-yellow {
            background-color: #FACC15; /* yellow-400 */
            border-color: #EAB308; /* yellow-600 */
            transform: scale(1.1);
        }
        .exp-dot.active-blue {
            background-color: #3B82F6; /* blue-500 */
            border-color: #2563EB; /* blue-700 */
            transform: scale(1.1);
        }
        /* NEW: Styles for overall EXP dots */
        .exp-dot.active-pink {
            background-color: #EC4899; /* Pink 500 */
            border-color: #BE185D; /* Pink 700 */
            transform: scale(1.1);
        }
        .exp-dot.active-green-total {
            background-color: #22C55E; /* Green 500 */
            border-color: #15803D; /* Green 700 */
            transform: scale(1.1);
        }
        .exp-dot.active-blue-total {
            background-color: #3B82F6; /* Blue 500 */
            border-color: #1D4ED8; /* Blue 700 */
            transform: scale(1.1);
        }
        .exp-dot.active-yellow-total {
            background-color: #FACC15; /* Yellow 400 */
            border-color: #CA8A04; /* Yellow 700 */
            transform: scale(1.1);
        }
        .exp-dot.active-red-total {
            background-color: #EF4444; /* Red 500 */
            border-color: #B91C1C; /* Red 800 */
            transform: scale(1.1);
        }

        /* Stile per il banner globale dei dadi (ATTACCA/RITIRATA) */
        @keyframes fadeInOutDiceRoll {
            0% { opacity: 0; transform: scale(0.7); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.7); }
        }
        .animate-fade-in-out-dice-roll {
            animation: fadeInOutDiceRoll 3s ease-out forwards;
        }

        /* Stili per la modale del lancio della moneta di cattura */
        .capture-coin-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .capture-coin-modal-content {
            background-color: #333;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            border: 4px solid #FACC15; /* Yellow border */
        }
        .capture-coin-modal-content h2 {
            font-size: 2.5rem; /* text-4xl */
            font-weight: 800; /* font-extrabold */
            color: #FACC15; /* Yellow text */
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .capture-coin-modal-content button {
            padding: 1rem 2.5rem;
            border-radius: 9999px;
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700;
            background-image: linear-gradient(to bottom, #3B82F6, #2563EB); /* Blue gradient */
            border: 2px solid #1D4ED8;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease-in-out;
        }
        .capture-coin-modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .capture-coin-modal-content button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .capture-coin-result {
            font-size: 4rem; /* text-7xl */
            font-weight: 900; /* font-black */
            margin-top: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6);
        }
        .capture-coin-result.success {
            color: #22C55E; /* Green */
        }
        .capture-coin-result.fail {
            color: #EF4444; /* Red */
        }

        /* Stili per la modale di zoom dell'immagine */
        .zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .zoom-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .zoom-modal-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }
        .zoom-modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
        }
        .zoom-modal-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- React, ReactDOM, and Babel for JSX transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
     <!-- Supabase Client Library CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

   <script type="text/babel">
        // Your Supabase credentials
        const SUPABASE_URL = 'https://wcarhpvygqbjekacizlb.supabase.co'; // Assicurati che questo URL sia quello del tuo progetto Supabase
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjYXJocHZ5Z3FiamVrYWNpemxiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ0OTAzMTYsImV4cCI6MjA3MDA2NjMxNn0.xc7_wXB16kaAVOdcucP_7zzvUQ8f2S6IYKBjIs0ffEU'; // <<< INSERISCI QUI LA TUA VERA CHIAVE SUPABASE ANON KEY (PUBLIC) DA projects.supabase.com -> Project Settings -> API Keys

        // Initialize the Supabase client using the global 'supabase' object from the CDN
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Aggiungi un controllo per avvisare l'utente se la chiave API sembra generica
        if (SUPABASE_ANON_KEY === 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjYXJocHZ5Z3FiamVrYWNpembiLCJyb2xlIjoiYW5vbiIsImiaWF0IjoxNzU0NDkwMzE2LCJleHAiOjIwNzAwNjYzMTZ9.xc7_wXB16kaAVOdcucP_7zzvUQ8f2S6IYKBjIs0ffEU') {
            console.warn("ATTENZIONE: Stai utilizzando una chiave API Supabase anonima/pubblica di esempio. Per evitare errori 'Invalid API key' e connetterti al TUO database, sostituisci 'SUPABASE_ANON_KEY' con la chiave 'anon (Public)' dal pannello di controllo del tuo progetto Supabase (sezioni 'Project Settings' -> 'API Keys').");
        }

        // Mapping numbers to dice symbols (emoji) - Global for accessibility
        const diceFaces = {
            1: '⚀',
            2: '⚁',
            3: '⚂',
            4: '⚃',
            5: '⚄',
            6: '⚅',
        };

        // Local fallback/example database of Pokémon cards.
        // This will be used if Supabase data is not yet loaded or if Supabase setup fails.
        const localPokemonCardsDatabase = [
            { id: 'db-local-001', name: 'Pikachu', imageUrl: 'https://placehold.co/192x256/FFD700/000000?text=Pikachu', baseHp: 60, exp: 0 },
            { id: 'db-local-002', name: 'Charmander', imageUrl: 'https://placehold.co/192x256/FF4500/FFFFFF?text=Charmander', baseHp: 50, exp: 0 },
            { id: 'db-local-003', name: 'Squirtle', imageUrl: 'https://placehold.co/192x256/1E90FF/FFFFFF?text=Squirtle', baseHp: 60, exp: 0 },
            { id: 'db-local-004', name: 'Bulbasaur', imageUrl: 'https://placehold.co/192x256/7CFC00/000000?text=Bulbasaur', baseHp: 70, exp: 0 },
            { id: 'db-local-005', name: 'Jigglypuff', imageUrl: 'https://placehold.co/192x256/FF69B4/000000?text=Jigglypuff', baseHp: 80, exp: 0 },
            { id: 'db-local-006', name: 'Meowth', imageUrl: 'https://placehold.co/192x256/A9A9A9/000000?text=Meowth', baseHp: 70, exp: 0 },
            { id: 'db-local-007', name: 'Psyduck', imageUrl: 'https://placehold.co/192x256/ADD8E6/000000?text=Psyduck', baseHp: 80, exp: 0 },
            { id: 'db-local-008', name: 'Snorlax', imageUrl: 'https://placehold.co/192x256/6A5ACD/FFFFFF?text=Snorlax', baseHp: 120, exp: 0 },
            { id: 'db-local-009', name: 'Eevee', imageUrl: 'https://placehold.co/192x256/CD853F/FFFFFF?text=Eevee', baseHp: 60, exp: 0 },
            { id: 'db-local-010', name: 'Mewtwo', imageUrl: 'https://placehold.co/192x256/8A2BE2/FFFFFF?text=Mewtwo', baseHp: 130, exp: 0 },
            // Aggiungi qui altre carte di esempio locali se necessario
        ];

        // CameraModal Component
        // Modal for camera access and image capture.
        function CameraModal({ isOpen, onClose, onCapture }) {
            const videoRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const [currentStream, setCurrentStream] = React.useState(null);
            const [error, setError] = React.useState(null);
            const [availableCameras, setAvailableCameras] = React.useState([]);
            const [selectedCameraId, setSelectedCameraId] = React.useState('');
            const [cameraStatusMessage, setCameraStatusMessage] = React.useState("Inizializzazione fotocamera...");
            const [isFrontCamera, setIsFrontCamera] = React.useState(false); // New state to detect front camera

            // Function to stop the camera stream
            const stopCurrentStream = React.useCallback((s) => {
                if (s) {
                    console.log("Stopping tracks for stream:", s);
                    s.getTracks().forEach(track => {
                        console.log("Stopping track:", track.kind);
                        track.stop();
                    });
                    console.log("Stream stopped.");
                }
                setCurrentStream(null);
                if (videoRef.current) {
                    videoRef.current.srcObject = null; // Clear srcObject
                }
            }, []);

            // Function to start the camera stream
            const startCamera = React.useCallback(async (deviceIdToUse, facingMode = 'environment', fallback = false) => {
                setCameraStatusMessage("Avvio fotocamera...");
                setError(null);

                // Stop any existing stream
                if (currentStream) {
                    stopCurrentStream(currentStream);
                }
                setCurrentStream(null); // Ensure currentStream is null before attempting to get a new stream

                try {
                    const constraints = {
                        video: deviceIdToUse ? { deviceId: { exact: deviceIdToUse } } : { facingMode: facingMode }
                    };
                    console.log("Attempting getUserMedia with constraints:", constraints);
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    if (videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.onloadedmetadata = () => {
                            console.log("Video metadata loaded, attempting to play...");
                            setCameraStatusMessage("Attendere il video...");
                            videoRef.current.play().then(() => {
                                console.log("Video played successfully.");
                                setCameraStatusMessage(""); // Clear message on success
                            }).catch(playErr => {
                                console.error("Error playing video after metadata loaded:", playErr);
                                setError("Errore nella riproduzione del video della fotocamera. Assicurati che il browser consenta l'autoplay e riprova.");
                                setCameraStatusMessage("Errore riproduzione video.");
                            });
                        };
                        // If metadata already loaded (e.g., re-render), try to play immediately
                        if (videoRef.current.readyState >= 2) { // HAVE_CURRENT_DATA or more
                             videoRef.current.play().catch(playErr => {
                                 console.error("Error playing video (readyState >=2):", playErr);
                             });
                        }
                    }
                    setCurrentStream(mediaStream); // Set stream to state after successful acquisition
                    console.log("Camera started successfully with deviceId:", deviceIdToUse || "generic");

                    // Determine if the current camera is front-facing
                    const videoTrack = mediaStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    setIsFrontCamera(settings.facingMode === 'user');

                } catch (err) { // Correctly placed catch block for the try
                    console.error("Error accessing camera with deviceId:", deviceIdToUse, err);
                    setCameraStatusMessage("Errore nell'accesso alla fotocamera.");
                    if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                        setError("Accesso alla fotocamera negato. Controlla i permessi del browser.");
                    } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                        if (!fallback && availableCameras.length > 0) { 
                            console.log("Specific camera not found, attempting generic fallback or first available.");
                            startCamera(availableCameras[0].deviceId, availableCameras[0].label.toLowerCase().includes('front') ? 'user' : 'environment', true); // Fallback
                            return; 
                        }
                        setError("Nessuna fotocamera disponibile.");
                    } else {
                        setError("Impossibile accedere alla fotocamera: " + err.message);
                    }
                    stopCurrentStream(null); // Ensure cleanup on error
                }
            }, [stopCurrentStream, currentStream, availableCameras]); 

            // Main effect to handle modal opening/closing and camera initialization
            React.useEffect(() => {
                if (!isOpen) {
                    stopCurrentStream(currentStream); // Stop stream when modal closes
                    setAvailableCameras([]);
                    setSelectedCameraId('');
                    setError(null);
                    setCameraStatusMessage("Inizializzazione fotocamera...");
                    return; // Exit early if modal is closed
                }

                const setupDevicesAndStartInitialCamera = async () => {
                    setCameraStatusMessage("Ricerca fotocamere...");
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoInputs = devices.filter(device => device.kind === 'videoinput');
                        setAvailableCameras(videoInputs);
                        console.log("Available cameras detected (initial setup):", videoInputs);

                        if (videoInputs.length === 0) {
                            setError("Nessuna fotocamera trovata.");
                            setCameraStatusMessage("Nessuna fotocamera trovata.");
                            return;
                        }

                        let targetDeviceId = selectedCameraId; 
                        let targetFacingMode = 'environment'; // Default to rear camera
                        // If no selected camera or selected camera is no longer available, pick a default
                        if (!targetDeviceId || !videoInputs.some(device => device.deviceId === targetDeviceId)) { 
                            const rearCamera = videoInputs.find(device =>
                                device.label.toLowerCase().includes('back') ||
                                device.label.toLowerCase().includes('rear') ||
                                device.label.toLowerCase().includes('environment')
                            );
                            targetDeviceId = rearCamera ? rearCamera.deviceId : videoInputs[0].deviceId; 
                            targetFacingMode = rearCamera ? 'environment' : (videoInputs[0].label.toLowerCase().includes('front') ? 'user' : 'environment');
                            console.log("Determined initial targetDeviceId:", targetDeviceId, "facingMode:", targetFacingMode);
                        } else {
                            // If a selected camera is found, try to determine its facing mode
                            const selectedCamera = videoInputs.find(device => device.deviceId === targetDeviceId);
                            if (selectedCamera) {
                                targetFacingMode = selectedCamera.label.toLowerCase().includes('front') ? 'user' : 'environment';
                            }
                        }
                        
                        setSelectedCameraId(targetDeviceId); 
                        startCamera(targetDeviceId, targetFacingMode); 

                    } catch (err) { 
                        console.error("Errore nell'enumerazione dei dispositivi o nell'avvio iniziale:", err);
                        setError("Impossibile enumerare le fotocamere o avviare la fotocamera iniziale. Controlla i permessi del browser.");
                        setCameraStatusMessage("Errore configurazione fotocamera.");
                    }
                };

                setupDevicesAndStartInitialCamera();

                // Cleanup function for useEffect
                return () => {
                    stopCurrentStream(currentStream); // This ensures stream is stopped when component unmounts or dependencies change
                };
            }, [isOpen]); // Keep isOpen as the primary dependency for this effect

            // Effect to restart camera if selectedCameraId changes (user selects from dropdown)
            React.useEffect(() => {
                if (isOpen && selectedCameraId && currentStream && currentStream.getTracks().length > 0 && currentStream.getVideoTracks()[0].getSettings().deviceId !== selectedCameraId) {
                    console.log("Selected camera ID changed by user, restarting camera with:", selectedCameraId);
                    const selectedCam = availableCameras.find(cam => cam.deviceId === selectedCameraId);
                    const facingMode = selectedCam ? (selectedCam.label.toLowerCase().includes('front') ? 'user' : 'environment') : 'environment';
                    startCamera(selectedCameraId, facingMode);
                }
            }, [selectedCameraId, isOpen, startCamera, currentStream, availableCameras]);


            // Capture the image from the video feed and pass it via onCapture
            const takePhoto = () => {
                console.log("Attempting to take photo...");
                // Add an explicit check for videoRef.current before accessing its properties
                if (!videoRef.current || videoRef.current.readyState < 3 || !currentStream) {
                    setError("Errore: Elemento video non disponibile o non pronto.");
                    setCameraStatusMessage("Errore interno: Video non pronto.");
                    console.error("videoRef.current is null or not ready when attempting to take photo.");
                    return;
                }

                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // Define the target aspect ratio for a card (e.g., 3:4 or 2.5:3.5)
                // For a standard Pokemon card, typical dimensions are about 6.3 cm x 8.8 cm
                // Ratio: 8.8 / 6.3 ≈ 1.396 or ~ 3.5 / 2.5 = 1.4
                // Let's use 3:4 aspect ratio for simplicity, which is 192x256 pixels as our target output.
                const targetWidth = 192; // px
                const targetHeight = 256; // px

                // Calculate the crop area to maintain 3:4 aspect ratio from the video stream
                const videoRatio = video.videoWidth / video.videoHeight;
                const targetRatio = targetWidth / targetHeight;

                let sx, sy, sWidth, sHeight; // Source x, y, width, height for cropping

                if (videoRatio > targetRatio) {
                    // Video is wider than target. Crop left/right.
                    sHeight = video.videoHeight;
                    sWidth = sHeight * targetRatio;
                    sx = (video.videoWidth - sWidth) / 2;
                    sy = 0;
                } else {
                    // Video is taller than target. Crop top/bottom.
                    sWidth = video.videoWidth;
                    sHeight = sWidth / targetRatio;
                    sx = 0;
                    sy = (video.videoHeight - sHeight) / 2;
                }

                canvas.width = targetWidth;
                canvas.height = targetHeight;

                const context = canvas.getContext('2d');
                // Draw the cropped video frame onto the canvas
                context.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);

                const imageDataUrl = canvas.toDataURL('image/png');
                onCapture(imageDataUrl);
                onClose();
            };

            if (!isOpen) return null; // Do not render anything if the modal is not open

            return (
                <div className="camera-modal-overlay">
                    <div className="camera-modal-content">
                        <h2 className="text-xl font-bold text-blue-400 mb-4">Cattura Immagine dalla Fotocamera</h2>
                        {error && <p className="text-red-500 mb-4">{error}</p>}
                        {!error && <p className="text-blue-300 mb-4">{cameraStatusMessage}</p>}

                        {/* Dropdown for camera selection */}
                        {availableCameras.length > 1 && (
                            <div className="mb-4 w-full max-w-xs">
                                <label htmlFor="camera-select" className="block text-gray-300 text-sm font-bold mb-2">
                                    Seleziona Fotocamera:
                                </label>
                                <select
                                    id="camera-select"
                                    value={selectedCameraId || ''}
                                    onChange={(e) => e.stopPropagation() || setSelectedCameraId(e.target.value)}
                                    className="block w-full p-2 rounded-md bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                >
                                    {availableCameras.map(camera => (
                                        <option key={camera.deviceId} value={camera.deviceId}>
                                            {camera.label || `Fotocamera ${camera.deviceId.substring(0, 5)}...`}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        )}

                        {/* Video Feed with framing overlay */}
                        <div className="camera-video-container">
                            <video 
                                ref={videoRef} 
                                className="camera-video" 
                                autoPlay 
                                playsInline 
                                muted 
                                style={{ transform: isFrontCamera ? 'scaleX(-1)' : 'scaleX(1)' }} /* Apply flip only if it's a front camera */
                            ></video>
                            {/* Overlay for card framing */}
                            <div className="capture-frame-overlay"></div>
                            {/* Overlay for status/error messages if video is not ready */}
                            {(!currentStream || error || videoRef.current?.readyState < 2) && (
                                <div className="absolute inset-0 flex justify-center items-center bg-gray-900 bg-opacity-80 text-gray-400 text-center p-4">
                                    {error || cameraStatusMessage || "Attendere il video..."}
                                </div>
                            )}
                        </div>
                        
                        <canvas ref={canvasRef} className="camera-canvas"></canvas>
                        <div className="flex space-x-4 mt-4">
                            <button
                                onClick={takePhoto}
                                className="px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors shadow-lg font-bold disabled:opacity-50"
                                disabled={!currentStream || !videoRef.current || videoRef.current.videoWidth === 0 || videoRef.current.readyState < 3} 
                            >
                                Scatta Foto
                            </button>
                            <button
                                onClick={onClose}
                                className="px-6 py-3 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-lg font-bold"
                            >
                                Chiudi
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // New ZoomModal Component
        function ZoomModal({ isOpen, imageUrl, onClose }) {
            if (!isOpen || !imageUrl) return null;

            return (
                <div className="zoom-modal-overlay" onClick={onClose}>
                    <div className="zoom-modal-content" onClick={(e) => e.stopPropagation()}> {/* Prevent closing when clicking on the image itself */}
                        <img src={imageUrl} alt="Zoomed Card" />
                        <button className="zoom-modal-close-btn" onClick={onClose}>×</button>
                    </div>
                </div>
            );
        }

        // NEW: RecallFromBoxModal Component
        function RecallFromBoxModal({ isOpen, onClose, boxCards, onSelectCardFromBox, onDeleteCardFromBox }) {
            const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
            const [cardToDeleteIndex, setCardToDeleteIndex] = React.useState(null);

            const handleDeleteClick = (index, e) => {
                e.stopPropagation(); // Prevent selecting the card when clicking delete
                setCardToDeleteIndex(index);
                setIsDeleteConfirmOpen(true);
            };

            const confirmDelete = () => {
                if (cardToDeleteIndex !== null) {
                    onDeleteCardFromBox(cardToDeleteIndex);
                    setIsDeleteConfirmOpen(false);
                    setCardToDeleteIndex(null);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay"> {/* Reusing zoom-modal-overlay for consistent styling */}
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Box</h2>
                        {boxCards.length === 0 ? (
                            <p className="text-gray-400 text-lg">Il box è vuoto. Invia prima alcune carte!</p>
                        ) : (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {boxCards.map((card, index) => (
                                    <div
                                        key={index}
                                        className="relative bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromBox(card, index)}
                                    >
                                        <img
                                            src={card.imageUrl}
                                            alt={`Box Card ${index + 1}`}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs">HP: {card.baseHp}</p>
                                        <p className="text-gray-300 text-xs">EXP: {card.exp}</p> {/* EXP in Box View */}
                                        <button
                                            onClick={(e) => handleDeleteClick(index, e)}
                                            className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700"
                                            title="Elimina dal Box"
                                        >
                                            X
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>

                        {/* Delete Confirmation Modal (internal to RecallFromBoxModal) */}
                        {isDeleteConfirmOpen && (
                            <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-30 rounded-lg p-6">
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    Sei sicuro di voler eliminare questa carta dal Box?
                                </p>
                                <div className="flex space-x-4">
                                    <button
                                        onClick={confirmDelete}
                                        className="btn-theme btn-red text-base md:text-lg"
                                    >
                                        Sì
                                    </button>
                                    <button
                                        onClick={() => setIsDeleteConfirmOpen(false)}
                                        className="btn-theme btn-gray text-base md:text-lg"
                                    >
                                        No
                                    </button>
                                </div> {/* Corrected closing div */}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // NEW: SelectFromDatabaseModal Component
        // This component now accepts a 'cardsData' prop which will be either pokemonDbCards or trainersDbCards
        function SelectFromDatabaseModal({ isOpen, onClose, onSelectCardFromDatabase, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Database</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta trovata. Assicurati che il database contenga carte o prova a cercare un altro nome.</p>
                        )}

                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromDatabase(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {/* Only show HP if it's a Pokemon card (baseHp > 0 or defined) */}
                                        {card.baseHp !== undefined && card.baseHp > 0 && (
                                            <p className="text-gray-400 text-xs">HP: {card.baseHp}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: SelectFromSupabaseTableModal Component
        function SelectFromSupabaseTableModal({ isOpen, onClose, onSelectTableAndFetchRandom }) {
            const tableOptions = ['rosa', 'verde', 'blu', 'giallo', 'rosso', 'oro'];
            const [selectedTable, setSelectedTable] = React.useState('');
            const [isLoadingRandomCard, setIsLoadingRandomCard] = React.useState(false);
            const [randomCardError, setRandomCardError] = React.useState(null);

            const handleSelect = async () => {
                if (selectedTable) {
                    setIsLoadingRandomCard(true);
                    setRandomCardError(null);
                    try {
                        // The parent function now directly handles the update
                        await onSelectTableAndFetchRandom(selectedTable);
                        onClose(); // Close modal after successful selection and processing
                    } catch (error) {
                        console.error("Errore nel recupero della carta casuale dalla tabella:", error);
                        setRandomCardError("Errore nel recupero della carta casuale: " + error.message);
                    } finally {
                        setIsLoadingRandomCard(false);
                    }
                }
            };

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Scegli Tabella per Carta Casuale</h2>
                        <select
                            value={selectedTable}
                            onChange={(e) => e.stopPropagation() || setSelectedTable(e.target.value)}
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                            <option value="">Seleziona una tabella</option>
                            {tableOptions.map(table => (
                                <option key={table} value={table}>{table.charAt(0).toUpperCase() + table.slice(1)}</option>
                            ))}
                        </select>

                        <button
                            onClick={handleSelect}
                            className="btn-theme btn-green px-6 py-3 text-lg disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={!selectedTable || isLoadingRandomCard}
                        >
                            {isLoadingRandomCard ? 'Caricamento...' : 'Scegli e Carica Casuale'}
                        </button>

                        {randomCardError && <p className="text-red-500 mt-4">{randomCardError}</p>}

                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Annulla
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: SelectFromPalestreModal Component
        function SelectFromPalestreModal({ isOpen, onClose, onSelectCardFromPalestre, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Database Palestre</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta palestra..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte palestra...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta palestra trovata. Assicurati che il database contenga carte o prova a cercare un altro nome.</p>
                        )}

                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromPalestre(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {/* Palestre cards typically don't have HP/EXP, so no need to display them */}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: SelectFromTrainersCardDatabaseModal Component
        function SelectFromTrainersCardDatabaseModal({ isOpen, onClose, onSelectTrainerCard, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Aggiungi Carta Allenatore</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta allenatore..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte allenatore...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta allenatore trovata. Assicurati che il database contenga carte o prova a cercare un altro nome.</p>
                        )}

                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectTrainerCard(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {/* Display cost if available */}
                                        {card.cost !== undefined && (
                                            <p className="text-yellow-400 text-xs font-bold">Costo: {card.cost} 💰</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: AddCardChoiceModal Component
        function AddCardChoiceModal({ isOpen, onClose, onChooseNew, onChooseFromBox, onChooseFromDatabase, onChooseFromSupabaseTable, onChooseFromPalestre }) {
            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay"> {/* Reusing overlay style */}
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-6 text-center">Come vuoi aggiungere la carta?</h2>
                        <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                            <button
                                onClick={onChooseNew}
                                className="btn-theme btn-green px-6 py-3 text-lg"
                            >
                                Nuova Carta 📸
                            </button>
                            <button
                                onClick={onChooseFromBox}
                                className="btn-theme btn-blue px-6 py-3 text-lg"
                            >
                                Scegli dal Box 📦
                            </button>
                            <button
                                onClick={onChooseFromDatabase}
                                className="btn-theme btn-yellow px-6 py-3 text-lg"
                            >
                                Scegli dal Database 📚
                            </button>
                            <button
                                onClick={onChooseFromSupabaseTable} /* New button */
                                className="btn-theme btn-orange px-6 py-3 text-lg"
                            >
                                Casuale da Tabella 🎲
                            </button>
                            <button
                                onClick={onChooseFromPalestre} /* New button for Palestre */
                                className="btn-theme btn-purple px-6 py-3 text-lg"
                            >
                                Scegli da Palestre 🏛️
                            </button>
                        </div>
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-8 px-6 py-2 text-lg"
                        >
                            Annulla
                        </button>
                    </div>
                </div>
            );
        }


        // CardSlot component - Represents a single card slot
        function CardSlot({ slotIndex, cardData, onUpdateCard, onToggleActivePokemon, isMyTurn, activeCardParalyzed, onSendToBox, onRecallFromBox, boxCards, pokemonDbCards, trainersDbCards, palestreDbCards, isDbLoading, dbError, onSelectTableAndFetchRandom, onSelectPalestreCard, role, showTemporaryCard }) {
            const [baseHp, setBaseHp] = React.useState(cardData ? cardData.baseHp : 0);
            const [damageTaken, setDamageTaken] = React.useState(cardData ? cardData.damageTaken : 0);
            const [statuses, setStatuses] = React.useState(cardData ? cardData.statuses : Array(5).fill(false));
            const [cardImage, setCardImage] = React.useState(cardData ? cardData.imageUrl : null);
            const [currentExp, setCurrentExp] = React.useState(cardData ? cardData.exp : 0);
            const [isActivePokemon, setIsActivePokemon] = React.useState(cardData ? cardData.isActivePokemon : false);

            const [isConfirmModalOpen, setIsConfirmModal] = React.useState(false);
            const [confirmAction, setConfirmAction] = React.useState(null);

            const fileInputRef = React.useRef(null);
            const [showCameraModal, setShowCameraModal] = React.useState(false);
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [showRecallFromBoxModal, setShowRecallFromBoxModal] = React.useState(false);
            const [showAddCardChoiceModal, setShowAddCardChoiceModal] = React.useState(false);
            const [showSelectFromDatabaseModal, setShowSelectFromDatabaseModal] = React.useState(false);
            const [showSelectFromSupabaseTableModal, setShowSelectFromSupabaseTableModal] = React.useState(false);
            const [showSelectFromPalestreModal, setShowSelectFromPalestreModal] = React.useState(false);

            const [zoomLevel, setZoomLevel] = React.useState(1.0);
            const [panX, setPanX] = React.useState(0);
            const [panY, setPanY] = React.useState(0);

            const MAX_ZOOM = 3.0;
            const MIN_ZOOM = 1.0;
            const ZOOM_STEP = 0.1;

            const resetCardView = React.useCallback(() => {
                setZoomLevel(1.0);
                setPanX(0);
                setPanY(0);
            }, []);

            React.useEffect(() => {
                if (cardData) {
                    setBaseHp(cardData.baseHp);
                    setDamageTaken(cardData.damageTaken);
                    setStatuses(cardData.statuses);
                    setCardImage(cardData.imageUrl);
                    setCurrentExp(cardData.exp);
                    setIsActivePokemon(cardData.isActivePokemon);
                } else {
                    setBaseHp(0);
                    setDamageTaken(0);
                    setStatuses(Array(5).fill(false));
                    setCardImage(null);
                    setCurrentExp(0);
                    setIsActivePokemon(false);
                    resetCardView();
                }
            }, [cardData]);

            const updateParentCardData = React.useCallback((newBaseHp, newDamageTaken, newStatuses, newImageUrl, newExpValue, newIsActivePokemon) => {
                onUpdateCard(slotIndex, {
                    imageUrl: newImageUrl,
                    baseHp: newBaseHp,
                    damageTaken: newDamageTaken,
                    statuses: newStatuses,
                    exp: newExpValue,
                    isActivePokemon: newIsActivePokemon
                });
            }, [onUpdateCard, slotIndex]);

            const handleNewImageSelection = (imageUrl, cardDetailsFromDb = {}) => {
                const expFromDb = cardDetailsFromDb.exp !== undefined ? cardDetailsFromDb.exp : currentExp;
                if (cardImage) {
                    setConfirmAction({ type: 'replace_image', imageUrl: imageUrl, cardDetailsFromDb: { ...cardDetailsFromDb, exp: expFromDb } });
                    setIsConfirmModal(true);
                } else {
                    setCardImage(imageUrl);
                    const newBaseHp = cardDetailsFromDb.baseHp !== undefined ? cardDetailsFromDb.baseHp : baseHp;
                    updateParentCardData(newBaseHp, damageTaken, statuses, imageUrl, expFromDb, isActivePokemon);
                }
                resetCardView();
            };

            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        handleNewImageSelection(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
                resetCardView();
            };

            const handleConfirmAction = (actionType, shouldResetDataForImageReplace = false) => {
                setIsConfirmModal(false);

                if (actionType === 'confirm_replace_image' && confirmAction && confirmAction.type === 'replace_image') {
                    const imageUrl = confirmAction.imageUrl;
                    const cardDetailsFromDb = confirmAction.cardDetailsFromDb || {};
                    const currentExpValue = currentExp;

                    if (shouldResetDataForImageReplace) {
                        const newBaseHp = cardDetailsFromDb.baseHp !== undefined ? cardDetailsFromDb.baseHp : 0;
                        const newExp = cardDetailsFromDb.exp !== undefined ? cardDetailsFromDb.exp : 0;
                        setBaseHp(newBaseHp);
                        setDamageTaken(0);
                        setStatuses(Array(5).fill(false));
                        setCurrentExp(newExp);
                        setCardImage(imageUrl);
                        setIsActivePokemon(false);
                        updateParentCardData(newBaseHp, 0, Array(5).fill(false), imageUrl, newExp, false);
                    } else {
                        setCardImage(imageUrl);
                        updateParentCardData(baseHp, damageTaken, statuses, imageUrl, currentExpValue, isActivePokemon);
                    }
                } else if (actionType === 'reset_full_slot' && confirmAction && confirmAction.type === 'reset_full_slot') {
                    setCardImage(null);
                    setBaseHp(0);
                    setDamageTaken(0);
                    setStatuses(Array(5).fill(false));
                    setCurrentExp(0);
                    setIsActivePokemon(false);
                    onUpdateCard(slotIndex, null);
                } else if (actionType === 'send_to_box' && confirmAction && confirmAction.type === 'send_to_box') {
                    if (cardData) {
                        onSendToBox({
                            imageUrl: cardImage,
                            baseHp: baseHp,
                            exp: currentExp
                        }, slotIndex);
                    }
                } else if (actionType === 'save_and_recall_from_box' && confirmAction && confirmAction.type === 'save_and_recall_from_box') {
                    if (shouldResetDataForImageReplace) {
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                    }
                    setShowRecallFromBoxModal(true);
                } else if (actionType === 'save_and_select_from_db' && confirmAction && confirmAction.type === 'save_and_select_from_db') {
                    if (shouldResetDataForImageReplace) {
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                    }
                    setShowSelectFromDatabaseModal(true);
                } else if (actionType === 'save_and_select_from_supabase_table' && confirmAction && confirmAction.type === 'save_and_select_from_supabase_table') {
                    if (shouldResetDataForImageReplace) {
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                    }
                    setShowSelectFromSupabaseTableModal(true);
                } else if (actionType === 'save_and_select_from_palestre' && confirmAction && confirmAction.type === 'save_and_select_from_palestre') {
                    if (shouldResetDataForImageReplace) {
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                    }
                    setShowSelectFromPalestreModal(true);
                }
                setConfirmAction(null);
            };

            const handleBaseHpChange = (event) => {
                const value = parseInt(event.target.value) || 0;
                setBaseHp(value);
                updateParentCardData(value, damageTaken, statuses, cardImage, currentExp, isActivePokemon);
            };

            const handleDamageChange = (amount) => {
                setDamageTaken(prevDamage => {
                    const newDamage = Math.max(0, prevDamage + amount);
                    updateParentCardData(baseHp, newDamage, statuses, cardImage, currentExp, isActivePokemon); 
                    return newDamage;
                });
            };

            const handleExpChange = (amount) => {
                setCurrentExp(prevExp => {
                    const newExp = Math.max(0, Math.min(6, prevExp + amount));
                    updateParentCardData(baseHp, damageTaken, statuses, cardImage, newExp, isActivePokemon);
                    return newExp;
                });
            };

            const toggleStatus = (index) => {
                if (!isActivePokemon) return;
                setStatuses(prevStatuses => {
                    const newStatuses = Array(5).fill(false); // Reset all statuses
                    // If the clicked status was not already active, activate it.
                    if (!prevStatuses[index]) {
                        newStatuses[index] = true;
                    }
                    // If it was already active, the new array will have all false, deactivating it.
                    updateParentCardData(baseHp, damageTaken, newStatuses, cardImage, currentExp, isActivePokemon);
                    return newStatuses;
                });
            };

            const requestFullSlotReset = () => {
                setConfirmAction({ type: 'reset_full_slot' });
                setIsConfirmModal(true);
            };

            const handleSendToBox = () => {
                if (cardData) {
                    setConfirmAction({ type: 'send_to_box' });
                    setIsConfirmModal(true);
                }
            };

            const handleBoxRecallClick = () => {
                if (cardData) {
                    setConfirmAction({ type: 'save_and_recall_from_box' });
                    setIsConfirmModal(true);
                } else {
                    setShowRecallFromBoxModal(true);
                }
            };

            const handleAddCardPlaceholderClick = () => {
                setShowAddCardChoiceModal(true);
            };

            const handleChooseNewCard = () => {
                setShowAddCardChoiceModal(false);
                setShowCameraModal(true);
            };

            const handleChooseFromBox = () => {
                setShowAddCardChoiceModal(false);
                setShowRecallFromBoxModal(true);
            };

            const handleChooseFromDatabase = () => {
                setShowAddCardChoiceModal(false);
                if (cardData) {
                    setConfirmAction({ type: 'save_and_select_from_db' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromDatabaseModal(true);
                }
            };

            const handleChooseFromSupabaseTable = () => {
                setShowAddCardChoiceModal(false);
                if (cardData) {
                    setConfirmAction({ type: 'save_and_select_from_supabase_table' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromSupabaseTableModal(true);
                }
            };

            const handleChooseFromPalestre = () => {
                setShowAddCardChoiceModal(false);
                if (cardData) {
                    setConfirmAction({ type: 'save_and_select_from_palestre' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromPalestreModal(true);
                }
            };

            const handleSelectCardFromDatabase = (selectedCard) => {
                setShowSelectFromDatabaseModal(false);
                showTemporaryCard(selectedCard.imageUrl, () => {
                    handleNewImageSelection(selectedCard.imageUrl, { 
                        baseHp: selectedCard.baseHp, 
                        exp: selectedCard.exp 
                    });
                    resetCardView();
                });
            };

            const handleSelectRandomCardFromSupabaseTable = async (tableName) => {
                try {
                    await onSelectTableAndFetchRandom(tableName);
                    setShowSelectFromSupabaseTableModal(false);
                } catch (error) {
                    console.error("Errore durante il recupero della carta casuale:", error);
                } 
                resetCardView();
            };

            const handleSelectCardFromPalestreCallback = (selectedCard) => {
                setShowSelectFromPalestreModal(false);
                showTemporaryCard(selectedCard.imageUrl, () => {
                    onSelectPalestreCard(selectedCard);
                });
            };

            const handleToggleActivePokemon = () => {
                onToggleActivePokemon(slotIndex);
            };

            React.useEffect(() => {
                setIsActivePokemon(cardData ? cardData.isActivePokemon : false);
            }, [cardData ? cardData.isActivePokemon : undefined]);

            const isStarButtonDisabled = !isMyTurn || (isMyTurn && activeCardParalyzed && !isActivePokemon) || (isMyTurn && isActivePokemon && cardData && cardData.statuses[3]);
            const isPlayerSlotDisabled = (role === 'player' ? false : false); 
            const statusColors = ['bg-lime-500 hover:bg-lime-600', 'bg-rose-500 hover:bg-rose-600', 'bg-sky-500 hover:bg-sky-600', 'bg-yellow-500 hover:bg-yellow-600', 'bg-purple-500 hover:bg-purple-600'];
            const currentHpValue = baseHp - damageTaken;

            const handleZoom = (factor) => {
                setZoomLevel(prevZoom => {
                    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, prevZoom * factor));
                    if (newZoom === MIN_ZOOM) {
                        setPanX(0);
                        setPanY(0);
                    }
                    return newZoom;
                });
            };

            const handleResetView = () => {
                setZoomLevel(1.0);
                setPanX(0);
                setPanY(0);
            };

            return (
                <div className={`relative p-6 rounded-xl shadow-2xl flex flex-col items-center border-4 ${isActivePokemon ? 'border-blue-400 bg-blue-900 bg-opacity-70' : 'border-yellow-400 bg-gray-800'} ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}>
                    <input type="file" accept="image/*" onChange={handleFileUpload} ref={fileInputRef} className="hidden" disabled={isPlayerSlotDisabled} />
                    <div className="flex items-center justify-between w-full mb-4">
                        <div className="flex items-center space-x-2 text-2xl bg-gray-900 p-2 rounded-lg border-2 border-green-600 shadow-md flex-grow">
                            <span className="counter-label text-green-300">HP:</span>
                            <span className="counter-value text-green-500">{currentHpValue}</span>
                        </div>
                        <button onClick={handleToggleActivePokemon} className={`ml-4 flex items-center justify-center w-12 h-12 rounded-full text-3xl shadow-md transition-all duration-200 ease-in-out border-2 ${isActivePokemon ? 'bg-yellow-400 border-yellow-600 text-gray-800' : 'bg-gray-600 border-gray-700 text-gray-300 hover:bg-gray-500'} ${(isStarButtonDisabled || isPlayerSlotDisabled) ? 'opacity-50 cursor-not-allowed' : ''}`} title={isActivePokemon ? 'Pokémon Attivo' : 'Rendi Attivo'} disabled={isStarButtonDisabled || isPlayerSlotDisabled}>
                            ⭐
                        </button>
                    </div>
                    {currentHpValue <= 0 && cardImage && (
                        <div className="absolute top-36 w-48 bg-red-700 text-white text-center font-extrabold text-2xl py-2 rounded-lg border-2 border-red-400 z-10 animate-pulse shadow-lg">
                            ESAUSTO
                        </div>
                    )}
                    {cardImage ? (
                        <div className="relative w-48 h-64 overflow-hidden rounded-lg border-2 border-gray-600 mb-6 bg-gray-900 shadow-inner">
                            <img src={cardImage} alt={"Carta " + (slotIndex + 1)} className="w-full h-full object-cover transition-transform duration-100 ease-out cursor-pointer" style={{ transform: `scale(${zoomLevel}) translate(${panX}px, ${panY}px)` }} onClick={() => setShowZoomModal(true)} onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/192x256/444/bbb?text=Errore+Immagine"; }} />
                            <div className="absolute bottom-2 right-2 flex items-center space-x-1 bg-gray-900 bg-opacity-70 p-1 rounded-lg shadow-md">
                                <button onClick={(e) => e.stopPropagation() || handleZoom(1 / (1 + ZOOM_STEP))} className="w-8 h-8 rounded-full bg-blue-600 text-white text-xl font-bold flex items-center justify-center shadow-md hover:bg-blue-700 transition-colors" title="Zoom Out" disabled={zoomLevel <= MIN_ZOOM || isPlayerSlotDisabled}>-</button>
                                <button onClick={(e) => e.stopPropagation() || handleZoom(1 + ZOOM_STEP)} className="w-8 h-8 rounded-full bg-blue-600 text-white text-xl font-bold flex items-center justify-center shadow-md hover:bg-blue-700 transition-colors" title="Zoom In" disabled={zoomLevel >= MAX_ZOOM || isPlayerSlotDisabled}>+</button>
                                <button onClick={(e) => e.stopPropagation() || handleResetView()} className="w-8 h-8 rounded-full bg-red-600 text-white text-lg flex items-center justify-center shadow-md hover:bg-red-700 transition-colors" title="Reset View" disabled={isPlayerSlotDisabled}>🔄</button>
                            </div>
                        </div>
                    ) : (
                        <div className="w-48 h-64 bg-gray-900 flex justify-center items-center text-gray-400 text-xl cursor-pointer rounded-lg border-4 border-dashed border-gray-600 mb-6 hover:bg-gray-800 transition-colors duration-300 shadow-inner" onClick={handleAddCardPlaceholderClick}>
                            <span className="text-center font-bold">Aggiungi Carta</span>
                        </div>
                    )}
                    {(cardData || cardImage) && (
                        <>
                            <div className="flex space-x-4 mb-6 w-full justify-center">
                                <button onClick={() => { fileInputRef.current.click(); }} className={`icon-btn btn-blue ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} title="Carica da File" disabled={isPlayerSlotDisabled}>📁</button>
                                <button onClick={() => { setShowCameraModal(true); }} className={`icon-btn btn-purple ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} title="Carica da Fotocamera" disabled={isPlayerSlotDisabled}>📸</button>
                            </div>
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-red-300">HP Base:</span>
                                <input type="number" value={baseHp} onChange={handleBaseHpChange} className={`w-24 px-3 py-2 bg-gray-900 border-2 border-red-500 rounded-lg text-center text-red-200 font-extrabold shadow-inner focus:outline-none focus:ring-2 focus:ring-red-400 no-spinner ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} min="0" disabled={isPlayerSlotDisabled} />
                            </div>
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-orange-300">Danni:</span>
                                <button onClick={() => handleDamageChange(-10)} className={`btn-theme btn-yellow px-4 py-2 text-xl ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={isPlayerSlotDisabled}>-10</button>
                                <span className="counter-value text-red-500">{damageTaken}</span>
                                <button onClick={() => handleDamageChange(10)} className={`btn-theme btn-orange px-4 py-2 text-xl ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={isPlayerSlotDisabled}>+10</button>
                            </div>
                            {role === 'player' && (
                                <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                    <span className="counter-label text-blue-300">EXP:</span>
                                    <button onClick={() => handleExpChange(-1)} className={`btn-theme btn-red px-4 py-2 text-xl ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={isPlayerSlotDisabled}>-</button>
                                    <div className="flex space-x-1">
                                        {[...Array(6)].map((_, i) => (<div key={i} className={`exp-dot ${i < currentExp ? (isActivePokemon ? 'active-blue' : 'active-yellow') : ''}`}></div>))}
                                    </div>
                                    <button onClick={() => handleExpChange(1)} className={`btn-theme btn-green px-4 py-2 text-xl ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={isPlayerSlotDisabled}>+</button>
                                </div>
                            )}
                            <div className="flex space-x-3 mb-6">
                                {statuses.map((isActive, index) => {
                                    const classes = ["w-10", "h-10", "rounded-full", "flex", "justify-center", "items-center", "font-bold", "transition-all", "duration-200", "ease-in-out", "transform", "border-2", "border-gray-600", "shadow-md"];
                                    let statusSymbol, statusTitle;
                                    switch(index) {
                                        case 0: statusSymbol = '😴'; statusTitle = 'Addormentato'; break;
                                        case 1: statusSymbol = '🔥'; statusTitle = 'Bruciato'; break;
                                        case 2: statusSymbol = '😵'; statusTitle = 'Confuso'; break;
                                        case 3: statusSymbol = '🛑'; statusTitle = 'Paralizzato'; break;
                                        case 4: statusSymbol = '💀'; statusTitle = 'Avvelenato'; break;
                                        default: statusSymbol = ''; statusTitle = '';
                                    }
                                    classes.push("text-3xl");
                                    if (isActive) {
                                        classes.push(statusColors[index], 'scale-110', 'ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-opacity-75');
                                    } else {
                                        classes.push('bg-gray-600', 'text-gray-300');
                                    }
                                    if (isActivePokemon && !isPlayerSlotDisabled) { 
                                        classes.push('cursor-pointer', 'hover:bg-gray-500');
                                    } else {
                                        classes.push('cursor-not-allowed', 'opacity-50');
                                    }
                                    return (<div key={index} className={classes.join(' ')} onClick={isPlayerSlotDisabled ? null : () => toggleStatus(index)} title={statusTitle}>{statusSymbol}</div>);
                                })}
                            </div>
                            <div className="flex justify-center w-full mt-2 space-x-4 max-w-xs">
                                {role === 'player' && (
                                    <>
                                        <button onClick={handleSendToBox} className={`btn-theme btn-purple px-4 py-2 text-base flex-grow ${(!cardData || isPlayerSlotDisabled) ? 'opacity-50 cursor-not-allowed' : ''}`} title="Invia al Box" disabled={!cardData || isPlayerSlotDisabled}>INVIA AL BOX</button>
                                        <button onClick={handleBoxRecallClick} className={`btn-theme btn-purple px-4 py-2 text-base flex-grow ${isPlayerSlotDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} title="Richiama dal Box" disabled={isPlayerSlotDisabled}>BOX</button>
                                    </>
                                )}
                                <button onClick={requestFullSlotReset} className={`icon-btn btn-red ${(!cardData || isPlayerSlotDisabled) ? 'opacity-50 cursor-not-allowed' : ''}`} title="Resetta Tutto lo Slot" disabled={!cardData || isPlayerSlotDisabled}>🗑️</button>
                            </div>
                        </>
                    )}
                    {isConfirmModalOpen && (
                        <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-20 rounded-lg p-6">
                            {confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') && (<p className="text-white text-center mb-6 text-xl font-bold">Vuoi mantenere i dati della carta precedente o azzerarli?</p>)}
                            {confirmAction && confirmAction.type === 'reset_full_slot' && (<p className="text-white text-center mb-6 text-xl font-bold">Sei sicuro di voler resettare tutti i dati di questo slot? Questa azione è irreversibile.</p>)}
                            {confirmAction && confirmAction.type === 'send_to_box' && (<p className="text-white text-center mb-6 text-xl font-bold">VUOI INVIARE AL BOX?</p>)}
                            {confirmAction && confirmAction.type === 'save_and_recall_from_box' && (<p className="text-white text-center mb-6 text-xl font-bold">VUOI SALVARE QUESTA CARTA NEL BOX PRIMA DI SOSTITUIRLA?</p>)}
                            <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                                {confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') && (<button onClick={() => handleConfirmAction(confirmAction.type, false)} className="btn-theme btn-green text-base md:text-lg">Mantieni Dati</button>)}
                                <button onClick={() => handleConfirmAction(confirmAction.type, true)} className="btn-theme btn-red text-base md:text-lg">{confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') ? 'Azzera Dati' : 'Sì'}</button>
                                {(confirmAction && (confirmAction.type === 'reset_full_slot' || confirmAction.type === 'send_to_box' || confirmAction.type === 'save_and_recall_from_box' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_palestre')) && (<button onClick={() => { setIsConfirmModal(false); }} className="btn-theme btn-gray text-base md:text-lg">No</button>)}
                            </div>
                        </div>
                    )}
                    <CameraModal isOpen={showCameraModal} onClose={() => { setShowCameraModal(false); }} onCapture={handleNewImageSelection} />
                    <ZoomModal isOpen={showZoomModal} imageUrl={cardImage} onClose={() => setShowZoomModal(false)} />
                    <RecallFromBoxModal isOpen={showRecallFromBoxModal} onClose={() => { setShowRecallFromBoxModal(false); }} boxCards={boxCards} onSelectCardFromBox={(selectedCard, boxCardIndex) => { onRecallFromBox(selectedCard, slotIndex, boxCardIndex); setShowRecallFromBoxModal(false); resetCardView(); }} onDeleteCardFromBox={(indexToDelete) => { onRecallFromBox(null, null, indexToDelete, true); }} />
                    <SelectFromDatabaseModal isOpen={showSelectFromDatabaseModal} onClose={() => setShowSelectFromDatabaseModal(false)} onSelectCardFromDatabase={handleSelectCardFromDatabase} cardsData={pokemonDbCards} isLoading={isDbLoading} error={dbError} />
                    <SelectFromSupabaseTableModal isOpen={showSelectFromSupabaseTableModal} onClose={() => setShowSelectFromSupabaseTableModal(false)} onSelectTableAndFetchRandom={handleSelectRandomCardFromSupabaseTable} />
                    <SelectFromPalestreModal isOpen={showSelectFromPalestreModal} onClose={() => setShowSelectFromPalestreModal(false)} onSelectCardFromPalestre={handleSelectCardFromPalestreCallback} cardsData={palestreDbCards} isLoading={isDbLoading} error={dbError} />
                    <AddCardChoiceModal isOpen={showAddCardChoiceModal} onClose={() => { setShowAddCardChoiceModal(false); }} onChooseNew={handleChooseNewCard} onChooseFromBox={handleChooseFromBox} onChooseFromDatabase={handleChooseFromDatabase} onChooseFromSupabaseTable={handleChooseFromSupabaseTable} onChooseFromPalestre={handleChooseFromPalestre} />
                </div>
            );
        }

        function MedalDisplay({ gymMedals, onToggleMedal }) { 
            const medalSymbols = ['⚫', '💧', '⚡', '🌈', '❤️', '🟠', '🌋', '🌿']; 
            const medalTitles = ['Medaglia Roccia', 'Medaglia Cascata', 'Medaglia Saetta', 'Medaglia Arcobaleno', 'Medaglia Anima', 'Medaglia Terra', 'Medaglia Vulcano', 'Medaglia Foglia'];
            return (
                <div className="flex flex-col items-center p-3 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 max-w-sm w-full">
                    <h3 className="text-xl font-bold text-yellow-300 mb-4">PALESTRE</h3>
                    <div className="flex flex-wrap justify-center space-x-2 space-y-2">
                        {gymMedals.map((isActive, index) => {
                            const classes = ["medal-icon", isActive ? "bg-yellow-300 text-gray-800 ring-yellow-500" : "bg-gray-600 text-gray-300 hover:bg-gray-500"];
                            classes.push((index === 0) ? "text-xl" : "text-3xl");
                            return (<div key={index} className={classes.join(' ')} onClick={() => onToggleMedal(index)} title={medalTitles[index]}>{medalSymbols[index]}</div>);
                        })}
                    </div>
                </div>
            );
        }

        function EliteFourDisplay({ eliteFourMedals, onToggleMedal }) { 
            const eliteFourSymbols = ['❄️', '✊', '👻', '🐉']; 
            const eliteFourTitles = ['Superquattro Lorelei', 'Superquattro Bruno', 'Superquattro Agatha', 'Superquattro Lance'];
            return (
                <div className="flex flex-col items-center p-3 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 max-w-sm w-full mt-8 pb-20"> 
                    <h3 className="text-xl font-bold text-yellow-300 mb-4">SUPERQUATTRO</h3>
                    <div className="flex flex-wrap justify-center space-x-2 space-y-2">
                        {eliteFourMedals.map((isActive, index) => {
                            const classes = ["elite-four-icon", isActive ? "active" : ""];
                            classes.push((index === 0) ? "text-xl" : "text-3xl");
                            return (<div key={index} className={classes.join(' ')} onClick={() => onToggleMedal(index)} title={eliteFourTitles[index]}>{eliteFourSymbols[index]}</div>);
                        })}
                    </div>
                </div>
            );
        }

        function DiceRoller({ title, isAttackRoller, isDiceRollDisabled, onConfusedRollAttempt, isMyTurn, onDiceRollComplete, onDisplayGlobalBanner, isCaptureRoller, onCaptureCoinFlipNeeded }) {
            const [numberOfDice, setNumberOfDice] = React.useState(1);
            const [diceResults, setDiceResults] = React.useState([]);
            const [rollOutcomeText, setRollOutcomeText] = React.useState('');
            
            const handleRoll = async () => {
                setDiceResults([]);
                setRollOutcomeText('');

                if (isAttackRoller) {
                    if (isDiceRollDisabled === 'paralyzed') {
                        onDisplayGlobalBanner("Lancio bloccato: Pokémon Paralizzato!", 'info', 3000);
                        return; 
                    }
                    if (isDiceRollDisabled === 'confused') { 
                        const shouldProceed = await onConfusedRollAttempt();
                        if (!shouldProceed) return;
                    }
                }

                const newResults = [];
                let foursCount = 0;
                let onesCount = 0;
                for (let i = 0; i < numberOfDice; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    newResults.push(roll);
                    if (roll === 4) foursCount++;
                    if (roll === 1) onesCount++;
                }
                setDiceResults(newResults);

                if (isAttackRoller) {
                    const isCritical = (numberOfDice <= 3 && foursCount >= 2) || (numberOfDice > 3 && foursCount >= 3);
                    if (isCritical) {
                        setRollOutcomeText('Attacco Critico!');
                        onDisplayGlobalBanner("Attacco Critico!", 'attack_critical', 3000);
                    } else if (onesCount >= 1) {
                        setRollOutcomeText('Attacco Fallito!');
                        onDisplayGlobalBanner("Attacco Fallito!", 'attack_failed', 3000);
                    } else {
                        setRollOutcomeText('Attacco Riuscito!');
                    }
                    onDiceRollComplete(); 
                } else if (!isCaptureRoller) { // Retreat Dice
                    if (onesCount >= 1) {
                        setRollOutcomeText('Ritirata Fallita!');
                        onDisplayGlobalBanner("Ritirata Fallita!", 'retreat_failed', 3000);
                    } else {
                        setRollOutcomeText('Ritirata Riuscita!');
                        onDisplayGlobalBanner("Ritirata Riuscita!", 'retreat_success', 3000);
                    }
                    onDiceRollComplete(); 
                } else { // Capture Dice
                    if (onesCount >= 1) {
                        onDisplayGlobalBanner("Cattura Fallita!", 'capture_fail', 3000);
                        onDiceRollComplete(); 
                    } else {
                        onCaptureCoinFlipNeeded();
                    }
                }
            };

            let isDisabled = !isMyTurn; 
            if (isAttackRoller) {
                isDisabled = isDisabled || isDiceRollDisabled === 'asleep' || isDiceRollDisabled === 'paralyzed';
            }

            return (
                <div className="bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col items-center justify-center border-4 border-yellow-400 gap-4 flex-1 max-w-xs w-full mb-4"> 
                    <h2 className="text-lg font-bold text-yellow-300 whitespace-nowrap">{title}</h2>
                    <div className="flex items-center space-x-2">
                        <label htmlFor={`num-dice-${title}`} className="counter-label text-white text-sm">N°:</label>
                        <select id={`num-dice-${title}`} value={numberOfDice} onChange={(e) => e.stopPropagation() || setNumberOfDice(parseInt(e.target.value))} className="bg-gray-700 text-white rounded-md p-1 text-sm border border-gray-600 focus:outline-none focus:ring-2 focus:ring-yellow-500">
                            {[1, 2, 3, 4, 5, 6].map(num => (<option key={num} value={num}>{num}</option>))}
                        </select>
                    </div>
                    <button onClick={handleRoll} className="btn-theme btn-green text-base px-3 py-1 disabled:opacity-50 disabled:cursor-not-allowed w-full" disabled={isDisabled}>Lancia</button>
                    {diceResults.length > 0 && (<div className="flex flex-wrap justify-center gap-2 text-3xl font-extrabold text-white mt-2">{diceResults.map((result, index) => (<span key={index} className="bg-gray-900 p-2 rounded-md border-2 border-yellow-500 shadow-md flex-shrink-0">{diceFaces[result]}</span>))}</div>)}
                    {rollOutcomeText && (<p className="text-lg font-bold text-white mt-2 text-center">{rollOutcomeText}</p>)}
                </div>
            );
        }

        function TurnIndicator({ isMyTurn, onToggleTurn, role, disabled }) { 
            const icon = isMyTurn ? '🏁' : '🚩'; 
            const title = isMyTurn ? 'Il tuo turno' : 'Turno avversario';
            const bgColor = isMyTurn ? 'bg-green-500' : 'bg-red-500';
            const borderColor = isMyTurn ? 'border-green-700' : 'border-red-700';
            return (<button onClick={onToggleTurn} className={`flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md transition-all duration-200 ease-in-out border-4 ${bgColor} ${borderColor} hover:scale-105 active:scale-95 mb-4 ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`} title={title} disabled={disabled}>{icon}</button>);
        }

        function CaptureCoinFlipModal({ isOpen, onFlipCoin, coinResult, finalOutcome }) {
            if (!isOpen) return null;
            return (
                <div className="capture-coin-modal-overlay">
                    <div className="capture-coin-modal-content">
                        {!coinResult && (<><h2>Lancio della Moneta di Cattura!</h2><button onClick={onFlipCoin}>Lancia Moneta</button></>)}
                        {coinResult && (<><h2>Risultato: {coinResult === 'heads' ? 'TESTA' : 'CROCE'}</h2><p className={`capture-coin-result ${finalOutcome === 'PRESO' ? 'success' : 'fail'}`}>{finalOutcome}</p></>)}
                    </div>
                </div>
            );
        }

        function BoxView({ boxCards, onBackToMain, onDeleteCardFromBox, role }) { 
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);

            const handleDeleteClick = (index) => {
                if (role === 'master') {
                    onDeleteCardFromBox(index);
                }
            };

            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };

            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-gray-700 to-gray-900 p-4 relative">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8 text-center">{role === 'player' ? 'IL TUO ZAINO POKÉMON' : 'IL TUO BOX POKÉMON'}</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    {boxCards.length === 0 ? (<p className="text-gray-400 text-xl mt-8">{role === 'player' ? 'Il tuo zaino è vuoto.' : 'Il tuo box è vuoto.'}</p>) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-4xl">
                            {boxCards.map((card, index) => (
                                <div key={index} className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center cursor-pointer hover:bg-gray-700 transition-colors" onClick={() => handleCardClick(card.imageUrl)}>
                                    <img src={card.imageUrl} alt={`Carta nel Box ${index + 1}`} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2" onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm font-semibold">HP Base: {card.baseHp}</p>
                                    <p className="text-gray-300 text-sm font-semibold">EXP: {card.exp}</p>
                                    {role === 'master' && (<button onClick={(e) => {e.stopPropagation(); handleDeleteClick(index);}} className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700" title="Elimina dal Box">X</button>)}
                                </div>
                            ))}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                </div>
            );
        }

        function NegozioView({ negozioCards, onBackToMain, isDbLoading, dbError, role }) { 
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);

            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };

            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-indigo-700 to-purple-900 p-4 relative">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8 text-center">NEGOZIO DI CARTE</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    {isDbLoading && <p className="text-blue-300 text-xl mt-8">Caricamento...</p>}
                    {dbError && <p className="text-red-500 text-xl mt-8">Errore: {dbError}</p>}
                    {!isDbLoading && !dbError && negozioCards.length === 0 ? (<p className="text-gray-400 text-xl mt-8">Il negozio è vuoto.</p>) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-4xl">
                            {negozioCards.map((card, index) => (
                                <div key={card.id || index} className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center cursor-pointer hover:bg-gray-700 transition-colors" onClick={() => handleCardClick(card.imageUrl)}>
                                    <img src={card.imageUrl} alt={card.name || `Carta Negozio ${index + 1}`} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2" onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm font-semibold">{card.name || 'Carta Sconosciuta'}</p>
                                    {card.baseHp > 0 && (<p className="text-gray-400 text-xs">HP: {card.baseHp}</p>)}
                                    {card.cost !== undefined && (<p className="text-yellow-400 text-base font-bold mt-1">Costo: {card.cost} 💰</p>)}
                                </div>
                            ))}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                </div>
            );
        }

        function ZainoView({ playerZainoCards, onBackToMain, onAddCardToZaino, onUpdateZainoCardQuantity, onDeleteZainoCard, trainersCardDbCards, isDbLoading, dbError }) {
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);
            const [showAddTrainerCardModal, setShowAddTrainerCardModal] = React.useState(false);

            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };

            const handleAddTrainerCard = (selectedCard) => {
                onAddCardToZaino(selectedCard);
                setShowAddTrainerCardModal(false);
            };

            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-indigo-700 to-teal-900 p-4 relative">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8 text-center">IL TUO ZAINO</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    <button onClick={() => setShowAddTrainerCardModal(true)} className="btn-theme btn-green px-6 py-3 text-lg mb-8">Aggiungi Carta Allenatore</button>
                    {playerZainoCards.length === 0 ? (<p className="text-gray-400 text-xl mt-8">Il tuo zaino è vuoto.</p>) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-4xl">
                            {playerZainoCards.map((card) => (
                                <div key={card.id} className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center">
                                    <img src={card.imageUrl} alt={card.name} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2 cursor-pointer" onClick={() => handleCardClick(card.imageUrl)} onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm font-semibold text-center">{card.name}</p>
                                    <div className="flex items-center mt-2 space-x-2">
                                        <button onClick={() => onUpdateZainoCardQuantity(card.id, -1)} className="btn-theme btn-red px-2 py-0.5 text-base rounded-md" disabled={card.quantity <= 1}>-</button>
                                        <span className="text-white text-lg font-bold">Qtà: {card.quantity}</span>
                                        <button onClick={() => onUpdateZainoCardQuantity(card.id, 1)} className="btn-theme btn-green px-2 py-0.5 text-base rounded-md">+</button>
                                    </div>
                                    <button onClick={() => onDeleteZainoCard(card.id)} className="btn-theme btn-gray text-xs mt-2 px-3 py-1 rounded-md">Rimuovi</button>
                                </div>
                            ))}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                    <SelectFromTrainersCardDatabaseModal isOpen={showAddTrainerCardModal} onClose={() => setShowAddTrainerCardModal(false)} onSelectTrainerCard={handleAddTrainerCard} cardsData={trainersCardDbCards} isLoading={isDbLoading} error={dbError} />
                </div>
            );
        }

        function CoinFlipper() {
            const [numCoins, setNumCoins] = React.useState(1);
            const [results, setResults] = React.useState([]);
            
            const handleFlip = () => {
                const newResults = [];
                for (let i = 0; i < numCoins; i++) {
                    newResults.push(Math.random() < 0.5 ? 'Testa' : 'Croce');
                }
                setResults(newResults);
            };

            return (
                <div className="bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col items-center justify-center border-4 border-yellow-400 gap-4 flex-1 max-w-xs w-full mb-4 relative">
                    <h2 className="text-lg font-bold text-yellow-300 whitespace-nowrap">LANCIO MONETE</h2>
                    <div className="flex items-center space-x-2">
                        <label htmlFor="num-coins" className="counter-label text-white text-sm">N°:</label>
                        <select id="num-coins" value={numCoins} onChange={(e) => setNumCoins(parseInt(e.target.value))} className="bg-gray-700 text-white rounded-md p-1 text-sm border border-gray-600 focus:outline-none focus:ring-2 focus:ring-yellow-500">
                            {[1, 2, 3, 4, 5].map(num => (<option key={num} value={num}>{num}</option>))}
                        </select>
                    </div>
                    <button onClick={handleFlip} className="btn-theme btn-yellow text-base px-3 py-1 w-full">Lancia Monete</button>
                    {results.length > 0 && (<div className="mt-4 flex flex-wrap justify-center gap-2 text-xl font-bold text-yellow-200">{results.map((result, index) => (<span key={index} className={`px-3 py-1 rounded-full ${result === 'Testa' ? 'bg-green-600' : 'bg-red-600'} text-white shadow-md`}>{result === 'Testa' ? '🪙 T' : '🪙 C'}</span>))}</div>)}
                </div>
            );
        }

        function GlobalEventBanner({ isVisible, message, type }) {
            if (!isVisible) return null;
            let bannerClasses = "fixed top-0 left-1/2 transform -translate-x-1/2 w-11/12 max-w-lg p-4 mt-4 rounded-xl shadow-2xl text-center text-white font-extrabold text-2xl z-50 transition-all duration-300 ease-in-out";
            let specificTypeClasses = "";
            switch (type) {
                case 'status_woke_up': case 'retreat_success': case 'capture_success': case 'attack_critical': case 'confusion_miss': case 'purchase_success': specificTypeClasses = "bg-green-700 border-4 border-green-400"; break;
                case 'status_cleared': case 'info': specificTypeClasses = "bg-blue-700 border-4 border-blue-400"; break;
                case 'damage_burn': case 'damage_poison': case 'attack_failed': case 'retreat_failed': case 'capture_fail': case 'confusion_hit': case 'purchase_fail': specificTypeClasses = "bg-red-700 border-4 border-red-400"; break;
                default: specificTypeClasses = "bg-gray-700 border-4 border-gray-400";
            }
            return (<div className={`${bannerClasses} ${specificTypeClasses}`}>{message}</div>);
        }
        
        function TemporaryCardDisplay({ imageUrl }) {
            if (!imageUrl) return null;

            return (
                <div className="zoom-modal-overlay" style={{ zIndex: 2000, backgroundColor: 'rgba(0, 0, 0, 0.98)' }}>
                    <div className="zoom-modal-content">
                        <img src={imageUrl} alt="Anteprima Carta Casuale" style={{ maxHeight: '80vh', maxWidth: '80vw', borderRadius: '15px', border: '4px solid #FACC15' }} />
                    </div>
                </div>
            );
        }

        function PrizePreviewDisplay({ prizeData }) {
            if (!prizeData) return null;

            return (
                <div className="zoom-modal-overlay" style={{ zIndex: 2000, backgroundColor: 'rgba(0, 0, 0, 0.98)' }}>
                    <div className="flex flex-col items-center justify-center">
                        <h2 className="text-5xl font-extrabold text-yellow-300 mb-4 text-center drop-shadow-lg">PREMIO!</h2>
                        <div className="flex space-x-4">
                            {prizeData.cards.map((card, index) => (
                                <img key={index} src={card.imageUrl} alt={`Premio ${index + 1}`} style={{ height: '50vh', maxHeight: '350px', borderRadius: '10px', border: '3px solid #FACC15' }} />
                            ))}
                        </div>
                        <h3 className="text-4xl font-bold text-green-400 mt-4 text-center drop-shadow-md">+{prizeData.currency} $</h3>
                    </div>
                </div>
            );
        }

        function DefeatPreviewDisplay({ defeatData }) {
            if (!defeatData) return null;

            return (
                <div className="zoom-modal-overlay" style={{ zIndex: 2000, backgroundColor: 'rgba(0, 0, 0, 0.98)' }}>
                    <div className="flex flex-col items-center justify-center">
                        <h2 className="text-5xl font-extrabold text-red-500 mb-4 text-center drop-shadow-lg">{defeatData.type === 'fuga' ? 'FUGA!' : 'SCONFITTA'}</h2>
                        <h3 className="text-4xl font-bold text-red-400 mt-4 text-center drop-shadow-md">-{defeatData.currency} $</h3>
                    </div>
                </div>
            );
        }

        function VictoryDefeatModal({ isOpen, onClose, onVictoryClick, onDefeatClick }) {
            const [outcome, setOutcome] = React.useState(null);

            const handleBackOrClose = () => {
                if (outcome) {
                    setOutcome(null);
                } else {
                    onClose();
                }
            };
            
            React.useEffect(() => {
                if (!isOpen) {
                    setOutcome(null);
                }
            }, [isOpen]);

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center w-full max-w-md">
                        <h2 className="text-3xl font-bold text-yellow-300 mb-6 text-center">
                            {outcome === null ? 'Seleziona Esito' : (outcome === 'victory' ? 'Vittoria!' : 'Sconfitta')}
                        </h2>

                        {outcome === null && (
                            <div className="flex space-x-4">
                                <button onClick={() => setOutcome('victory')} className="btn-theme btn-green px-8 py-4 text-2xl">Vittoria</button>
                                <button onClick={() => setOutcome('defeat')} className="btn-theme btn-red px-8 py-4 text-2xl">Sconfitta</button>
                            </div>
                        )}

                        {outcome === 'victory' && (
                            <div className="flex flex-col space-y-3 w-full">
                                <button onClick={() => onVictoryClick({ currency: 1, prizes: 0 })} className="btn-theme btn-blue w-full">Cattura Pokemon Selvatico</button>
                                <button onClick={() => onVictoryClick({ currency: 1, prizes: 1 })} className="btn-theme btn-blue w-full">Sconfitta Pokemon Selvatico</button>
                                <button onClick={() => onVictoryClick({ currency: 2, prizes: 1 })} className="btn-theme btn-blue w-full">Vittoria vs Allenatore</button>
                                <button onClick={() => onVictoryClick({ currency: 4, prizes: 2 })} className="btn-theme btn-blue w-full">Vittoria vs Palestra/Superquattro</button>
                                <button onClick={() => onVictoryClick({ currency: 8, prizes: 2 })} className="btn-theme btn-blue w-full">Vittoria vs Altro Giocatore</button>
                            </div>
                        )}

                        {outcome === 'defeat' && (
                            <div className="flex flex-col space-y-3 w-full">
                                <button onClick={() => onDefeatClick({ currency: 2, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Allenatore</button>
                                <button onClick={() => onDefeatClick({ currency: 3, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Palestra/Superquattro</button>
                                <button onClick={() => onDefeatClick({ currency: 6, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Altro Giocatore</button>
                                <button onClick={() => onDefeatClick({ currency: 1, type: 'fuga' })} className="btn-theme btn-gray w-full">Fuga</button>
                            </div>
                        )}

                        <button onClick={handleBackOrClose} className="btn-theme btn-gray mt-8 px-6 py-2 text-lg">
                            {outcome === null ? 'Annulla' : 'Indietro'}
                        </button>
                    </div>
                </div>
            );
        }
        
        function AssignExpModal({ isOpen, onClose, onConfirm, cards }) {
            const [selectedIndices, setSelectedIndices] = React.useState([]);

            const handleToggle = (index) => {
                setSelectedIndices(prev => 
                    prev.includes(index) ? prev.filter(i => i !== index) : [...prev, index]
                );
            };

            const handleSubmit = () => {
                onConfirm(selectedIndices);
                onClose();
            };
            
            React.useEffect(() => {
                if (!isOpen) {
                    setSelectedIndices([]);
                }
            }, [isOpen]);

            if (!isOpen) return null;

            const participatingPokemon = cards.map((card, index) => ({ card, index })).filter(item => item.card && item.card.baseHp > 0);

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-blue-400 flex flex-col items-center w-full max-w-2xl">
                        <h2 className="text-3xl font-bold text-blue-300 mb-6 text-center">Assegna Punti Esperienza</h2>
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full mb-6">
                            {participatingPokemon.map(({ card, index }) => (
                                <div 
                                    key={index}
                                    className={`relative p-2 rounded-lg cursor-pointer transition-all duration-200 ${selectedIndices.includes(index) ? 'bg-blue-700 ring-4 ring-blue-400' : 'bg-gray-700'}`}
                                    onClick={() => handleToggle(index)}
                                >
                                    <img src={card.imageUrl} alt={`Pokemon in slot ${index + 1}`} className="w-24 h-32 object-cover rounded-md mx-auto" />
                                    {selectedIndices.includes(index) && (
                                        <div className="absolute top-1 right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center text-white font-bold text-lg">✓</div>
                                    )}
                                </div>
                            ))}
                        </div>
                        <button onClick={handleSubmit} className="btn-theme btn-green px-8 py-3 text-xl">Conferma</button>
                    </div>
                </div>
            );
        }

        function MovementModal({ isOpen, onClose, onRoll }) {
            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-cyan-400 flex flex-col items-center w-full max-w-md">
                        <h2 className="text-3xl font-bold text-cyan-300 mb-6 text-center">Movimento</h2>
                        <p className="text-white text-lg mb-6">Usi la bici?</p>
                        <div className="flex space-x-4">
                            <button onClick={() => onRoll(true)} className="btn-theme btn-green px-8 py-3 text-xl">Sì</button>
                            <button onClick={() => onRoll(false)} className="btn-theme btn-red px-8 py-3 text-xl">No</button>
                        </div>
                        <button onClick={onClose} className="btn-theme btn-gray mt-8 px-6 py-2 text-lg">Annulla</button>
                    </div>
                </div>
            );
        }

        function MovementResultDisplay({ result }) {
            if (!result) return null;
            
            const diceSymbol = diceFaces[result] || result;

            return (
                <div className="zoom-modal-overlay" style={{ zIndex: 2000, backgroundColor: 'rgba(0, 0, 0, 0.98)' }}>
                    <div className="flex flex-col items-center justify-center text-white">
                        <span className="text-9xl">{diceSymbol}</span>
                    </div>
                </div>
            );
        }

        function PlayerApp({ onSwitchRole, displayGlobalBanner, clearGlobalBanner, showTemporaryCard, showPrizePreview, showDefeatPreview, showMovementResultPreview }) {
            const rolePrefix = 'player';
            const [cards, setCards] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_gameCards`)) || Array(6).fill(null));
            const [boxCards, setBoxCards] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_pokemonBoxCards`)) || []);
            const [playerZainoCards, setPlayerZainoCards] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_playerZainoCards`)) || []);
            const [negozioCards, setNegozioCards] = React.useState([]); 
            const [currentView, setCurrentView] = React.useState('main');
            const [pokemonDbCards, setPokemonDbCards] = React.useState([]); 
            const [trainersDbCards, setTrainersDbCards] = React.useState([]);
            const [palestreDbCards, setPalestreDbCards] = React.useState([]); 
            const [trainersCardDbCards, setTrainersCardDbCards] = React.useState([]);
            const [isDbLoading, setIsDbLoading] = React.useState(true);
            const [dbError, setDbError] = React.useState(null);
            const [showVictoryDefeatModal, setShowVictoryDefeatModal] = React.useState(false);
            const [showAssignExpModal, setShowAssignExpModal] = React.useState(false);
            const [pendingPrize, setPendingPrize] = React.useState(null);
            const [showMovementModal, setShowMovementModal] = React.useState(false);
            const [showClearConfirm, setShowClearConfirm] = React.useState(false);

            React.useEffect(() => {
                async function getSupabaseCards() {
                    try {
                        setIsDbLoading(true);
                        setDbError(null);
                        const { data: pokemonData, error: pokemonError } = await supabase.from('pokemon_cards').select('*, hp');
                        if (pokemonError) throw pokemonError;
                        setPokemonDbCards(pokemonData.map(c => ({...c, baseHp: c.hp, imageUrl: c.image_url})));
                        const { data: trainersData, error: trainersError } = await supabase.from('pokemon_allenatori').select('*');
                        if (trainersError) throw trainersError;
                        setTrainersDbCards(trainersData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: palestreData, error: palestreError } = await supabase.from('palestre').select('*');
                        if (palestreError) throw palestreError;
                        setPalestreDbCards(palestreData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: trainersCardData, error: trainersCardError } = await supabase.from('trainers_card').select('*');
                        if (trainersCardError) throw trainersCardError;
                        setTrainersCardDbCards(trainersCardData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: negozioData, error: negozioError } = await supabase.from('negozio').select('*');
                        if (negozioError) throw negozioError;
                        setNegozioCards(negozioData.map(c => ({...c, imageUrl: c.image_url, baseHp: c.base_hp})));
                    } catch (err) {
                        console.error("Supabase Error:", err.message);
                        setDbError(err.message);
                        setPokemonDbCards(localPokemonCardsDatabase);
                    } finally {
                        setIsDbLoading(false);
                    }
                }
                getSupabaseCards();
            }, []); 

            const [globalCurrency, setGlobalCurrency] = React.useState(() => parseInt(localStorage.getItem(`${rolePrefix}_globalCurrency`) || '0'));
            const [gymMedals, setGymMedals] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_gymMedals`)) || Array(8).fill(false));
            const [eliteFourMedals, setEliteFourMedals] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_eliteFourMedals`)) || Array(4).fill(false));
            const [isMyTurn, setIsMyTurn] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_isMyTurn`)) || false);
            const [showCaptureCoinFlipModal, setShowCaptureCoinFlipModal] = React.useState(false);
            const [captureCoinFlipResult, setCaptureCoinFlipResult] = React.useState(null);
            const [captureFinalOutcome, setCaptureFinalOutcome] = React.useState(null);
            const [playerOverallExp, setPlayerOverallExp] = React.useState(() => parseInt(localStorage.getItem(`${rolePrefix}_playerOverallExp`) || '0'));

            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_gameCards`, JSON.stringify(cards)); }, [cards]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_pokemonBoxCards`, JSON.stringify(boxCards)); }, [boxCards]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_playerZainoCards`, JSON.stringify(playerZainoCards)); }, [playerZainoCards]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_globalCurrency`, globalCurrency.toString()); }, [globalCurrency]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_gymMedals`, JSON.stringify(gymMedals)); }, [gymMedals]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_eliteFourMedals`, JSON.stringify(eliteFourMedals)); }, [eliteFourMedals]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_isMyTurn`, JSON.stringify(isMyTurn)); }, [isMyTurn]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_playerOverallExp`, playerOverallExp.toString()); }, [playerOverallExp]);

            const updateCardInSlot = React.useCallback((index, cardData) => {
                setCards(prev => {
                    const newCards = [...prev];
                    newCards[index] = cardData;
                    return newCards;
                });
            }, []);

            const handleActivePokemonToggle = React.useCallback((clickedSlotIndex) => {
                const currentActiveCard = cards.find(c => c && c.isActivePokemon);
                if (isMyTurn && currentActiveCard && currentActiveCard.statuses[3]) {
                    displayGlobalBanner("Pokémon Paralizzato non può essere sostituito!", 'info', 3000);
                    return;
                }
                setCards(prev => prev.map((card, idx) => {
                    if (!card) return null;
                    let newIsActive = (idx === clickedSlotIndex) ? !card.isActivePokemon : false;
                    let newStatuses = (idx === clickedSlotIndex && !newIsActive) || (idx !== clickedSlotIndex) ? Array(5).fill(false) : [...card.statuses];
                    return { ...card, isActivePokemon: newIsActive, statuses: newStatuses };
                }));
            }, [isMyTurn, cards, displayGlobalBanner]);

            const adjustGlobalCurrency = (amount) => setGlobalCurrency(prev => Math.max(0, prev + amount));
            const handleGlobalCurrencyChange = (e) => setGlobalCurrency(parseInt(e.target.value) || 0);
            const toggleGymMedal = (index) => setGymMedals(prev => { const n = [...prev]; n[index] = !n[index]; return n; });
            const toggleEliteFourMedal = (index) => setEliteFourMedals(prev => { const n = [...prev]; n[index] = !n[index]; return n; });

            const activeCardForDice = cards.find(c => c && c.isActivePokemon);
            const diceRollDisableStatus = activeCardForDice ? (activeCardForDice.statuses[0] ? 'asleep' : (activeCardForDice.statuses[2] ? 'confused' : (activeCardForDice.statuses[3] ? 'paralyzed' : false))) : false;

            const handleConfusedRollAttempt = React.useCallback(async () => {
                const result = Math.random() < 0.5 ? 'Testa' : 'Croce';
                if (result === 'Croce') {
                    setCards(prev => prev.map(c => c && c.isActivePokemon ? { ...c, damageTaken: c.damageTaken + 30 } : c));
                    displayGlobalBanner("Confusione: Colpito da solo!", 'confusion_hit', 3000);
                    setTimeout(() => toggleMyTurn(), 2000);
                    return false;
                } else {
                    displayGlobalBanner("Confusione: Attacco riuscito!", 'confusion_miss', 3000);
                    return true;
                }
            }, [cards, displayGlobalBanner, toggleMyTurn]);

            const toggleMyTurn = React.useCallback(() => {
                clearGlobalBanner();
                setIsMyTurn(prev => {
                    const newTurn = !prev;
                    const active = cards.find(c => c && c.isActivePokemon);
                    if (active) {
                        if (!newTurn && active.statuses[3]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, statuses: [c.statuses[0], c.statuses[1], c.statuses[2], false, c.statuses[4]]} : c));
                            displayGlobalBanner("Non più paralizzato!", 'status_cleared', 3000);
                        }
                        if (active.statuses[0]) {
                            if (Math.random() < 0.5) {
                                setCards(p => p.map(c => c && c.isActivePokemon ? {...c, statuses: [false, c.statuses[1], c.statuses[2], c.statuses[3], c.statuses[4]]} : c));
                                displayGlobalBanner("Si è svegliato!", 'status_woke_up', 3000);
                            } else {
                                displayGlobalBanner("Resta addormentato!", 'info', 3000);
                            }
                        }
                        if (newTurn && active.statuses[1]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, damageTaken: c.damageTaken + 20} : c));
                            displayGlobalBanner("Subisce danni da bruciatura!", 'damage_burn', 3000);
                        }
                        if (newTurn && active.statuses[4]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, damageTaken: c.damageTaken + 10} : c));
                            displayGlobalBanner("Subisce danni da veleno!", 'damage_poison', 3000);
                        }
                    }
                    return newTurn;
                });
            }, [cards, displayGlobalBanner, clearGlobalBanner]);

            const handleCaptureCoinFlipNeeded = React.useCallback(() => {
                setShowCaptureCoinFlipModal(true);
                setCaptureCoinFlipResult(null);
                setCaptureFinalOutcome(null);
            }, []);

            const performCaptureCoinFlip = React.useCallback(() => {
                const result = Math.random() < 0.5 ? 'heads' : 'tails';
                setCaptureCoinFlipResult(result);
                const final = result === 'tails' ? 'PRESO' : 'FALLITA';
                setCaptureFinalOutcome(final);
                displayGlobalBanner(final === 'PRESO' ? 'Pokémon Catturato!' : 'Cattura Fallita!', final === 'PRESO' ? 'capture_success' : 'capture_fail', 3000);
                setTimeout(() => {
                    setShowCaptureCoinFlipModal(false);
                    toggleMyTurn();
                }, 2000); 
            }, [displayGlobalBanner, toggleMyTurn]);

            const sendCardToBox = React.useCallback((card, slot) => {
                setBoxCards(prev => [...prev, card]);
                updateCardInSlot(slot, null);
            }, [updateCardInSlot]);

            const recallCardFromBox = React.useCallback((card, slot, boxIndex, delOnly) => {
                if (delOnly) {
                    setBoxCards(prev => prev.filter((_, i) => i !== boxIndex));
                } else {
                    updateCardInSlot(slot, {...card, damageTaken: 0, statuses: Array(5).fill(false), isActivePokemon: false});
                    setBoxCards(prev => prev.filter((_, i) => i !== boxIndex));
                }
            }, [updateCardInSlot]);

            const deleteCardFromBox = React.useCallback((index) => {
                setBoxCards(prev => prev.filter((_, i) => i !== index));
            }, []);

            const addCardToZaino = React.useCallback((card, isPrize = false) => {
                if (!isPrize && globalCurrency < card.cost) {
                    displayGlobalBanner(`Non hai abbastanza soldi!`, 'purchase_fail', 3000);
                    return;
                }
                if (!isPrize) {
                    setGlobalCurrency(prev => prev - card.cost);
                }
                setPlayerZainoCards(prev => {
                    const existing = prev.find(c => c.id === card.id);
                    if (existing) {
                        return prev.map(c => c.id === card.id ? {...c, quantity: c.quantity + 1} : c);
                    }
                    return [...prev, {...card, quantity: 1}];
                });
                if (!isPrize) {
                    displayGlobalBanner(`Hai acquistato ${card.name}!`, 'purchase_success', 3000);
                }
            }, [globalCurrency, displayGlobalBanner]);

            const updateZainoCardQuantity = React.useCallback((id, amount) => {
                setPlayerZainoCards(prev => {
                    const card = prev.find(c => c.id === id);
                    if (amount > 0) {
                        const cardCost = trainersCardDbCards.find(db => db.id === id)?.cost || 0;
                        if (globalCurrency < cardCost) {
                            displayGlobalBanner(`Non hai abbastanza soldi!`, 'purchase_fail', 3000);
                            return prev;
                        }
                        setGlobalCurrency(p => p - cardCost);
                        displayGlobalBanner(`Hai acquistato un'altra copia!`, 'purchase_success', 3000);
                    }
                    return prev.map(c => c.id === id ? {...c, quantity: c.quantity + amount} : c).filter(c => c.quantity > 0);
                });
            }, [globalCurrency, trainersCardDbCards, displayGlobalBanner]);

            const onDeleteZainoCard = React.useCallback((id) => {
                setPlayerZainoCards(prev => prev.filter(c => c.id !== id));
            }, []);

            const handlePlayerOverallExpChange = (amount) => {
                setPlayerOverallExp(prev => Math.max(0, Math.min(15, prev + amount)));
            };

            const handleVictory = ({ currency, prizes }) => {
                setShowVictoryDefeatModal(false);
                handlePlayerOverallExpChange(1);
                adjustGlobalCurrency(currency);
                
                if (prizes > 0) {
                    if (negozioCards.length === 0) {
                        displayGlobalBanner("Negozio vuoto, nessun premio disponibile!", "info");
                        setShowAssignExpModal(true);
                        return;
                    }
                    
                    const prizeCards = [];
                    for (let i = 0; i < prizes; i++) {
                        const randomIndex = Math.floor(Math.random() * negozioCards.length);
                        prizeCards.push(negozioCards[randomIndex]);
                    }
                    setPendingPrize(prizeCards);
                    showPrizePreview(prizeCards, currency, () => {
                        setShowAssignExpModal(true);
                    });
                } else {
                    setShowAssignExpModal(true);
                }
            };

            const handleConfirmExpAssignment = (selectedIndices) => {
                setCards(prevCards => 
                    prevCards.map((card, index) => {
                        if (selectedIndices.includes(index) && card) {
                            return {
                                ...card,
                                exp: Math.min(6, card.exp + 1)
                            };
                        }
                        return card;
                    })
                );
            
                if (pendingPrize) {
                    pendingPrize.forEach(card => addCardToZaino(card, true));
                    setPendingPrize(null);
                }
                setShowAssignExpModal(false);
            };
            
            const handleDefeat = ({ currency, type }) => {
                adjustGlobalCurrency(-currency);
                showDefeatPreview(type, currency, () => {
                    setShowVictoryDefeatModal(false);
                });
            };

            const handleMovementRoll = (isBiking) => {
                setShowMovementModal(false);
                const result = isBiking ? Math.floor(Math.random() * 6) + 1 : Math.floor(Math.random() * 3) + 1;
                showMovementResultPreview(result);
            };

            const handlePalestreCardSelection = React.useCallback(async (palestreCard) => {
                const trainer1Name = `${palestreCard.name}-1`;
                const trainer2Name = `${palestreCard.name}-2`;
                const trainerCard1 = trainersDbCards.find(c => c.name === trainer1Name);
                const trainerCard2 = trainersDbCards.find(c => c.name === trainer2Name);

                updateCardInSlot(0, trainerCard1 ? {...trainerCard1, baseHp: trainerCard1.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false} : null);
                updateCardInSlot(1, trainerCard2 ? {...trainerCard2, baseHp: trainerCard2.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false} : null);
            }, [trainersDbCards, updateCardInSlot]);

            const fetchRandomCardFromTable = React.useCallback(async (tableName) => {
                try {
                    const { count, error: countError } = await supabase.from(tableName).select('*', { count: 'exact', head: true });
                    if (countError) throw countError;
                    if (count === 0) throw new Error(`La tabella '${tableName}' è vuota.`);

                    const randomIndex = Math.floor(Math.random() * count);
                    const { data, error: fetchError } = await supabase.from(tableName).select('*, hp, tipo').range(randomIndex, randomIndex + 1);
                    if (fetchError) throw fetchError;

                    if (data && data.length > 0) {
                        const randomCard = data[0];
                        
                        showTemporaryCard(randomCard.image_url, () => {
                            if (randomCard.tipo === 'a') {
                                handlePalestreCardSelection(randomCard);
                            } else {
                                const mappedCard = {
                                    imageUrl: randomCard.image_url,
                                    baseHp: randomCard.hp || 0,
                                    damageTaken: 0,
                                    statuses: Array(5).fill(false),
                                    exp: randomCard.exp || 0,
                                    isActivePokemon: false,
                                };
                                updateCardInSlot(0, mappedCard);
                            }
                        });
                    } else {
                        throw new Error("Nessuna carta trovata.");
                    }
                } catch (error) {
                    console.error("Errore nel fetchRandomCardFromTable:", error);
                    displayGlobalBanner(`Errore: ${error.message}`, 'purchase_fail');
                    throw error;
                }
            }, [updateCardInSlot, displayGlobalBanner, showTemporaryCard, handlePalestreCardSelection]);
            
            const handleFullReset = () => {
                setCards(Array(6).fill(null));
                setBoxCards([]);
                setPlayerZainoCards([]);
                setGlobalCurrency(0);
                setGymMedals(Array(8).fill(false));
                setEliteFourMedals(Array(4).fill(false));
                setPlayerOverallExp(0);
                setShowClearConfirm(false);
            };

            const getOverallExpDotColorClass = (index) => {
                if (index >= playerOverallExp) return '';
                if (index <= 2) return 'active-pink';
                if (index <= 5) return 'active-green-total';
                if (index <= 8) return 'active-blue-total';
                if (index <= 11) return 'active-yellow-total';
                return 'active-red-total';
            };

            return (
                <>
                    <h1 className="text-5xl font-extrabold text-white mb-8 text-center drop-shadow-lg">POKÉMON DUEL (PLAYER)</h1>
                    <button onClick={() => onSwitchRole('master')} className="btn-theme btn-gray px-6 py-3 text-lg mt-4 mb-4">Passa a Master</button>
                    {currentView === 'main' && (
                        <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-green-600 to-blue-700 p-4 relative">
                            <div className="w-full max-w-xs flex flex-col items-center p-4 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 z-10 mb-4">
                                <div className="flex flex-col items-center mb-4 w-full">
                                    <h3 className="text-xl font-bold text-yellow-300 mb-2">Punti Esperienza Totali</h3>
                                    <div className="flex items-center space-x-2 mb-2">
                                        <button onClick={() => handlePlayerOverallExpChange(-1)} className="btn-theme btn-red px-2 py-0.5 text-xl">-</button>
                                        <div className="flex flex-wrap justify-center gap-1 w-48">{[...Array(15)].map((_, i) => (<div key={i} className={`exp-dot ${getOverallExpDotColorClass(i)}`}></div>))}</div>
                                        <button onClick={() => handlePlayerOverallExpChange(1)} className="btn-theme btn-green px-2 py-0.5 text-xl">+</button>
                                    </div>
                                    <span className="text-xl font-bold text-white">{playerOverallExp}/15</span>
                                </div>
                                <div className="flex items-center justify-center space-x-4 mb-4">
                                    <TurnIndicator isMyTurn={isMyTurn} onToggleTurn={toggleMyTurn} role="player" disabled={false} />
                                    <button onClick={() => setShowMovementModal(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md transition-all duration-200 ease-in-out border-4 bg-cyan-500 border-cyan-700 hover:scale-105 active:scale-95" title="Movimento">🎲</button>
                                </div>
                                <CoinFlipper />
                                <div className="flex flex-col items-center gap-4 w-full">
                                    <DiceRoller title="ATTACCA" isAttackRoller={true} isDiceRollDisabled={diceRollDisableStatus} onConfusedRollAttempt={handleConfusedRollAttempt} isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                                    <DiceRoller title="RITIRATA" isAttackRoller={false} onDisplayGlobalBanner={displayGlobalBanner} onDiceRollComplete={toggleMyTurn} isMyTurn={isMyTurn} />
                                    <DiceRoller title="CATTURA" isAttackRoller={false} isCaptureRoller={true} onDisplayGlobalBanner={displayGlobalBanner} isMyTurn={isMyTurn} onDiceRollComplete={() => {}} onCaptureCoinFlipNeeded={handleCaptureCoinFlipNeeded} />
                                </div>
                                <div className="bg-yellow-400 p-2 rounded-full shadow-lg flex items-center justify-center border-4 border-yellow-700 w-full max-w-xs mt-4">
                                    <span className="text-xl font-extrabold text-gray-800 mr-1">$</span>
                                    <button onClick={() => adjustGlobalCurrency(-1)} className="btn-theme btn-red px-2 py-0.5 text-base">-</button>
                                    <input type="number" value={globalCurrency} onChange={handleGlobalCurrencyChange} className="w-16 px-1 py-0.5 bg-yellow-200 border-2 border-yellow-600 rounded-lg text-center text-gray-900 font-extrabold text-base mx-1 shadow-inner focus:outline-none focus:ring-2 focus:ring-yellow-500 no-spinner" min="0" />
                                    <button onClick={() => adjustGlobalCurrency(1)} className="btn-theme btn-green px-2 py-0.5 text-base">+</button>
                                </div>
                                <button onClick={() => setCurrentView('box')} className="btn-theme btn-purple px-6 py-3 text-lg mt-4">VAI AL BOX ({boxCards.length})</button>
                                <button onClick={() => setCurrentView('zaino')} className="btn-theme btn-orange px-6 py-3 text-lg mt-4">ZAINO ({playerZainoCards.length})</button>
                                <button onClick={() => setShowVictoryDefeatModal(true)} className="btn-theme btn-yellow px-6 py-3 text-lg mt-4">Vittoria/Sconfitta</button>
                            </div>
                            <VictoryDefeatModal isOpen={showVictoryDefeatModal} onClose={() => setShowVictoryDefeatModal(false)} onVictoryClick={handleVictory} onDefeatClick={handleDefeat} />
                            <AssignExpModal isOpen={showAssignExpModal} onClose={() => setShowAssignExpModal(false)} onConfirm={handleConfirmExpAssignment} cards={cards} />
                            <MovementModal isOpen={showMovementModal} onClose={() => setShowMovementModal(false)} onRoll={handleMovementRoll} />
                            <CaptureCoinFlipModal isOpen={showCaptureCoinFlipModal} onFlipCoin={performCaptureCoinFlip} coinResult={captureCoinFlipResult} finalOutcome={captureFinalOutcome} />
                            <div className="grid grid-cols-1 gap-8 w-full max-w-xs mt-8 pb-8"> 
                                {cards.map((cardData, index) => (
                                    <CardSlot key={index} slotIndex={index} cardData={cardData} onUpdateCard={updateCardInSlot} onToggleActivePokemon={handleActivePokemonToggle} isMyTurn={isMyTurn} activeCardParalyzed={isMyTurn && activeCardForDice && activeCardForDice.statuses[3]} onSendToBox={sendCardToBox} onRecallFromBox={recallCardFromBox} boxCards={boxCards} pokemonDbCards={pokemonDbCards} trainersDbCards={trainersDbCards} palestreDbCards={palestreDbCards} isDbLoading={isDbLoading} dbError={dbError} onSelectTableAndFetchRandom={fetchRandomCardFromTable} onSelectPalestreCard={handlePalestreCardSelection} role="player" showTemporaryCard={showTemporaryCard} />
                                ))}
                            </div>
                            <div className="w-full flex justify-center mt-8"><MedalDisplay gymMedals={gymMedals} onToggleMedal={toggleGymMedal} /></div>
                            <div className="w-full flex justify-center mt-8 pb-20"><EliteFourDisplay eliteFourMedals={eliteFourMedals} onToggleMedal={toggleEliteFourMedal} /></div>
                            <div className="w-full flex justify-center mt-8 pb-20">
                                <button onClick={() => setShowClearConfirm(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md transition-all duration-200 ease-in-out border-4 bg-red-600 border-red-800 hover:scale-105 active:scale-95" title="Resetta tutti i dati del giocatore">
                                    🗑️
                                </button>
                            </div>
                            {showClearConfirm && (
                                <div className="zoom-modal-overlay">
                                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-red-500">
                                        <h3 className="text-2xl font-bold text-red-400 mb-6 text-center">Sei sicuro di voler resettare tutti i dati del giocatore?</h3>
                                        <div className="flex space-x-4">
                                            <button onClick={handleFullReset} className="btn-theme btn-red">Sì, Resetta</button>
                                            <button onClick={() => setShowClearConfirm(false)} className="btn-theme btn-gray">No, Annulla</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                    {currentView === 'box' && (<BoxView boxCards={boxCards} onBackToMain={() => setCurrentView('main')} onDeleteCardFromBox={deleteCardFromBox} role="player" />)}
                    {currentView === 'negozio' && (<NegozioView negozioCards={negozioCards} onBackToMain={() => setCurrentView('main')} isDbLoading={isDbLoading} dbError={dbError} role="player" />)}
                    {currentView === 'zaino' && (<ZainoView playerZainoCards={playerZainoCards} onBackToMain={() => setCurrentView('main')} onAddCardToZaino={addCardToZaino} onUpdateZainoCardQuantity={updateZainoCardQuantity} onDeleteZainoCard={onDeleteZainoCard} trainersCardDbCards={trainersCardDbCards} isDbLoading={isDbLoading} dbError={dbError} />)}
                </>
            );
        }
        
        function MasterApp({ onSwitchRole, displayGlobalBanner, clearGlobalBanner, showTemporaryCard }) {
            const rolePrefix = 'master';
            const [cards, setCards] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_gameCards`)) || Array(6).fill(null));
            const [boxCards, setBoxCards] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_pokemonBoxCards`)) || []);
            const [negozioCards, setNegozioCards] = React.useState([]); 
            const [currentView, setCurrentView] = React.useState('main');
            const [pokemonDbCards, setPokemonDbCards] = React.useState([]); 
            const [trainersDbCards, setTrainersDbCards] = React.useState([]);
            const [palestreDbCards, setPalestreDbCards] = React.useState([]); 
            const [trainersCardDbCards, setTrainersCardDbCards] = React.useState([]);
            const [isDbLoading, setIsDbLoading] = React.useState(true);
            const [dbError, setDbError] = React.useState(null);
            const [showClearConfirm, setShowClearConfirm] = React.useState(false);

            React.useEffect(() => {
                async function getSupabaseCards() {
                    try {
                        setIsDbLoading(true);
                        setDbError(null);
                        const { data: pokemonData, error: pokemonError } = await supabase.from('pokemon_cards').select('*, hp');
                        if (pokemonError) throw pokemonError;
                        setPokemonDbCards(pokemonData.map(c => ({...c, baseHp: c.hp, imageUrl: c.image_url})));
                        const { data: trainersData, error: trainersError } = await supabase.from('pokemon_allenatori').select('*');
                        if (trainersError) throw trainersError;
                        setTrainersDbCards(trainersData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: palestreData, error: palestreError } = await supabase.from('palestre').select('*');
                        if (palestreError) throw palestreError;
                        setPalestreDbCards(palestreData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: trainersCardData, error: trainersCardError } = await supabase.from('trainers_card').select('*');
                        if (trainersCardError) throw trainersCardError;
                        setTrainersCardDbCards(trainersCardData.map(c => ({...c, imageUrl: c.image_url})));
                        const { data: negozioData, error: negozioError } = await supabase.from('negozio').select('*');
                        if (negozioError) throw negozioError;
                        setNegozioCards(negozioData.map(c => ({...c, imageUrl: c.image_url, baseHp: c.base_hp})));
                    } catch (err) {
                        console.error("Supabase Error (Master):", err.message);
                        setDbError(err.message);
                        setPokemonDbCards(localPokemonCardsDatabase);
                    } finally {
                        setIsDbLoading(false);
                    }
                }
                getSupabaseCards();
            }, []); 

            const [globalCurrency, setGlobalCurrency] = React.useState(() => parseInt(localStorage.getItem(`${rolePrefix}_globalCurrency`) || '0'));
            const [gymMedals, setGymMedals] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_gymMedals`)) || Array(8).fill(false));
            const [eliteFourMedals, setEliteFourMedals] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_eliteFourMedals`)) || Array(4).fill(false));
            const [isMyTurn, setIsMyTurn] = React.useState(() => JSON.parse(localStorage.getItem(`${rolePrefix}_isMyTurn`)) || true);
            const [showCaptureCoinFlipModal, setShowCaptureCoinFlipModal] = React.useState(false);
            const [captureCoinFlipResult, setCaptureCoinFlipResult] = React.useState(null);
            const [captureFinalOutcome, setCaptureFinalOutcome] = React.useState(null);

            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_gameCards`, JSON.stringify(cards)); }, [cards, rolePrefix]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_pokemonBoxCards`, JSON.stringify(boxCards)); }, [boxCards, rolePrefix]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_globalCurrency`, globalCurrency.toString()); }, [globalCurrency, rolePrefix]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_gymMedals`, JSON.stringify(gymMedals)); }, [gymMedals, rolePrefix]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_eliteFourMedals`, JSON.stringify(eliteFourMedals)); }, [eliteFourMedals, rolePrefix]);
            React.useEffect(() => { localStorage.setItem(`${rolePrefix}_isMyTurn`, JSON.stringify(isMyTurn)); }, [isMyTurn, rolePrefix]);

            const updateCardInSlot = React.useCallback((index, cardData) => {
                setCards(prev => {
                    const newCards = [...prev];
                    newCards[index] = cardData;
                    return newCards;
                });
            }, []);

            const handleActivePokemonToggle = React.useCallback((clickedSlotIndex) => {
                 setCards(prev => prev.map((card, idx) => {
                    if (!card) return null;
                    let newIsActive = (idx === clickedSlotIndex) ? !card.isActivePokemon : false;
                    let newStatuses = (idx === clickedSlotIndex && !newIsActive) || (idx !== clickedSlotIndex) ? Array(5).fill(false) : [...card.statuses];
                    return { ...card, isActivePokemon: newIsActive, statuses: newStatuses };
                }));
            }, []);

            const toggleGymMedal = (index) => setGymMedals(prev => { const n = [...prev]; n[index] = !n[index]; return n; });
            const toggleEliteFourMedal = (index) => setEliteFourMedals(prev => { const n = [...prev]; n[index] = !n[index]; return n; });

            const activeCardForDice = cards.find(c => c && c.isActivePokemon);
            const diceRollDisableStatus = activeCardForDice ? (activeCardForDice.statuses[0] ? 'asleep' : (activeCardForDice.statuses[2] ? 'confused' : (activeCardForDice.statuses[3] ? 'paralyzed' : false))) : false;

            const handleConfusedRollAttempt = React.useCallback(async () => {
                const result = Math.random() < 0.5 ? 'Testa' : 'Croce';
                if (result === 'Croce') {
                    setCards(prev => prev.map(c => c && c.isActivePokemon ? { ...c, damageTaken: c.damageTaken + 30 } : c));
                    displayGlobalBanner("Confusione: Colpito da solo!", 'confusion_hit', 3000);
                    setTimeout(() => toggleMyTurn(), 2000);
                    return false;
                } else {
                    displayGlobalBanner("Confusione: Attacco riuscito!", 'confusion_miss', 3000);
                    return true;
                }
            }, [cards, displayGlobalBanner, toggleMyTurn]);

            const toggleMyTurn = React.useCallback(() => {
                clearGlobalBanner();
                setIsMyTurn(prev => {
                    const newTurn = !prev;
                    const active = cards.find(c => c && c.isActivePokemon);
                    if (active) {
                        if (!newTurn && active.statuses[3]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, statuses: [c.statuses[0], c.statuses[1], c.statuses[2], false, c.statuses[4]]} : c));
                            displayGlobalBanner("Non più paralizzato!", 'status_cleared', 3000);
                        }
                        if (active.statuses[0]) {
                            if (Math.random() < 0.5) {
                                setCards(p => p.map(c => c && c.isActivePokemon ? {...c, statuses: [false, c.statuses[1], c.statuses[2], c.statuses[3], c.statuses[4]]} : c));
                                displayGlobalBanner("Si è svegliato!", 'status_woke_up', 3000);
                            } else {
                                displayGlobalBanner("Resta addormentato!", 'info', 3000);
                            }
                        }
                        if (newTurn && active.statuses[1]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, damageTaken: c.damageTaken + 20} : c));
                            displayGlobalBanner("Subisce danni da bruciatura!", 'damage_burn', 3000);
                        }
                        if (newTurn && active.statuses[4]) {
                            setCards(p => p.map(c => c && c.isActivePokemon ? {...c, damageTaken: c.damageTaken + 10} : c));
                            displayGlobalBanner("Subisce danni da veleno!", 'damage_poison', 3000);
                        }
                    }
                    return newTurn;
                });
            }, [cards, displayGlobalBanner, clearGlobalBanner]);

            const handleCaptureCoinFlipNeeded = React.useCallback(() => {
                setShowCaptureCoinFlipModal(true);
                setCaptureCoinFlipResult(null);
                setCaptureFinalOutcome(null);
            }, []);

            const performCaptureCoinFlip = React.useCallback(() => {
                const result = Math.random() < 0.5 ? 'heads' : 'tails';
                setCaptureCoinFlipResult(result);
                const final = result === 'tails' ? 'PRESO' : 'FALLITA';
                setCaptureFinalOutcome(final);
                displayGlobalBanner(final === 'PRESO' ? 'Pokémon Catturato!' : 'Cattura Fallita!', final === 'PRESO' ? 'capture_success' : 'capture_fail', 3000);
                setTimeout(() => {
                    setShowCaptureCoinFlipModal(false);
                    toggleMyTurn();
                }, 2000); 
            }, [displayGlobalBanner, toggleMyTurn]);

            const sendCardToBox = React.useCallback((card, slot) => {
                setBoxCards(prev => [...prev, card]);
                updateCardInSlot(slot, null);
            }, [updateCardInSlot]);

            const recallCardFromBox = React.useCallback((card, slot, boxIndex, delOnly) => {
                if (delOnly) {
                    setBoxCards(prev => prev.filter((_, i) => i !== boxIndex));
                } else {
                    updateCardInSlot(slot, {...card, damageTaken: 0, statuses: Array(5).fill(false), isActivePokemon: false});
                    setBoxCards(prev => prev.filter((_, i) => i !== boxIndex));
                }
            }, [updateCardInSlot]);

            const deleteCardFromBox = React.useCallback((index) => {
                setBoxCards(prev => prev.filter((_, i) => i !== index));
            }, []);
            
            const handleClearAllSlots = () => {
                setCards(Array(6).fill(null));
                setShowClearConfirm(false);
            };

            const handlePalestreCardSelection = React.useCallback(async (palestreCard) => {
                const trainer1Name = `${palestreCard.name}-1`;
                const trainer2Name = `${palestreCard.name}-2`;
                const trainerCard1 = trainersDbCards.find(c => c.name === trainer1Name);
                const trainerCard2 = trainersDbCards.find(c => c.name === trainer2Name);
                updateCardInSlot(0, trainerCard1 ? {...trainerCard1, baseHp: trainerCard1.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false} : null);
                updateCardInSlot(1, trainerCard2 ? {...trainerCard2, baseHp: trainerCard2.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false} : null);
            }, [trainersDbCards, updateCardInSlot]); 

            const fetchRandomCardFromTable = React.useCallback(async (tableName) => {
                try {
                    const { count, error: countError } = await supabase.from(tableName).select('*', { count: 'exact', head: true });
                    if (countError) throw countError;
                    if (count === 0) throw new Error(`La tabella '${tableName}' è vuota.`);

                    const randomIndex = Math.floor(Math.random() * count);
                    const { data, error: fetchError } = await supabase.from(tableName).select('*, hp, tipo').range(randomIndex, randomIndex + 1);
                    if (fetchError) throw fetchError;

                    if (data && data.length > 0) {
                        const randomCard = data[0];
                        
                        showTemporaryCard(randomCard.image_url, () => {
                            if (randomCard.tipo === 'a') {
                                handlePalestreCardSelection(randomCard);
                            } else {
                                const mappedCard = {
                                    imageUrl: randomCard.image_url,
                                    baseHp: randomCard.hp || 0,
                                    damageTaken: 0,
                                    statuses: Array(5).fill(false),
                                    exp: randomCard.exp || 0,
                                    isActivePokemon: false,
                                };
                                updateCardInSlot(0, mappedCard);
                            }
                        });
                    } else {
                        throw new Error("Nessuna carta trovata.");
                    }
                } catch (error) {
                    console.error("Errore nel fetchRandomCardFromTable (Master):", error);
                    displayGlobalBanner(`Errore: ${error.message}`, 'purchase_fail');
                    throw error;
                }
            }, [updateCardInSlot, displayGlobalBanner, showTemporaryCard, handlePalestreCardSelection]);

            return (
                <>
                    <h1 className="text-5xl font-extrabold text-white mb-8 text-center drop-shadow-lg">POKÉMON DUEL (MASTER)</h1>
                    <button onClick={() => onSwitchRole('player')} className="btn-theme btn-gray px-6 py-3 text-lg mt-4 mb-4">Passa a Player</button>
                    {currentView === 'main' && (
                        <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-red-600 to-purple-700 p-4 relative">
                            <div className="w-full max-w-xs flex flex-col items-center p-4 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 z-10 mb-4">
                                <div className="flex items-center justify-center space-x-4 mb-4">
                                    <TurnIndicator isMyTurn={isMyTurn} onToggleTurn={toggleMyTurn} role="master" disabled={false} />
                                    <button onClick={() => setShowClearConfirm(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md transition-all duration-200 ease-in-out border-4 bg-red-600 border-red-800 hover:scale-105 active:scale-95" title="Svuota tutti gli slot">
                                        🗑️
                                    </button>
                                </div>
                                <CoinFlipper />
                                <div className="flex flex-col items-center gap-4 w-full">
                                    <DiceRoller title="ATTACCA" isAttackRoller={true} isDiceRollDisabled={diceRollDisableStatus} onConfusedRollAttempt={handleConfusedRollAttempt} isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                                    <DiceRoller title="RITIRATA" isAttackRoller={false} onDisplayGlobalBanner={displayGlobalBanner} onDiceRollComplete={toggleMyTurn} isMyTurn={isMyTurn} />
                                </div>
                                <button onClick={() => setCurrentView('negozio')} className="btn-theme btn-orange px-6 py-3 text-lg mt-4">NEGOZIO</button>
                            </div>
                            {showClearConfirm && (
                                <div className="zoom-modal-overlay">
                                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-red-500">
                                        <h3 className="text-2xl font-bold text-red-400 mb-6 text-center">Sei sicuro di voler svuotare tutti gli slot?</h3>
                                        <div className="flex space-x-4">
                                            <button onClick={handleClearAllSlots} className="btn-theme btn-red">Sì, Svuota</button>
                                            <button onClick={() => setShowClearConfirm(false)} className="btn-theme btn-gray">No, Annulla</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                            <CaptureCoinFlipModal isOpen={showCaptureCoinFlipModal} onFlipCoin={performCaptureCoinFlip} coinResult={captureCoinFlipResult} finalOutcome={captureFinalOutcome} />
                            <div className="grid grid-cols-1 gap-8 w-full max-w-xs mt-8 pb-8"> 
                                {cards.map((cardData, index) => (
                                    <CardSlot key={index} slotIndex={index} cardData={cardData} onUpdateCard={updateCardInSlot} onToggleActivePokemon={handleActivePokemonToggle} isMyTurn={isMyTurn} activeCardParalyzed={diceRollDisableStatus === 'paralyzed'} onSendToBox={sendCardToBox} onRecallFromBox={recallCardFromBox} boxCards={boxCards} pokemonDbCards={pokemonDbCards} trainersDbCards={trainersDbCards} palestreDbCards={palestreDbCards} isDbLoading={isDbLoading} dbError={dbError} onSelectTableAndFetchRandom={fetchRandomCardFromTable} onSelectPalestreCard={handlePalestreCardSelection} role="master" showTemporaryCard={showTemporaryCard} />
                                ))}
                            </div>
                            <div className="w-full flex justify-center mt-8"><MedalDisplay gymMedals={gymMedals} onToggleMedal={toggleGymMedal} /></div>
                            <div className="w-full flex justify-center mt-8 pb-20"><EliteFourDisplay eliteFourMedals={eliteFourMedals} onToggleMedal={toggleEliteFourMedal} /></div>
                        </div>
                    )}
                    {currentView === 'box' && (<BoxView boxCards={boxCards} onBackToMain={() => setCurrentView('main')} onDeleteCardFromBox={deleteCardFromBox} role="master" />)}
                    {currentView === 'negozio' && (<NegozioView negozioCards={negozioCards} onBackToMain={() => setCurrentView('main')} isDbLoading={isDbLoading} dbError={dbError} role="master" />)}
                </>
            );
        }
        
        function MainAppContainer() {
            const [currentRole, setCurrentRole] = React.useState('player');
            const [globalBanner, setGlobalBanner] = React.useState({ isVisible: false, message: '', type: '' });
            const bannerTimeoutRef = React.useRef(null);
            const [temporaryCard, setTemporaryCard] = React.useState(null);
            const [prizePreview, setPrizePreview] = React.useState(null);
            const [defeatPreview, setDefeatPreview] = React.useState(null);
            const [movementResult, setMovementResult] = React.useState(null);

            const displayGlobalBanner = React.useCallback((message, type = 'info', duration = 3000) => {
                if (bannerTimeoutRef.current) {
                    clearTimeout(bannerTimeoutRef.current);
                }
                setGlobalBanner({ isVisible: true, message, type });
                if (duration > 0) {
                    bannerTimeoutRef.current = setTimeout(() => {
                        setGlobalBanner({ isVisible: false, message: '', type: '' });
                        bannerTimeoutRef.current = null;
                    }, duration);
                }
            }, []);

            const clearGlobalBanner = React.useCallback(() => {
                setGlobalBanner({ isVisible: false, message: '', type: '' });
                if (bannerTimeoutRef.current) {
                    clearTimeout(bannerTimeoutRef.current);
                    bannerTimeoutRef.current = null;
                }
            }, []);
            
            const showTemporaryCard = React.useCallback((imageUrl, callback) => {
                setTemporaryCard(imageUrl);
                setTimeout(() => {
                    setTemporaryCard(null);
                    if (callback) callback();
                }, 3000);
            }, []);

            const showPrizePreview = React.useCallback((cards, currency, callback) => {
                setPrizePreview({ cards, currency });
                setTimeout(() => {
                    setPrizePreview(null);
                    if (callback) callback();
                }, 2000);
            }, []);

            const showDefeatPreview = React.useCallback((type, currency, callback) => {
                setDefeatPreview({ type, currency });
                setTimeout(() => {
                    setDefeatPreview(null);
                    if (callback) callback();
                }, 2000);
            }, []);

            const showMovementResultPreview = React.useCallback((result) => {
                setMovementResult(result);
                setTimeout(() => {
                    setMovementResult(null);
                }, 3000);
            }, []);

            const switchRole = (newRole) => {
                clearGlobalBanner();
                setCurrentRole(newRole);
            };

            return (
                <div className="main-container min-h-screen flex flex-col items-center bg-gray-900">
                    <GlobalEventBanner {...globalBanner} />
                    <TemporaryCardDisplay imageUrl={temporaryCard} />
                    <PrizePreviewDisplay prizeData={prizePreview} />
                    <DefeatPreviewDisplay defeatData={defeatPreview} />
                    <MovementResultDisplay result={movementResult} />
                    {currentRole === 'player' ? (
                        <PlayerApp onSwitchRole={switchRole} displayGlobalBanner={displayGlobalBanner} clearGlobalBanner={clearGlobalBanner} showTemporaryCard={showTemporaryCard} showPrizePreview={showPrizePreview} showDefeatPreview={showDefeatPreview} showMovementResultPreview={showMovementResultPreview} />
                    ) : (
                        <MasterApp onSwitchRole={switchRole} displayGlobalBanner={displayGlobalBanner} clearGlobalBanner={clearGlobalBanner} showTemporaryCard={showTemporaryCard} />
                    )}
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<MainAppContainer />);
    </script>
</body>
</html>
