<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaccia Gioco di Carte Pokémon</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter (o un font più "gamey" se disponibile e adatto) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Manteniamo Inter, ma puoi cambiarlo per un font pixelato se preferisci */
            margin: 0;
            /* Sfondo a tema Pokémon (es. verde erba scuro, blu cielo, ecc.) */
            background: linear-gradient(to bottom right, #4CAF50, #2E7D32); /* Verde scuro/erba */
            color: #E0E0E0; /* Testo chiaro */
        }
        /* Stile per la modale della fotocamera */
        .camera-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .camera-modal-content {
            background-color: #333;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        /* Nuovo stile per il contenitore del video e l'overlay di inquadratura */
        .camera-video-container {
            position: relative;
            width: 100%;
            max-width: 400px; /* Max width for the video stream */
            padding-top: calc(4 / 3 * 100%); /* Proporzioni 3:4 (altezza = 4/3 di larghezza) */
            height: 0; /* Set height to 0 to use padding-top for aspect ratio */
            overflow: hidden;
            background-color: black;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assicura che il video riempia il contenitore */
            transform: scaleX(-1); /* Specchia il video se è una fotocamera frontale */
        }

        .capture-frame-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 192px; /* Larghezza target della carta */
            height: 256px; /* Altezza target della carta (proporzione 3:4) */
            border: 3px dashed rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Permette il click attraverso l'overlay */
            z-index: 10;
        }

        /* Nasconde la canvas utilizzata per catturare l'immagine */
        .camera-canvas {
            display: none;
        }

        /* Stili aggiuntivi per i pulsanti tematici */
        .btn-theme {
            padding: 0.75rem 1.5rem; /* Aumentato padding */
            border-radius: 9999px; /* Completamente arrotondato */
            font-weight: 700; /* Bold */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3); /* Ombra testo */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); /* Ombra più pronunciata */
            transition: all 0.2s ease-in-out;
            border: 2px solid;
            background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
        }
        .btn-theme:hover {
            transform: translateY(-2px); /* Effetto sollevamento */
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .btn-theme:active {
            transform: translateY(1px); /* Effetto click */
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn-red {
            --tw-gradient-stops: #EF4444, #DC2626; /* from-red-500 to-red-700 */
            border-color: #B91C1C; /* border-red-800 */
            color: white;
        }
        .btn-green {
            --tw-gradient-stops: #22C55E, #16A34A; /* from-green-500 to-green-700 */
            border-color: #15803D; /* border-green-800 */
            color: white;
        }
        .btn-blue {
            --tw-gradient-stops: #3B82F6, #2563EB; /* from-blue-500 to-blue-700 */
            border-color: #1D4ED8; /* border-blue-800 */
            color: white;
        }
        .btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA; /* from-purple-500 to-purple-700 */
            border-color: #7E22CE; /* border-purple-800 */
            color: white;
        }
        .btn-yellow {
            --tw-gradient-stops: #FACC15, #EAB308; /* from-yellow-400 to-yellow-600 */
            border-color: #CA8A04; /* border-yellow-700 */
            color: #333; /* Testo scuro per il giallo */
        }
        .btn-orange {
            --tw-gradient-stops: #F97316, #EA580C; /* from-orange-500 to-orange-700 */
            border-color: #C2410C; /* border-orange-800 */
            color: white;
        }
        .btn-gray {
            --tw-gradient-stops: #6B7280, #4B5563; /* from-gray-500 to-gray-700 */
            border-color: #374151; /* border-gray-800 */
            color: white;
        }

        /* Stili per le label dei contatori */
        .counter-label {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #F0F0F0; /* Light gray */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
        }
        /* Stili per i valori dei contatori */
        .counter-value {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 800; /* font-extrabold */
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
        }

        /* Stili per i pulsanti icona */
        .icon-btn {
            @apply flex items-center justify-center w-12 h-12 rounded-full text-2xl shadow-md transition-all duration-200 ease-in-out border-2;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
        }
        .icon-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }
        .icon-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .icon-btn.btn-blue {
             --tw-gradient-stops: #3B82F6, #2563EB; /* from-blue-500 to-blue-700 */
            border-color: #1D4ED8; /* border-blue-800 */
            color: white;
        }
        .icon-btn.btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA; /* from-purple-500 to-purple-700 */
            border-color: #7E22CE; /* border-purple-800 */
            color: white;
        }

        /* Stili per i segnalini medaglia */
        .medal-icon {
            @apply w-10 h-10 rounded-full flex items-center justify-center text-3xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md; /* Changed to text-3xl for uniformity */
        }
        .medal-icon.active {
            @apply scale-110 ring-2 ring-offset-2 ring-offset-green-700;
        }

        /* Stili per i segnalini Superquattro */
        .elite-four-icon {
            @apply w-10 h-10 rounded-full flex items-center justify-center text-3xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md; /* Changed to text-3xl for uniformity */
            background: linear-gradient(to bottom, #4A5568, #2D3748); /* gray-700 to gray-800 */
            color: #CBD5E0; /* text-gray-300 */
        }
        .elite-four-icon.active {
            @apply scale-110 ring-2 ring-offset-2 ring-offset-yellow-400;
            background: linear-gradient(to bottom, #FACC15, #EAB308); /* yellow-400 to yellow-600 */
            color: #333; /* Dark text for active */
        }


        /* Nasconde le frecce (spinner) dagli input di tipo number */
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type='number'] {
            -moz-appearance: textfield; /* Per Firefox */
        }

        /* Animazione per il banner della moneta */
        @keyframes fadeInOutCoin {
            0% { opacity: 0; transform: translateY(-50%) translateX(20px); }
            10% { opacity: 1; transform: translateY(-50%) translateX(0); }
            90% { opacity: 1; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(20px); }
        }
        .animate-fade-in-out-coin {
            animation: fadeInOutCoin 3s ease-in-out forwards;
        }

        /* Animazione per il banner di confusione (opzionale, per distinguere) */
        @keyframes fadeInOutConfusion {
            0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
            10% { opacity: 1; transform: translateY(-50%) scale(1); }
            90% { opacity: 1; transform: translateY(-50%) scale(1); }
            100% { opacity: 0; transform: translateY(-50%) scale(0.8); }
        }
        .animate-fade-in-out-confusion {
            animation: fadeInOutConfusion 3s ease-in-out forwards;
        }
        /* Animazione per il banner dado movimento */
        @keyframes fadeInOutMovementDice {
            0% { opacity: 0; transform: scale(0.5); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        .animate-fade-in-out-movement-dice {
            animation: fadeInOutMovementDice 5s ease-out forwards;
        }

        /* Stili per i pallini EXP */
        .exp-dot {
            width: 1rem; /* 16px */
            height: 1rem; /* 16px */
            border-radius: 50%;
            background-color: #4B5563; /* gray-600, inactive */
            border: 2px solid #374151; /* gray-700 */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
        }
        .exp-dot.active-yellow {
            background-color: #FACC15; /* yellow-400 */
            border-color: #EAB308; /* yellow-600 */
            transform: scale(1.1);
        }
        .exp-dot.active-blue {
            background-color: #3B82F6; /* blue-500 */
            border-color: #2563EB; /* blue-700 */
            transform: scale(1.1);
        }
        /* Stile per il banner globale dei dadi (ATTACCA/RITIRATA) */
        @keyframes fadeInOutDiceRoll {
            0% { opacity: 0; transform: scale(0.7); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.7); }
        }
        .animate-fade-in-out-dice-roll {
            animation: fadeInOutDiceRoll 3s ease-out forwards;
        }

        /* Stili per la modale del lancio della moneta di cattura */
        .capture-coin-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .capture-coin-modal-content {
            background-color: #333;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            border: 4px solid #FACC15; /* Yellow border */
        }
        .capture-coin-modal-content h2 {
            font-size: 2.5rem; /* text-4xl */
            font-weight: 800; /* font-extrabold */
            color: #FACC15; /* Yellow text */
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .capture-coin-modal-content button {
            padding: 1rem 2.5rem;
            border-radius: 9999px;
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700;
            background-image: linear-gradient(to bottom, #3B82F6, #2563EB); /* Blue gradient */
            border: 2px solid #1D4ED8;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease-in-out;
        }
        .capture-coin-modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .capture-coin-modal-content button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .capture-coin-result {
            font-size: 4rem; /* text-7xl */
            font-weight: 900; /* font-black */
            margin-top: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6);
        }
        .capture-coin-result.success {
            color: #22C55E; /* Green */
        }
        .capture-coin-result.fail {
            color: #EF4444; /* Red */
        }

        /* Stili per la modale di zoom dell'immagine */
        .zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .zoom-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .zoom-modal-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }
        .zoom-modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
        }
        .zoom-modal-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- React, ReactDOM, and Babel for JSX transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Supabase Client Library CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script type="text/babel">
        // Your Supabase credentials
        const SUPABASE_URL = 'https://wcarhpvygqbjekacizlb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjYXJocHZ5Z3FiamVrYWNpemxiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ0OTAzMTYsImV4cCI6MjA3MDA2NjMxNn0.xc7_wXB16kaAVOdcucP_7zzvUQ8f2S6IYKBjIs0ffEU';

        // Initialize the Supabase client using the global 'supabase' object from the CDN
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Mapping numbers to dice symbols (emoji) - Global for accessibility
        const diceFaces = {
            1: '⚀',
            2: '⚁',
            3: '⚂',
            4: '⚃',
            5: '⚄',
            6: '⚅',
        };

        // Local fallback/example database of Pokémon cards.
        // This will be used if Supabase data is not yet loaded or if Supabase setup fails.
        const localPokemonCardsDatabase = [
            { id: 'db-local-001', name: 'Pikachu', imageUrl: 'https://placehold.co/192x256/FFD700/000000?text=Pikachu', baseHp: 60, exp: 0 },
            { id: 'db-local-002', name: 'Charmander', imageUrl: 'https://placehold.co/192x256/FF4500/FFFFFF?text=Charmander', baseHp: 50, exp: 0 },
            { id: 'db-local-003', name: 'Squirtle', imageUrl: 'https://placehold.co/192x256/1E90FF/FFFFFF?text=Squirtle', baseHp: 60, exp: 0 },
            { id: 'db-local-004', name: 'Bulbasaur', imageUrl: 'https://placehold.co/192x256/7CFC00/000000?text=Bulbasaur', baseHp: 70, exp: 0 },
            { id: 'db-local-005', name: 'Jigglypuff', imageUrl: 'https://placehold.co/192x256/FF69B4/000000?text=Jigglypuff', baseHp: 80, exp: 0 },
            { id: 'db-local-006', name: 'Meowth', imageUrl: 'https://placehold.co/192x256/A9A9A9/000000?text=Meowth', baseHp: 70, exp: 0 },
            { id: 'db-local-007', name: 'Psyduck', imageUrl: 'https://placehold.co/192x256/ADD8E6/000000?text=Psyduck', baseHp: 80, exp: 0 },
            { id: 'db-local-008', name: 'Snorlax', imageUrl: 'https://placehold.co/192x256/6A5ACD/FFFFFF?text=Snorlax', baseHp: 120, exp: 0 },
            { id: 'db-local-009', name: 'Eevee', imageUrl: 'https://placehold.co/192x256/CD853F/FFFFFF?text=Eevee', baseHp: 60, exp: 0 },
            { id: 'db-local-010', name: 'Mewtwo', imageUrl: 'https://placehold.co/192x256/8A2BE2/FFFFFF?text=Mewtwo', baseHp: 130, exp: 0 },
            // Aggiungi qui altre carte di esempio locali se necessario
        ];

        // CameraModal Component
        // Modal for camera access and image capture.
        function CameraModal({ isOpen, onClose, onCapture }) {
            const videoRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const [currentStream, setCurrentStream] = React.useState(null);
            const [error, setError] = React.useState(null);
            const [availableCameras, setAvailableCameras] = React.useState([]);
            const [selectedCameraId, setSelectedCameraId] = React.useState('');
            const [cameraStatusMessage, setCameraStatusMessage] = React.useState("Inizializzazione fotocamera...");
            const [isFrontCamera, setIsFrontCamera] = React.useState(false); // New state to detect front camera

            // Function to stop the camera stream
            const stopCurrentStream = React.useCallback((s) => {
                if (s) {
                    console.log("Stopping tracks for stream:", s);
                    s.getTracks().forEach(track => {
                        console.log("Stopping track:", track.kind);
                        track.stop();
                    });
                    console.log("Stream stopped.");
                }
                setCurrentStream(null);
                if (videoRef.current) {
                    videoRef.current.srcObject = null; // Clear srcObject
                }
            }, []);

            // Function to start the camera stream
            const startCamera = React.useCallback(async (deviceIdToUse, facingMode = 'environment', fallback = false) => {
                setCameraStatusMessage("Avvio fotocamera...");
                setError(null);

                // Stop any existing stream
                if (currentStream) {
                    stopCurrentStream(currentStream);
                }
                setCurrentStream(null); // Ensure currentStream is null before attempting to get a new stream

                try {
                    const constraints = {
                        video: deviceIdToUse ? { deviceId: { exact: deviceIdToUse } } : { facingMode: facingMode }
                    };
                    console.log("Attempting getUserMedia with constraints:", constraints);
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    if (videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.onloadedmetadata = () => {
                            console.log("Video metadata loaded, attempting to play...");
                            setCameraStatusMessage("Attendere il video...");
                            videoRef.current.play().then(() => {
                                console.log("Video played successfully.");
                                setCameraStatusMessage(""); // Clear message on success
                            }).catch(playErr => {
                                console.error("Error playing video after metadata loaded:", playErr);
                                setError("Errore nella riproduzione del video della fotocamera. Assicurati che il browser consenta l'autoplay e riprova.");
                                setCameraStatusMessage("Errore riproduzione video.");
                            });
                        };
                        // If metadata already loaded (e.g., re-render), try to play immediately
                        if (videoRef.current.readyState >= 2) { // HAVE_CURRENT_DATA or more
                             videoRef.current.play().catch(playErr => {
                                 console.error("Error playing video (readyState >=2):", playErr);
                             });
                        }
                    }
                    setCurrentStream(mediaStream); // Set stream to state after successful acquisition
                    console.log("Camera started successfully with deviceId:", deviceIdToUse || "generic");

                    // Determine if the current camera is front-facing
                    const videoTrack = mediaStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    setIsFrontCamera(settings.facingMode === 'user');

                } catch (err) {
                    console.error("Error accessing camera with deviceId:", deviceIdToUse, err);
                    setCameraStatusMessage("Errore nell'accesso alla fotocamera.");
                    if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                        setError("Accesso alla fotocamera negato. Controlla i permessi del browser.");
                    } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                        if (!fallback && availableCameras.length > 0) { 
                            console.log("Specific camera not found, attempting generic fallback or first available.");
                            startCamera(availableCameras[0].deviceId, availableCameras[0].label.toLowerCase().includes('front') ? 'user' : 'environment', true); // Fallback
                            return; 
                        }
                        setError("Nessuna fotocamera disponibile.");
                    } else {
                        setError("Impossibile accedere alla fotocamera: " + err.message);
                    }
                    stopCurrentStream(null); // Ensure cleanup on error
                }
            }, [stopCurrentStream, currentStream, availableCameras]); 

            // Main effect to handle modal opening/closing and camera initialization
            React.useEffect(() => {
                if (!isOpen) {
                    stopCurrentStream(currentStream); // Stop stream when modal closes
                    setAvailableCameras([]);
                    setSelectedCameraId('');
                    setError(null);
                    setCameraStatusMessage("Inizializzazione fotocamera...");
                    return; // Exit early if modal is closed
                }

                const setupDevicesAndStartInitialCamera = async () => {
                    setCameraStatusMessage("Ricerca fotocamere...");
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoInputs = devices.filter(device => device.kind === 'videoinput');
                        setAvailableCameras(videoInputs);
                        console.log("Available cameras detected (initial setup):", videoInputs);

                        if (videoInputs.length === 0) {
                            setError("Nessuna fotocamera trovata.");
                            setCameraStatusMessage("Nessuna fotocamera trovata.");
                            return;
                        }

                        let targetDeviceId = selectedCameraId; 
                        let targetFacingMode = 'environment'; // Default to rear camera
                        // If no selected camera or selected camera is no longer available, pick a default
                        if (!targetDeviceId || !videoInputs.some(device => device.deviceId === targetDeviceId)) { 
                            const rearCamera = videoInputs.find(device =>
                                device.label.toLowerCase().includes('back') ||
                                device.label.toLowerCase().includes('rear') ||
                                device.label.toLowerCase().includes('environment')
                            );
                            targetDeviceId = rearCamera ? rearCamera.deviceId : videoInputs[0].deviceId; 
                            targetFacingMode = rearCamera ? 'environment' : (videoInputs[0].label.toLowerCase().includes('front') ? 'user' : 'environment');
                            console.log("Determined initial targetDeviceId:", targetDeviceId, "facingMode:", targetFacingMode);
                        } else {
                            // If a selected camera is found, try to determine its facing mode
                            const selectedCamera = videoInputs.find(device => device.deviceId === targetDeviceId);
                            if (selectedCamera) {
                                targetFacingMode = selectedCamera.label.toLowerCase().includes('front') ? 'user' : 'environment';
                            }
                        }
                        
                        setSelectedCameraId(targetDeviceId); 
                        startCamera(targetDeviceId, targetFacingMode); 

                    } catch (err) { 
                        console.error("Errore nell'enumerazione dei dispositivi o nell'avvio iniziale:", err);
                        setError("Impossibile enumerare le fotocamere o avviare la fotocamera iniziale. Controlla i permessi del browser.");
                        setCameraStatusMessage("Errore configurazione fotocamera.");
                    }
                };

                setupDevicesAndStartInitialCamera();

                // Cleanup function for useEffect
                return () => {
                    stopCurrentStream(currentStream); // This ensures stream is stopped when component unmounts or dependencies change
                };
            }, [isOpen]); // Keep isOpen as the primary dependency for this effect

            // Effect to restart camera if selectedCameraId changes (user selects from dropdown)
            React.useEffect(() => {
                if (isOpen && selectedCameraId && currentStream && currentStream.getTracks().length > 0 && currentStream.getVideoTracks()[0].getSettings().deviceId !== selectedCameraId) {
                    console.log("Selected camera ID changed by user, restarting camera with:", selectedCameraId);
                    const selectedCam = availableCameras.find(cam => cam.deviceId === selectedCameraId);
                    const facingMode = selectedCam ? (selectedCam.label.toLowerCase().includes('front') ? 'user' : 'environment') : 'environment';
                    startCamera(selectedCameraId, facingMode);
                }
            }, [selectedCameraId, isOpen, startCamera, currentStream, availableCameras]);


            // Capture the image from the video feed and pass it via onCapture
            const takePhoto = () => {
                console.log("Attempting to take photo...");
                // Add an explicit check for videoRef.current before accessing its properties
                if (!videoRef.current || videoRef.current.readyState < 3 || !currentStream) {
                    setError("Errore: Elemento video non disponibile o non pronto.");
                    setCameraStatusMessage("Errore interno: Video non pronto.");
                    console.error("videoRef.current is null or not ready when attempting to take photo.");
                    return;
                }

                const video = videoRef.current;
                const canvas = canvasRef.current;
                
                // Define the target aspect ratio for a card (e.g., 3:4 or 2.5:3.5)
                // For a standard Pokemon card, typical dimensions are about 6.3 cm x 8.8 cm
                // Ratio: 8.8 / 6.3 ≈ 1.396 or ~ 3.5 / 2.5 = 1.4
                // Let's use 3:4 aspect ratio for simplicity, which is 192x256 pixels as our target output.
                const targetWidth = 192; // px
                const targetHeight = 256; // px

                // Calculate the crop area to maintain 3:4 aspect ratio from the video stream
                const videoRatio = video.videoWidth / video.videoHeight;
                const targetRatio = targetWidth / targetHeight;

                let sx, sy, sWidth, sHeight; // Source x, y, width, height for cropping

                if (videoRatio > targetRatio) {
                    // Video is wider than target. Crop left/right.
                    sHeight = video.videoHeight;
                    sWidth = sHeight * targetRatio;
                    sx = (video.videoWidth - sWidth) / 2;
                    sy = 0;
                } else {
                    // Video is taller than target. Crop top/bottom.
                    sWidth = video.videoWidth;
                    sHeight = sWidth / targetRatio;
                    sx = 0;
                    sy = (video.videoHeight - sHeight) / 2;
                }

                canvas.width = targetWidth;
                canvas.height = targetHeight;

                const context = canvas.getContext('2d');
                // Draw the cropped video frame onto the canvas
                context.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);

                const imageDataUrl = canvas.toDataURL('image/png');
                onCapture(imageDataUrl);
                onClose();
            };

            if (!isOpen) return null; // Do not render anything if the modal is not open

            return (
                <div className="camera-modal-overlay">
                    <div className="camera-modal-content">
                        <h2 className="text-xl font-bold text-blue-400 mb-4">Cattura Immagine dalla Fotocamera</h2>
                        {error && <p className="text-red-500 mb-4">{error}</p>}
                        {!error && <p className="text-blue-300 mb-4">{cameraStatusMessage}</p>}

                        {/* Dropdown for camera selection */}
                        {availableCameras.length > 1 && (
                            <div className="mb-4 w-full max-w-xs">
                                <label htmlFor="camera-select" className="block text-gray-300 text-sm font-bold mb-2">
                                    Seleziona Fotocamera:
                                </label>
                                <select
                                    id="camera-select"
                                    value={selectedCameraId || ''}
                                    onChange={(e) => e.stopPropagation() || setSelectedCameraId(e.target.value)}
                                    className="block w-full p-2 rounded-md bg-gray-600 text-white border border-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                >
                                    {availableCameras.map(camera => (
                                        <option key={camera.deviceId} value={camera.deviceId}>
                                            {camera.label || `Fotocamera ${camera.deviceId.substring(0, 5)}...`}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        )}

                        {/* Video Feed with framing overlay */}
                        <div className="camera-video-container">
                            <video 
                                ref={videoRef} 
                                className="camera-video" 
                                autoPlay 
                                playsInline 
                                muted 
                                style={{ transform: isFrontCamera ? 'scaleX(-1)' : 'scaleX(1)' }} /* Apply flip only if it's a front camera */
                            ></video>
                            {/* Overlay for card framing */}
                            <div className="capture-frame-overlay"></div>
                            {/* Overlay for status/error messages if video is not ready */}
                            {(!currentStream || error || videoRef.current?.readyState < 2) && (
                                <div className="absolute inset-0 flex justify-center items-center bg-gray-900 bg-opacity-80 text-gray-400 text-center p-4">
                                    {error || cameraStatusMessage || "Attendere il video..."}
                                </div>
                            )}
                        </div>
                        
                        <canvas ref={canvasRef} className="camera-canvas"></canvas>
                        <div className="flex space-x-4 mt-4">
                            <button
                                onClick={takePhoto}
                                className="px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors shadow-lg font-bold disabled:opacity-50"
                                disabled={!currentStream || !videoRef.current || videoRef.current.videoWidth === 0 || videoRef.current.readyState < 3} 
                            >
                                Scatta Foto
                            </button>
                            <button
                                onClick={onClose}
                                className="px-6 py-3 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-lg font-bold"
                            >
                                Chiudi
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // New ZoomModal Component
        function ZoomModal({ isOpen, imageUrl, onClose }) {
            if (!isOpen || !imageUrl) return null;

            return (
                <div className="zoom-modal-overlay" onClick={onClose}>
                    <div className="zoom-modal-content" onClick={(e) => e.stopPropagation()}> {/* Prevent closing when clicking on the image itself */}
                        <img src={imageUrl} alt="Zoomed Card" />
                        <button className="zoom-modal-close-btn" onClick={onClose}>×</button>
                    </div>
                </div>
            );
        }

        // NEW: RecallFromBoxModal Component
        function RecallFromBoxModal({ isOpen, onClose, boxCards, onSelectCardFromBox, onDeleteCardFromBox }) {
            const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
            const [cardToDeleteIndex, setCardToDeleteIndex] = React.useState(null);

            const handleDeleteClick = (index, e) => {
                e.stopPropagation(); // Prevent selecting the card when clicking delete
                setCardToDeleteIndex(index);
                setIsDeleteConfirmOpen(true);
            };

            const confirmDelete = () => {
                if (cardToDeleteIndex !== null) {
                    onDeleteCardFromBox(cardToDeleteIndex);
                    setIsDeleteConfirmOpen(false);
                    setCardToDeleteIndex(null);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay"> {/* Reusing zoom-modal-overlay for consistent styling */}
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Box</h2>
                        {boxCards.length === 0 ? (
                            <p className="text-gray-400 text-lg">Il box è vuoto. Invia prima alcune carte!</p>
                        ) : (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {boxCards.map((card, index) => (
                                    <div
                                        key={index}
                                        className="relative bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromBox(card, index)}
                                    >
                                        <img
                                            src={card.imageUrl}
                                            alt={`Box Card ${index + 1}`}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs">HP: {card.baseHp}</p>
                                        <p className="text-gray-300 text-xs">EXP: {card.exp}</p>
                                        <button
                                            onClick={(e) => handleDeleteClick(index, e)}
                                            className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700"
                                            title="Elimina dal Box"
                                        >
                                            X
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>

                        {/* Delete Confirmation Modal (internal to RecallFromBoxModal) */}
                        {isDeleteConfirmOpen && (
                            <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-30 rounded-lg p-6">
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    Sei sicuro di voler eliminare questa carta dal Box?
                                </p>
                                <div className="flex space-x-4">
                                    <button
                                        onClick={confirmDelete}
                                        className="btn-theme btn-red text-base md:text-lg"
                                    >
                                        Sì
                                    </button>
                                    <button
                                        onClick={() => setIsDeleteConfirmOpen(false)}
                                        className="btn-theme btn-gray text-base md:text-lg"
                                    >
                                        No
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // NEW: SelectFromDatabaseModal Component
        // This component now accepts a 'cardsData' prop which will be either pokemonDbCards or trainersDbCards
        function SelectFromDatabaseModal({ isOpen, onClose, onSelectCardFromDatabase, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Database</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta trovata. Assicurati che il database contenga carte o prova a cercare un altro nome.</p>
                        )}

                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromDatabase(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {/* Only show HP if it's a Pokemon card (baseHp > 0 or defined) */}
                                        {card.baseHp !== undefined && card.baseHp > 0 && (
                                            <p className="text-gray-400 text-xs">HP: {card.baseHp}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: SelectFromSupabaseTableModal Component
        function SelectFromSupabaseTableModal({ isOpen, onClose, onSelectTableAndFetchRandom }) {
            const tableOptions = ['rosa', 'verde', 'blu', 'giallo', 'rosso', 'oro'];
            const [selectedTable, setSelectedTable] = React.useState('');
            const [isLoadingRandomCard, setIsLoadingRandomCard] = React.useState(false);
            const [randomCardError, setRandomCardError] = React.useState(null);

            const handleSelect = async () => {
                if (selectedTable) {
                    setIsLoadingRandomCard(true);
                    setRandomCardError(null);
                    try {
                        await onSelectTableAndFetchRandom(selectedTable);
                        onClose(); // Close modal on success
                    } catch (error) {
                        console.error("Errore nel recupero della carta casuale dalla tabella:", error);
                        setRandomCardError("Errore nel recupero della carta casuale: " + error.message);
                    } finally {
                        setIsLoadingRandomCard(false);
                    }
                }
            };

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Scegli Tabella per Carta Casuale</h2>
                        <select
                            value={selectedTable}
                            onChange={(e) => e.stopPropagation() || setSelectedTable(e.target.value)}
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                            <option value="">Seleziona una tabella</option>
                            {tableOptions.map(table => (
                                <option key={table} value={table}>{table.charAt(0).toUpperCase() + table.slice(1)}</option>
                            ))}
                        </select>

                        <button
                            onClick={handleSelect}
                            className="btn-theme btn-green px-6 py-3 text-lg disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={!selectedTable || isLoadingRandomCard}
                        >
                            {isLoadingRandomCard ? 'Caricamento...' : 'Scegli e Carica Casuale'}
                        </button>

                        {randomCardError && <p className="text-red-500 mt-4">{randomCardError}</p>}

                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Annulla
                        </button>
                    </div>
                </div>
            );
        }

        // NEW: SelectFromPalestreModal Component
        function SelectFromPalestreModal({ isOpen, onClose, onSelectCardFromPalestre, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;

            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Database Palestre</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta palestra..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte palestra...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta palestra trovata. Assicurati che il database contenga carte o prova a cercare un altro nome.</p>
                        )}

                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromPalestre(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {/* Palestre cards typically don't have HP/EXP, so no need to display them */}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>
                    </div>
                </div>
            );
        }


        // NEW: AddCardChoiceModal Component
        function AddCardChoiceModal({ isOpen, onClose, onChooseNew, onChooseFromBox, onChooseFromDatabase, onChooseFromSupabaseTable, onChooseFromPalestre }) {
            if (!isOpen) return null;

            return (
                <div className="zoom-modal-overlay"> {/* Reusing overlay style */}
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-6 text-center">Come vuoi aggiungere la carta?</h2>
                        <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                            <button
                                onClick={onChooseNew}
                                className="btn-theme btn-green px-6 py-3 text-lg"
                            >
                                Nuova Carta 📸
                            </button>
                            <button
                                onClick={onChooseFromBox}
                                className="btn-theme btn-blue px-6 py-3 text-lg"
                            >
                                Scegli dal Box 📦
                            </button>
                            <button
                                onClick={onChooseFromDatabase}
                                className="btn-theme btn-yellow px-6 py-3 text-lg"
                            >
                                Scegli dal Database 📚
                            </button>
                            <button
                                onClick={onChooseFromSupabaseTable} /* New button */
                                className="btn-theme btn-orange px-6 py-3 text-lg"
                            >
                                Casuale da Tabella 🎲
                            </button>
                            <button
                                onClick={onChooseFromPalestre} /* New button for Palestre */
                                className="btn-theme btn-purple px-6 py-3 text-lg"
                            >
                                Scegli da Palestre 🏛️
                            </button>
                        </div>
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-8 px-6 py-2 text-lg"
                        >
                            Annulla
                        </button>
                    </div>
                </div>
            );
        }


        // CardSlot component - Represents a single card slot
        function CardSlot({ slotIndex, cardData, onUpdateCard, onToggleActivePokemon, isMyTurn, activeCardParalyzed, onSendToBox, onRecallFromBox, boxCards, pokemonDbCards, trainersDbCards, palestreDbCards, isDbLoading, dbError, onSelectTableAndFetchRandom, onSelectPalestreCard }) { // Added onSelectPalestreCard prop
            // Internal state for Base HP, Damage Taken, statuses, card image, and experience points,
            // initialized from props or default values
            const [baseHp, setBaseHp] = React.useState(cardData ? cardData.baseHp : 0);
            const [damageTaken, setDamageTaken] = React.useState(cardData ? cardData.damageTaken : 0);
            const [statuses, setStatuses] = React.useState(cardData ? cardData.statuses : Array(5).fill(false));
            const [cardImage, setCardImage] = React.useState(cardData ? cardData.imageUrl : null);
            // Removed currentExp state
            const [isActivePokemon, setIsActivePokemon] = React.useState(cardData ? cardData.isActivePokemon : false); // New state for active Pokémon

            // State for the generic confirmation window and details of the action to confirm
            const [isConfirmModalOpen, setIsConfirmModal] = React.useState(false);
            const [confirmAction, setConfirmAction] = React.useState(null); // { type: 'replace_image' | 'reset_full_slot' | 'send_to_box' | 'save_and_recall_from_box' | 'save_and_select_from_db' | 'save_and_select_from_supabase_table' | 'save_and_select_from_palestre', imageUrl?: string, cardDetailsFromDb?: object }

            // Reference for the hidden file input element
            const fileInputRef = React.useRef(null);
            const [showCameraModal, setShowCameraModal] = React.useState(false); // State for the camera modal

            // New state for zoom modal
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            // NEW: State for recall from box modal
            const [showRecallFromBoxModal, setShowRecallFromBoxModal] = React.useState(false);
            // NEW: State for the add card choice modal
            const [showAddCardChoiceModal, setShowAddCardChoiceModal] = React.useState(false);
            // NEW: State for select from database modal
            const [showSelectFromDatabaseModal, setShowSelectFromDatabaseModal] = React.useState(false);
            // NEW: State for select from Supabase Table modal
            const [showSelectFromSupabaseTableModal, setShowSelectFromSupabaseTableModal] = React.useState(false);
            // NEW: State for select from Palestre modal
            const [showSelectFromPalestreModal, setShowSelectFromPalestreModal] = React.useState(false);


            // States for in-slot image zoom and pan
            const [zoomLevel, setZoomLevel] = React.useState(1.0);
            const [panX, setPanX] = React.useState(0); // in pixels
            const [panY, setPanY] = React.useState(0); // in pixels

            const MAX_ZOOM = 3.0;
            const MIN_ZOOM = 1.0;
            const ZOOM_STEP = 0.1;

            // Function to reset zoom and pan
            const resetCardView = React.useCallback(() => {
                setZoomLevel(1.0);
                setPanX(0);
                setPanY(0);
            }, []);

            // Effect to synchronize internal state with changes in the cardData prop
            React.useEffect(() => {
                if (cardData) {
                    setBaseHp(cardData.baseHp);
                    setDamageTaken(cardData.damageTaken);
                    setStatuses(cardData.statuses);
                    setCardImage(cardData.imageUrl);
                    // Removed currentExp update
                    setIsActivePokemon(cardData.isActivePokemon); // Synchronize the new state
                    // Removed initial zoom when a card is loaded
                    // setZoomLevel(1.0 + (5 * ZOOM_STEP)); 
                    // setPanX(0);
                    // setPanY(0);
                } else {
                    // Reset internal state if cardData is null (clean slot)
                    setBaseHp(0);
                    setDamageTaken(0);
                    setStatuses(Array(5).fill(false));
                    setCardImage(null);
                    // Removed currentExp reset
                    setIsActivePokemon(false); // Also reset active state
                    setZoomLevel(1.0); // Reset to default zoom for empty slot
                    setPanX(0);
                    setPanY(0);
                }
            }, [cardData]); // Dependency on cardData ensures this effect runs when cardData changes

            /**
             * Updates the card data in a specific slot.
             * @param {number} index - The index of the card slot (0-5).
             * @param {object | null} cardData - The new card data or null to clear the slot.
             */
            const updateParentCardData = React.useCallback((newBaseHp, newDamageTaken, newStatuses, newImageUrl, newExpValue, newIsActivePokemon) => { // newExpValue added
                onUpdateCard(slotIndex, {
                    imageUrl: newImageUrl,
                    baseHp: newBaseHp,
                    damageTaken: newDamageTaken,
                    statuses: newStatuses,
                    exp: newExpValue, // Pass newExpValue
                    isActivePokemon: newIsActivePokemon // Include the new state
                });
            }, [onUpdateCard, slotIndex]); // Add onUpdateCard and slotIndex to dependencies

            /**
             * Handles the selection of a new image (either from file or camera).
             * If an existing card is present, it shows a confirmation window.
             * Otherwise, it loads the image directly.
             * @param {string} imageUrl - The Data URL of the new image to load.
             * @param {object} [cardDetailsFromDb] - Optional: { baseHp, exp } if from database.
             */
            const handleNewImageSelection = (imageUrl, cardDetailsFromDb = {}) => {
                const expFromDb = cardDetailsFromDb.exp !== undefined ? cardDetailsFromDb.exp : (cardData ? cardData.exp : 0); // Preserve existing exp or default
                if (cardImage) { // If an existing image, ask the user
                    setConfirmAction({ type: 'replace_image', imageUrl: imageUrl, cardDetailsFromDb: { ...cardDetailsFromDb, exp: expFromDb } }); // Pass exp to confirmAction
                    setIsConfirmModal(true);
                } else { // No existing image, set it and update the parent
                    setCardImage(imageUrl);
                    // Use provided HP/EXP or default to 0
                    const newBaseHp = cardDetailsFromDb.baseHp !== undefined ? cardDetailsFromDb.baseHp : baseHp;
                    updateParentCardData(newBaseHp, damageTaken, statuses, imageUrl, expFromDb, isActivePokemon); // Pass expFromDb
                }
                resetCardView(); // Reset view after image selection attempt
            };

            /**
             * Handles loading a local image file.
             * @param {Event} event - The change event from the file input.
             */
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        handleNewImageSelection(reader.result); // Pass the Data URL to the unified function
                    };
                    reader.readAsDataURL(file); // Reads the image file as a Data URL
                }
                resetCardView(); // Reset view after file upload attempt
            };

            /**
             * Handles confirmation window actions (keep or clear data).
             * @param {string} actionType - 'confirm_replace_image', 'reset_full_slot', or 'send_to_box'.
             * @param {boolean} [shouldResetDataForImageReplace=false] - Only for 'confirm_replace_image', true if data should be cleared.
             */
            const handleConfirmAction = (actionType, shouldResetDataForImageReplace = false) => {
                setIsConfirmModal(false); // Close the modal immediately

                if (actionType === 'confirm_replace_image' && confirmAction && confirmAction.type === 'replace_image') {
                    const imageUrl = confirmAction.imageUrl;
                    const cardDetailsFromDb = confirmAction.cardDetailsFromDb || {};
                    const currentExpValue = cardData ? cardData.exp : 0; // Get current exp from cardData for non-reset case

                    if (shouldResetDataForImageReplace) {
                        const newBaseHp = cardDetailsFromDb.baseHp !== undefined ? cardDetailsFromDb.baseHp : 0;
                        const newExp = cardDetailsFromDb.exp !== undefined ? cardDetailsFromDb.exp : 0; // Use exp from DB or 0
                        setBaseHp(newBaseHp);
                        setDamageTaken(0);
                        setStatuses(Array(5).fill(false));
                        // Removed setCurrentExp
                        setCardImage(imageUrl);
                        setIsActivePokemon(false); // Also clear active state
                        updateParentCardData(newBaseHp, 0, Array(5).fill(false), imageUrl, newExp, false); // Pass newExp here
                    } else {
                        setCardImage(imageUrl);
                        updateParentCardData(baseHp, damageTaken, statuses, imageUrl, currentExpValue, isActivePokemon); // Pass currentExpValue
                    }
                } else if (actionType === 'reset_full_slot' && confirmAction && confirmAction.type === 'reset_full_slot') { // This condition is correct
                    setCardImage(null);
                    setBaseHp(0);
                    setDamageTaken(0);
                    setStatuses(Array(5).fill(false));
                    // Removed setCurrentExp
                    setIsActivePokemon(false); // Also reset active state
                    onUpdateCard(slotIndex, null); // Pass null to completely remove the card
                } else if (actionType === 'send_to_box' && confirmAction && confirmAction.type === 'send_to_box') {
                    if (cardData) { // Ensure there's actually a card to send
                        onSendToBox({
                            imageUrl: cardImage,
                            baseHp: baseHp,
                            exp: cardData.exp // Use exp from original cardData
                        }, slotIndex);
                    }
                } else if (actionType === 'save_and_recall_from_box' && confirmAction && confirmAction.type === 'save_and_recall_from_box') {
                    if (shouldResetDataForImageReplace) { // This means "Sì" to saving current card
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: cardData.exp }, slotIndex); // Save current card
                    } else { // This means "No" to saving current card, but still proceeding to recall
                        // The current card will be overwritten, no explicit action needed here for it
                    }
                    setShowRecallFromBoxModal(true); // Always open the recall modal after confirmation
                } else if (actionType === 'save_and_select_from_db' && confirmAction && confirmAction.type === 'save_and_select_from_db') {
                    if (shouldResetDataForImageReplace) { // "Sì" to saving current card
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: cardData.exp }, slotIndex);
                    }
                    setShowSelectFromDatabaseModal(true); // Open database modal
                } else if (actionType === 'save_and_select_from_supabase_table' && confirmAction && confirmAction.type === 'save_and_select_from_supabase_table') {
                    if (shouldResetDataForImageReplace) { // "Sì" to saving current card
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: cardData.exp }, slotIndex);
                    }
                    setShowSelectFromSupabaseTableModal(true); // Open Supabase table modal
                } else if (actionType === 'save_and_select_from_palestre' && confirmAction && confirmAction.type === 'save_and_select_from_palestre') {
                    if (shouldResetDataForImageReplace) { // "Sì" to saving current card
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: cardData.exp }, slotIndex);
                    }
                    setShowSelectFromPalestreModal(true); // Open Palestre modal
                }
                setConfirmAction(null); // Reset the pending action
                // Removed resetCardView() from here
            };


            /**
             * Handles manual modification of the Base HP value.
             * @param {Event} event - The input change event.
             */
            const handleBaseHpChange = (event) => {
                const value = parseInt(event.target.value) || 0; // Convert to number, default 0
                setBaseHp(value);
                // When EXP is removed from UI, we should still pass the actual exp value from cardData
                const currentExpValue = cardData ? cardData.exp : 0;
                updateParentCardData(value, damageTaken, statuses, cardImage, currentExpValue, isActivePokemon);
                // Removed resetCardView() from here
            };

            /**
             * Handles modification of the Damage counter, in multiples of 10.
             * @param {number} amount - The amount (multiple of 10) to add (or subtract) to Damage.
             */
            const handleDamageChange = (amount) => {
                setDamageTaken(prevDamage => {
                    const newDamage = Math.max(0, prevDamage + amount); // Damage cannot be negative
                    const currentExpValue = cardData ? cardData.exp : 0; // Retrieve exp from cardData
                    updateParentCardData(baseHp, newDamage, statuses, cardImage, currentExpValue, isActivePokemon); 
                    return newDamage;
                });
                // Removed resetCardView() from here
            };

            /**
             * Handles modification of the EXP counter for the current card.
             * Ensures experience remains between 0 and 6.
             * @param {number} amount - The amount to add (or subtract) to EXP.
             */
            // Removed handleExpChange function

            /**
             * Toggles the state of a specific status marker.
             * @param {number} index - The index of the status marker (0-4).
             */
            const toggleStatus = (index) => {
                // Status toggles are only allowed if the Pokémon is active
                if (!isActivePokemon) return; 

                setStatuses(prevStatuses => {
                    const newStatuses = [...prevStatuses];
                    newStatuses[index] = !newStatuses[index]; // Toggle the status
                    const currentExpValue = cardData ? cardData.exp : 0; // Retrieve exp from cardData
                    updateParentCardData(baseHp, damageTaken, newStatuses, cardImage, currentExpValue, isActivePokemon);
                    return newStatuses;
                });
                // Removed resetCardView() from here
            };

            /**
             * Requests confirmation to completely reset the card slot.
             */
            const requestFullSlotReset = () => {
                setConfirmAction({ type: 'reset_full_slot' });
                setIsConfirmModal(true);
                // Removed resetCardView() from here
            };

            /**
             * Handles sending the card to the box.
             */
            const handleSendToBox = () => {
                if (cardData) { // Only allow sending to box if there's a card in the slot
                    setConfirmAction({ type: 'send_to_box' });
                    setIsConfirmModal(true);
                }
                // Removed resetCardView() from here
            };

            // Handles the click on the "BOX" button for recalling
            const handleBoxRecallClick = () => {
                if (cardData) { // If there's a card in the slot, ask to save it first
                    setConfirmAction({ type: 'save_and_recall_from_box' });
                    setIsConfirmModal(true);
                } else { // If the slot is empty, directly open the recall modal
                    setShowRecallFromBoxModal(true);
                }
                // Removed resetCardView() from here
            };

            // NEW: Handle click on the "Aggiungi Carta" placeholder when slot is empty
            const handleAddCardPlaceholderClick = () => {
                // Now always show the choice modal first
                setShowAddCardChoiceModal(true);
                // Removed resetCardView() from here
            };

            // NEW: Handlers for the AddCardChoiceModal
            const handleChooseNewCard = () => {
                setShowAddCardChoiceModal(false); // Close choice modal
                setShowCameraModal(true); // Open camera modal
                // Removed resetCardView() from here
            };

            const handleChooseFromBox = () => {
                setShowAddCardChoiceModal(false); // Close choice modal
                setShowRecallFromBoxModal(true); // Open recall modal
                // Removed resetCardView() from here
            };

            // NEW: Handler for choosing from database
            const handleChooseFromDatabase = () => {
                setShowAddCardChoiceModal(false); // Close choice modal
                if (cardData) { // If there's a card in the slot, ask to save it first
                    setConfirmAction({ type: 'save_and_select_from_db' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromDatabaseModal(true); // Directly open database modal
                }
                // Removed resetCardView() from here
            };

            // NEW: Handler for choosing from Supabase table
            const handleChooseFromSupabaseTable = () => {
                setShowAddCardChoiceModal(false); // Close choice modal
                if (cardData) { // If there's a card in the slot, ask to save it first
                    setConfirmAction({ type: 'save_and_select_from_supabase_table' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromSupabaseTableModal(true); // Directly open Supabase table modal
                }
            };

            // NEW: Handler for choosing from Palestre table
            const handleChooseFromPalestre = () => {
                setShowAddCardChoiceModal(false); // Close choice modal
                if (cardData) { // If there's a card in the slot, ask to save it first
                    setConfirmAction({ type: 'save_and_select_from_palestre' });
                    setIsConfirmModal(true);
                } else {
                    setShowSelectFromPalestreModal(true); // Directly open Palestre modal
                }
            };

            // NEW: Handler for selecting a card from the database modal
            const handleSelectCardFromDatabase = (selectedCard) => {
                // selectedCard already contains the correctly mapped properties (imageUrl, baseHp, exp)
                // from the App component's Supabase fetch.
                // We can directly pass these to handleNewImageSelection.
                handleNewImageSelection(selectedCard.imageUrl, { 
                    baseHp: selectedCard.baseHp, 
                    exp: selectedCard.exp 
                });
                setShowSelectFromDatabaseModal(false); // Close modal after selection
                resetCardView();
            };

            // NEW: Handler for selecting a random card from a Supabase table
            const handleSelectRandomCardFromSupabaseTable = async (tableName) => {
                try {
                    const randomCard = await onSelectTableAndFetchRandom(tableName); // Call the parent function
                    if (randomCard) {
                        handleNewImageSelection(randomCard.imageUrl, { baseHp: randomCard.baseHp, exp: randomCard.exp });
                    } else {
                        throw new Error("Nessuna carta trovata nella tabella selezionata.");
                    }
                } catch (error) {
                    console.error("Errore durante il recupero della carta casuale:", error);
                    // The error state is handled by SelectFromSupabaseTableModal itself
                } finally {
                    setShowSelectFromSupabaseTableModal(false); // Close modal regardless of success/failure
                    resetCardView();
                }
            };

            // NEW: Handler for selecting a card from the Palestre modal
            const handleSelectCardFromPalestreCallback = (selectedCard) => {
                onSelectPalestreCard(selectedCard); // Pass the entire selected palestre card to App
                setShowSelectFromPalestreModal(false); // Close modal after selection
                // No need to reset card view here, as the App component will update slots 0 and 1
            };


            /**
             * Toggles the active Pokémon status for this slot.
             * Calls the function passed from the parent to handle uniqueness logic.
             */
            const handleToggleActivePokemon = () => {
                // The actual logic for toggling and unique active is in App.js.
                // We just need to ensure we don't try to toggle if App.js has disabled it for 'paralyzed' reasons.
                onToggleActivePokemon(slotIndex); // Call parent function
                // Removed resetCardView() from here
            };

            // Update internal isActivePokemon state when the prop changes
            React.useEffect(() => {
                setIsActivePokemon(cardData ? cardData.isActivePokemon : false);
                // When the isActivePokemon prop becomes false (deactivated by another slot),
                // the parent App component already resets its statuses.
                // So, no need to call setStatuses here.
            }, [cardData ? cardData.isActivePokemon : undefined]); // Only depend on isActivePokemon part of cardData

            // Determine if the star button (toggle active) should be disabled for this specific CardSlot
            // This button should be disabled if:
            // 1. It's not my turn.
            // 2. An active card (potentially this one) is paralyzed, AND it's my turn.
            const isStarButtonDisabled = !isMyTurn || (isMyTurn && activeCardParalyzed && !isActivePokemon) || (isMyTurn && isActivePokemon && cardData && cardData.statuses[3]);


            // Tailwind CSS classes for status marker colors
            const statusColors = [
                'bg-lime-500 hover:bg-lime-600',    /* 😴 Asleep (Lime Green) */
                'bg-rose-500 hover:bg-rose-600',    /* 🔥 Burned (Rose/Red) */
                'bg-sky-500 hover:bg-sky-600',      /* 😵 Confused (Sky Blue) */
                'bg-yellow-500 hover:bg-yellow-600', /* 🛑 Paralizzato (Yellow) */
                'bg-purple-500 hover:bg-purple-600' /* 💀 Avvelenato (Purple) - Original color */
            ];

            const currentHpValue = baseHp - damageTaken;

            // --- In-slot image zoom and pan functions ---
            const handleZoom = (factor) => {
                setZoomLevel(prevZoom => {
                    const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, prevZoom * factor));
                    // When zooming, we try to keep the center. Pan values are reset on zoom out to MIN_ZOOM.
                    if (newZoom === MIN_ZOOM) {
                        setPanX(0);
                        setPanY(0);
                    }
                    return newZoom;
                });
            };

            const handleResetView = () => {
                setZoomLevel(1.0);
                setPanX(0);
                setPanY(0);
            };

            return (
                <div className={`relative p-6 rounded-xl shadow-2xl flex flex-col items-center border-4 ${isActivePokemon ? 'border-blue-400 bg-blue-900 bg-opacity-70' : 'border-yellow-400 bg-gray-800'}`}>
                    {/* Hidden file input for file upload */}
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleFileUpload}
                        ref={fileInputRef}
                        className="hidden" 
                    />

                    {/* Current HP Container and Active Indicator */}
                    <div className="flex items-center justify-between w-full mb-4">
                        {/* Current HP moved above the image */}
                        <div className="flex items-center space-x-2 text-2xl bg-gray-900 p-2 rounded-lg border-2 border-green-600 shadow-md flex-grow">
                            <span className="counter-label text-green-300">HP:</span>
                            <span className="counter-value text-green-500">{currentHpValue}</span>
                        </div>
                        {/* Active Icon */}
                        <button
                            onClick={handleToggleActivePokemon} // Use the new handler
                            className={`ml-4 flex items-center justify-center w-12 h-12 rounded-full text-3xl shadow-md transition-all duration-200 ease-in-out border-2 ${isActivePokemon ? 'bg-yellow-400 border-yellow-600 text-gray-800' : 'bg-gray-600 border-gray-700 text-gray-300 hover:bg-gray-500'} ${isStarButtonDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                            title={isActivePokemon ? 'Pokémon Attivo' : 'Rendi Attivo'}
                            disabled={isStarButtonDisabled}
                        >
                            ⭐
                        </button>
                    </div>


                    {/* FAINTED Banner - Now appears only if there's an image AND HP <= 0 */}
                    {currentHpValue <= 0 && cardImage && (
                        <div className="absolute top-36 w-48 bg-red-700 text-white text-center font-extrabold text-2xl py-2 rounded-lg border-2 border-red-400 z-10 animate-pulse shadow-lg">
                            ESAUSTO
                        </div>
                    )}

                    {cardImage ? (
                        // Display the card image if available with zoom/pan controls
                        <div className="relative w-48 h-64 overflow-hidden rounded-lg border-2 border-gray-600 mb-6 bg-gray-900 shadow-inner">
                            <img
                                src={cardImage}
                                alt={"Carta " + (slotIndex + 1)}
                                className="w-full h-full object-cover transition-transform duration-100 ease-out cursor-pointer"
                                style={{ transform: `scale(${zoomLevel}) translate(${panX}px, ${panY}px)` }}
                                onClick={() => setShowZoomModal(true)} /* Open zoom modal on click */
                                onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/192x256/444/bbb?text=Errore+Immagine"; }}
                            />
                            {/* Zoom controls overlay */}
                            <div className="absolute bottom-2 right-2 flex items-center space-x-1 bg-gray-900 bg-opacity-70 p-1 rounded-lg shadow-md">
                                <button
                                    onClick={(e) => e.stopPropagation() || handleZoom(1 / (1 + ZOOM_STEP))} /* Zoom out */
                                    className="w-8 h-8 rounded-full bg-blue-600 text-white text-xl font-bold flex items-center justify-center shadow-md hover:bg-blue-700 transition-colors"
                                    title="Zoom Out"
                                    disabled={zoomLevel <= MIN_ZOOM}
                                >
                                    -
                                </button>
                                <button
                                    onClick={(e) => e.stopPropagation() || handleZoom(1 + ZOOM_STEP)} /* Zoom in */
                                    className="w-8 h-8 rounded-full bg-blue-600 text-white text-xl font-bold flex items-center justify-center shadow-md hover:bg-blue-700 transition-colors"
                                    title="Zoom In"
                                    disabled={zoomLevel >= MAX_ZOOM}
                                >
                                    +
                                </button>
                                <button
                                    onClick={(e) => e.stopPropagation() || handleResetView()}
                                    className="w-8 h-8 rounded-full bg-red-600 text-white text-lg flex items-center justify-center shadow-md hover:bg-red-700 transition-colors"
                                    title="Reset View"
                                >
                                    🔄
                                </button>
                            </div>
                        </div>
                    ) : (
                        // Placeholder to request image upload (vertical)
                        <div
                            className="w-48 h-64 bg-gray-900 flex justify-center items-center text-gray-400 text-xl cursor-pointer rounded-lg border-4 border-dashed border-gray-600 mb-6 hover:bg-gray-800 transition-colors duration-300 shadow-inner"
                            onClick={handleAddCardPlaceholderClick} /* NEW: Use the new handler */
                        >
                            <span className="text-center font-bold">Aggiungi Carta</span>
                        </div>
                    )}

                    {/* Show controls if an image is present OR if the slot has persistent data */}
                    {(cardData || cardImage) && (
                        <>
                            {/* Image upload buttons - now icons */}
                            <div className="flex space-x-4 mb-6 w-full justify-center">
                                <button
                                    onClick={() => { fileInputRef.current.click(); }} 
                                    className="icon-btn btn-blue"
                                    title="Carica da File"
                                >
                                    📁
                                </button>
                                <button
                                    onClick={() => { setShowCameraModal(true); }} 
                                    className="icon-btn btn-purple"
                                    title="Carica da Fotocamera"
                                >
                                    📸
                                </button>
                            </div>

                            {/* Manual HP Input (no spinners) */}
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-red-300">HP Base:</span>
                                <input
                                    type="number"
                                    value={baseHp}
                                    onChange={handleBaseHpChange}
                                    className="w-24 px-3 py-2 bg-gray-900 border-2 border-red-500 rounded-lg text-center text-red-200 font-extrabold shadow-inner focus:outline-none focus:ring-2 focus:ring-red-400 no-spinner"
                                    min="0"
                                />
                            </div>

                            {/* Damage Counter */}
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-orange-300">Danni:</span>
                                <button
                                    onClick={() => handleDamageChange(-10)}
                                    className="btn-theme btn-yellow px-4 py-2 text-xl"
                                >
                                    -10
                                </button>
                                <span className="counter-value text-red-500">{damageTaken}</span>
                                <button
                                    onClick={() => handleDamageChange(10)}
                                    className="btn-theme btn-orange px-4 py-2 text-xl"
                                >
                                    +10
                                </button>
                            </div>

                            {/* Removed Experience Counter with dots */}

                            {/* Status Markers */}
                            <div className="flex space-x-3 mb-6">
                                {statuses.map((isActive, index) => {
                                    // Classes change if the slot is NOT active
                                    const classes = [
                                        "w-10", "h-10", "rounded-full", "flex", "justify-center", "items-center",
                                        "font-bold", "transition-all", "duration-200",
                                        "ease-in-out", "transform", "border-2", "border-gray-600", "shadow-md"
                                    ];

                                    // Specific font size for '⚫' (Rock Medal) and '❄️' (Lorelei)
                                    let statusSymbol;
                                    let statusTitle;
                                    let fontSizeClass = "text-base"; // Default font size

                                    switch(index) {
                                        case 0:
                                            statusSymbol = '😴';
                                            statusTitle = 'Addormentato';
                                            break;
                                        case 1:
                                            statusSymbol = '🔥';
                                            statusTitle = 'Bruciato';
                                            break;
                                        case 2:
                                            statusSymbol = '😵';
                                            statusTitle = 'Confuso';
                                            break;
                                        case 3:
                                            statusSymbol = '🛑';
                                            statusTitle = 'Paralizzato';
                                            break;
                                        case 4:
                                            statusSymbol = '💀';
                                            statusTitle = 'Avvelenato';
                                            break;
                                        default:
                                            statusSymbol = '';
                                            statusTitle = '';
                                    }

                                    // Apply specific font size if needed for large emojis
                                    // Removed specific font size for status symbols, as they are not medals and should be consistent.
                                    fontSizeClass = "text-3xl"; // Consistent large size for status emojis
                                    classes.push(fontSizeClass);


                                    if (isActive) {
                                        classes.push(statusColors[index]);
                                        classes.push('scale-110', 'ring-2', 'ring-offset-2', 'ring-offset-gray-800', 'ring-opacity-75');
                                    } else {
                                        /* If not active, gray and not-allowed cursor, reduced opacity */
                                        classes.push('bg-gray-600', 'text-gray-300');
                                    }

                                    // Add cursor-pointer only if active, otherwise cursor-not-allowed
                                    if (isActivePokemon) {
                                        classes.push('cursor-pointer', 'hover:bg-gray-500');
                                    } else {
                                        classes.push('cursor-not-allowed', 'opacity-50');
                                    }


                                    return (
                                        <div
                                            key={index}
                                            className={classes.join(' ')} 
                                            onClick={() => toggleStatus(index)}
                                            title={statusTitle}
                                        >
                                            {statusSymbol}
                                        </div>
                                    );
                                })}
                            </div>

                            {/* Box and Reset Buttons */}
                            <div className="flex justify-center w-full mt-2 space-x-4 max-w-xs">
                                <button
                                    onClick={handleBoxRecallClick} /* For recalling from box */
                                    className="btn-theme btn-purple px-4 py-2 text-base flex-grow"
                                    title="Richiama dal Box"
                                >
                                    BOX
                                </button>
                                <button
                                    onClick={requestFullSlotReset} 
                                    className="icon-btn btn-red"
                                    title="Resetta Tutto lo Slot"
                                >
                                    🗑️
                                </button>
                            </div>
                        </>
                    )}

                    {/* Generic confirmation window (for replace image or reset slot or send to box) */}
                    {isConfirmModalOpen && (
                        <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-20 rounded-lg p-6">
                            {confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') && (
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    Vuoi mantenere i dati della carta precedente o azzerarli?
                                </p>
                            )}
                            {confirmAction && confirmAction.type === 'reset_full_slot' && (
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    Sei sicuro di voler resettare tutti i dati di questo slot?
                                    Questa azione è irreversibile.
                                </p>
                            )}
                            {confirmAction && confirmAction.type === 'send_to_box' && (
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    VUOI INVIARE AL BOX?
                                </p>
                            )}
                            {confirmAction && confirmAction.type === 'save_and_recall_from_box' && (
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    VUOI SALVARE QUESTA CARTA NEL BOX PRIMA DI SOSTITUIRLA?
                                </p>
                            )}
                            <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                                {confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') && (
                                    <button
                                        onClick={() => handleConfirmAction(confirmAction.type, false)} // Keep Data
                                        className="btn-theme btn-green text-base md:text-lg"
                                    >
                                        Mantieni Dati
                                    </button>
                                )}
                                <button
                                    onClick={() => handleConfirmAction(confirmAction.type, true)} /* Corrected call: pass correct actionType based on confirmAction.type */
                                    className="btn-theme btn-red text-base md:text-lg"
                                >
                                    {confirmAction && (confirmAction.type === 'replace_image' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_palestre') ? 'Azzera Dati' : 'Sì'}
                                </button>
                                {(confirmAction && (confirmAction.type === 'reset_full_slot' || confirmAction.type === 'send_to_box' || confirmAction.type === 'save_and_recall_from_box' || confirmAction.type === 'save_and_select_from_supabase_table' || confirmAction.type === 'save_and_select_from_db' || confirmAction.type === 'save_and_select_from_palestre')) && (
                                    <button
                                        onClick={() => { setIsConfirmModal(false); }} 
                                        className="btn-theme btn-gray text-base md:text-lg"
                                    >
                                        No
                                    </button>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Camera modal */}
                    <CameraModal
                        isOpen={showCameraModal}
                        onClose={() => { setShowCameraModal(false); }} 
                        onCapture={handleNewImageSelection} 
                    />

                    {/* Zoom modal */}
                    <ZoomModal
                        isOpen={showZoomModal}
                        imageUrl={cardImage}
                        onClose={() => setShowZoomModal(false)}
                    />

                    {/* Recall from Box modal */}
                    <RecallFromBoxModal
                        isOpen={showRecallFromBoxModal}
                        onClose={() => { setShowRecallFromBoxModal(false); }} 
                        boxCards={boxCards}
                        onSelectCardFromBox={(selectedCard, boxCardIndex) => {
                            onRecallFromBox(selectedCard, slotIndex, boxCardIndex);
                            setShowRecallFromBoxModal(false); // Close modal after selection
                            resetCardView(); // This must remain to reset view after a new card is loaded from box
                        }}
                        onDeleteCardFromBox={(indexToDelete) => {
                            // This function is passed from App -> CardSlot -> RecallFromBoxModal
                            // It directly calls the App's delete function.
                            onRecallFromBox(null, null, indexToDelete, true); // Use onRecallFromBox to trigger deletion in App
                        }}
                    />

                    {/* NEW: Select from Database Modal */}
                    <SelectFromDatabaseModal
                        isOpen={showSelectFromDatabaseModal}
                        onClose={() => setShowSelectFromDatabaseModal(false)}
                        onSelectCardFromDatabase={handleSelectCardFromDatabase}
                        cardsData={pokemonDbCards} /* Passed Pokémon cards here */
                        isLoading={isDbLoading} /* Passed from App to CardSlot */
                        error={dbError} /* Passed from App to CardSlot */
                    />

                    {/* NEW: Select from Supabase Table Modal */}
                    <SelectFromSupabaseTableModal
                        isOpen={showSelectFromSupabaseTableModal}
                        onClose={() => setShowSelectFromSupabaseTableModal(false)}
                        onSelectTableAndFetchRandom={handleSelectRandomCardFromSupabaseTable} /* Pass the new handler */
                    />

                    {/* NEW: Select from Palestre Modal */}
                    <SelectFromPalestreModal
                        isOpen={showSelectFromPalestreModal}
                        onClose={() => setShowSelectFromPalestreModal(false)}
                        onSelectCardFromPalestre={handleSelectCardFromPalestreCallback} // Updated callback
                        cardsData={palestreDbCards} /* Pass Palestre cards here */
                        isLoading={isDbLoading} /* Passed from App to CardSlot */
                        error={dbError} /* Passed from App to CardSlot */
                    />

                    {/* NEW: Add Card Choice Modal */}
                    <AddCardChoiceModal
                        isOpen={showAddCardChoiceModal}
                        onClose={() => { setShowAddCardChoiceModal(false); }} 
                        onChooseNew={handleChooseNewCard}
                        onChooseFromBox={handleChooseFromBox}
                        onChooseFromDatabase={handleChooseFromDatabase}
                        onChooseFromSupabaseTable={handleChooseFromSupabaseTable} /* New prop */
                        onChooseFromPalestre={handleChooseFromPalestre} /* New prop */
                    />
                </div>
            );
        }

        // Component for rolling dice (now more generic)
        function DiceRoller({ title, isAttackRoller, isDiceRollDisabled, onConfusedRollAttempt, isMyTurn, onDiceRollComplete, results, onSetResults, onDisplayResultsForBanner, isCaptureRoller, onCaptureCoinFlipNeeded }) { 
            const [numberOfDice, setNumberOfDice] = React.useState(1);
            const [criticalHit, setCriticalHit] = React.useState(false); // Only for isAttackRoller
            const [attackFailed, setAttackFailed] = React.useState(false); // Only for isAttackRoller
            const [retreatFailed, setRetreatFailed] = React.useState(false); // For Retreat roller
            const [retreatSuccess, setRetreatSuccess] = React.useState(false); // For Retreat roller
            const [captureFailed, setCaptureFailed] = React.useState(false); // New state for Capture roller

            // Mapping numbers to dice symbols (emoji)
            // const diceFaces = { ... }; moved globally

            const handleRoll = async () => {
                // Reset banners for all roller types
                setCriticalHit(false);
                setAttackFailed(false);
                setRetreatFailed(false);
                setRetreatSuccess(false);
                setCaptureFailed(false);

                onSetResults([]); // Clear previous results immediately via parent prop

                // Logic specific to Attack Roller
                if (isAttackRoller) {
                    // If paralyzed, prevent roll
                    if (isDiceRollDisabled === 'paralyzed') {
                        console.log("Lancio dadi bloccato: Pokémon Paralizzato.");
                        return; 
                    }

                    // If confused, perform coin flip first
                    if (isDiceRollDisabled === 'confused') { 
                        const shouldProceed = await onConfusedRollAttempt(); 
                        if (!shouldProceed) {
                            onDiceRollComplete(); // End turn even if attack failed due to confusion
                            return;
                        }
                    }
                }

                const newResults = [];
                let foursCount = 0;
                let onesCount = 0;

                for (let i = 0; i < numberOfDice; i++) {
                    const roll = Math.floor(Math.random() * 6) + 1; // 6-sided die
                    newResults.push(roll);
                    if (roll === 4) {
                        foursCount++;
                    }
                    if (roll === 1) {
                        onesCount++;
                    }
                }
                onSetResults(newResults); // Update results via parent prop
                onDisplayResultsForBanner(newResults); // Display results on the big banner

                // Determine banners and turn end based on roller type
                if (isAttackRoller) {
                    // New logic for Critical Hit based on number of dice
                    if (numberOfDice <= 3) {
                        if (foursCount >= 2) {
                            setCriticalHit(true);
                        }
                    } else { // numberOfDice > 3
                        if (foursCount >= 3) {
                            setCriticalHit(true);
                        }
                    }
                    
                    if (onesCount >= 1) {
                        setAttackFailed(true);
                        setCriticalHit(false); // Prioritize Attack Failed over Critical Hit
                    } else {
                        setAttackFailed(false);
                    }
                    onDiceRollComplete(); // End turn after a successful dice roll for Attack Roller
                } else if (!isCaptureRoller) { // Logic for Retreat Roller (not Capture Roller)
                    if (onesCount >= 1) {
                        setRetreatFailed(true);
                        setRetreatSuccess(false);
                    } else {
                        setRetreatSuccess(true);
                        setRetreatFailed(false);
                    }
                    onDiceRollComplete(); // End turn after a successful dice roll for Retreat Roller
                } else { // Logic for Capture Roller (isCaptureRoller === true)
                    if (onesCount >= 1) {
                        setCaptureFailed(true);
                        onDiceRollComplete(); // End turn immediately if capture failed
                    } else {
                        // If no 1s, trigger the coin flip in App.js
                        onCaptureCoinFlipNeeded();
                        // Do NOT call onDiceRollComplete here, App.js will handle turn end after coin flip
                    }
                }
            };

            // Determine if the roll button should be disabled for this specific DiceRoller instance
            let isDisabled = !isMyTurn; // General rule: disabled if it's not my turn
            if (isAttackRoller) {
                isDisabled = isDisabled || isDiceRollDisabled === 'asleep' || isDiceRollDisabled === 'paralyzed';
            }
            // For Retreat and Capture, the only additional disable condition is !isMyTurn, which is already covered.


            return (
                <div className="bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col items-center justify-center border-4 border-yellow-400 gap-4 flex-1 max-w-xs w-full mb-4"> {/* flex-1 and min-w to make them share space */}
                    <h2 className="text-lg font-bold text-yellow-300 whitespace-nowrap">{title}</h2>
                    
                    <div className="flex items-center space-x-2">
                        <label htmlFor={`num-dice-${title}`} className="counter-label text-white text-sm">N°:</label>
                        <select
                            id={`num-dice-${title}`}
                            value={numberOfDice}
                            onChange={(e) => e.stopPropagation() || setNumberOfDice(parseInt(e.target.value))}
                            className="bg-gray-700 text-white rounded-md p-1 text-sm border border-gray-600 focus:outline-none focus:ring-2 focus:ring-yellow-500"
                        >
                            {[1, 2, 3, 4, 5, 6].map(num => (
                                <option key={num} value={num}>{num}</option>
                            ))}
                        </select>
                    </div>

                    <button
                        onClick={handleRoll}
                        className="btn-theme btn-green text-base px-3 py-1 disabled:opacity-50 disabled:cursor-not-allowed w-full" /* Added w-full */
                        disabled={isDisabled} 
                    >
                        Lancia
                    </button>

                    {results.length > 0 && ( 
                        <div className="flex flex-wrap justify-center gap-2 text-3xl font-extrabold text-white mt-2"> 
                            {results.map((result, index) => (
                                <span key={index} className="bg-gray-900 p-2 rounded-md border-2 border-yellow-500 shadow-md flex-shrink-0">
                                    {diceFaces[result]} 
                                </span>
                            ))}
                        </div>
                    )}

                    {/* Banners only for Attack Roller */}
                    {isAttackRoller && criticalHit && (
                        <div className="mt-4 p-2 px-4 bg-green-700 text-white font-bold text-xl rounded-lg shadow-xl border-2 border-green-400 animate-pulse text-center w-full">
                            ATTACCO CRITICO!
                        </div>
                    )}
                    {isAttackRoller && attackFailed && (
                        <div className="mt-4 p-2 px-4 bg-red-700 text-white font-bold text-xl rounded-lg shadow-xl border-2 border-red-400 animate-pulse text-center w-full">
                            ATTACCO FALLITO!
                        </div>
                    )}
                    {/* Banners only for Retreat Roller */}
                    {!isAttackRoller && !isCaptureRoller && retreatFailed && (
                        <div className="mt-4 p-2 px-4 bg-red-700 text-white font-bold text-xl rounded-lg shadow-xl border-2 border-red-400 animate-pulse text-center w-full">
                            FALLITA!
                        </div>
                    )}
                    {!isAttackRoller && !isCaptureRoller && retreatSuccess && (
                        <div className="mt-4 p-2 px-4 bg-green-700 text-white font-bold text-xl rounded-lg shadow-xl border-2 border-green-400 animate-pulse text-center w-full">
                            RIUSCITA!
                        </div>
                    )}
                    {/* Banners only for Capture Roller */}
                    {isCaptureRoller && captureFailed && (
                        <div className="mt-4 p-2 px-4 bg-red-700 text-white font-bold text-xl rounded-lg shadow-xl border-2 border-red-400 animate-pulse text-center w-full">
                            FALLITA!
                        </div>
                    )}
                </div>
            );
        }

        // Removed MovementDiceRoller component
        // function MovementDiceRoller({ onRoll }) {
        //     return (
        //         <button
        //             onClick={onRoll}
        //             className="btn-theme btn-gray px-4 py-2 text-base flex flex-col items-center justify-center w-full max-w-xs mb-4" /* Added w-full max-w-xs mb-4 */
        //             title="Lancia Dado Movimento"
        //         >
        //             <span className="text-xl">🎲</span>
        //             <span className="text-xs mt-1">Movimento</span>
        //         </button>
        //     );
        // }

        // Component for the turn indicator
        function TurnIndicator({ isMyTurn, onToggleTurn }) {
            const icon = isMyTurn ? '🏁' : '🚩'; // Checkered flag for your turn, red flag for opponent
            const title = isMyTurn ? 'Il tuo turno' : 'Turno avversario';
            const bgColor = isMyTurn ? 'bg-green-500' : 'bg-red-500';
            const borderColor = isMyTurn ? 'border-green-700' : 'border-red-700';

            return (
                <button
                    onClick={onToggleTurn}
                    className={`flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md transition-all duration-200 ease-in-out border-4 ${bgColor} ${borderColor} hover:scale-105 active:scale-95 mb-4`} /* Added mb-4 */
                    title={title}
                >
                    {icon}
                </button>
            );
        }

        // New CaptureCoinFlipModal Component
        function CaptureCoinFlipModal({ isOpen, onFlipCoin, coinResult, finalOutcome }) {
            if (!isOpen) return null;

            return (
                <div className="capture-coin-modal-overlay">
                    <div className="capture-coin-modal-content">
                        {!coinResult && (
                            <>
                                <h2>Lancio della Moneta di Cattura!</h2>
                                <button onClick={onFlipCoin}>Lancia Moneta</button>
                            </>
                        )}
                        {coinResult && (
                            <>
                                <h2>Risultato: {coinResult === 'heads' ? 'TESTA' : 'CROCE'}</h2>
                                <p className={`capture-coin-result ${finalOutcome === 'PRESO' ? 'success' : 'fail'}`}>
                                    {finalOutcome}
                                </p>
                            </>
                        )}
                    </div>
                </div>
            );
        }

        // NEW: BoxView Component
        function BoxView({ boxCards, onBackToMain, onDeleteCardFromBox }) { // Added onDeleteCardFromBox
            const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
            const [cardToDeleteIndex, setCardToDeleteIndex] = React.useState(null);

            const handleDeleteClick = (index) => {
                setCardToDeleteIndex(index);
                setIsDeleteConfirmOpen(true);
            };

            const confirmDelete = () => {
                if (cardToDeleteIndex !== null) {
                    onDeleteCardFromBox(cardToDeleteIndex);
                    setIsDeleteConfirmOpen(false);
                    setCardToDeleteIndex(null);
                }
            };

            if (!isOpen) return null;

            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-gray-700 to-gray-900 p-4 relative">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8 text-center">IL TUO BOX POKÉMON</h2>
                    
                    <button
                        onClick={onBackToMain}
                        className="btn-theme btn-blue mb-8 px-6 py-3 text-lg"
                    >
                        Torna al Gioco
                    </button>

                    {boxCards.length === 0 ? (
                        <p className="text-gray-400 text-xl mt-8">Il tuo box è vuoto. Invia prima alcune carte!</p>
                    ) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-4xl">
                            {boxCards.map((card, index) => (
                                <div key={index} className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center">
                                    <img
                                        src={card.imageUrl}
                                        alt={`Carta nel Box ${index + 1}`}
                                        className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2"
                                        onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore+Immagine"; }}
                                    />
                                    <p className="text-gray-300 text-sm font-semibold">HP Base: {card.baseHp}</p>
                                    <p className="text-gray-300 text-sm font-semibold">EXP: {card.exp}</p>
                                    <button
                                        onClick={() => handleDeleteClick(index)}
                                        className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700"
                                        title="Elimina dal Box"
                                    >
                                        X
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* Delete Confirmation Modal for BoxView */}
                    {isDeleteConfirmOpen && (
                        <div className="fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-50 rounded-lg p-6">
                            <p className="text-white text-center mb-6 text-xl font-bold">
                                Sei sicuro di voler eliminare questa carta dal Box?
                                Questa azione è irreversibile.
                            </p>
                            <div className="flex space-x-4">
                                <button
                                    onClick={confirmDelete}
                                    className="btn-theme btn-red text-base md:text-lg"
                                >
                                    Sì, Elimina
                                </button>
                                <button
                                    onClick={() => setIsDeleteConfirmOpen(false)}
                                    className="btn-theme btn-gray text-base md:text-lg"
                                >
                                    No, Annulla
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // NEW: NegozioView Component (replaces BackpackView)
        function NegozioView({ negozioCards, onBackToMain, isDbLoading, dbError }) {
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);

            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };

            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-indigo-700 to-purple-900 p-4 relative">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8 text-center">NEGOZIO DI CARTE</h2>

                    <button
                        onClick={onBackToMain}
                        className="btn-theme btn-blue mb-8 px-6 py-3 text-lg"
                    >
                        Torna al Gioco
                    </button>

                    {isDbLoading && <p className="text-blue-300 text-xl mt-8">Caricamento carte negozio...</p>}
                    {dbError && <p className="text-red-500 text-xl mt-8">Errore nel caricamento del negozio: {dbError}</p>}
                    
                    {!isDbLoading && !dbError && negozioCards.length === 0 ? (
                        <p className="text-gray-400 text-xl mt-8">Il negozio è vuoto. Nessuna carta disponibile.</p>
                    ) : (
                        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 w-full max-w-4xl">
                            {negozioCards.map((card, index) => (
                                <div 
                                    key={card.id || index} 
                                    className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center cursor-pointer hover:bg-gray-700 transition-colors"
                                    onClick={() => handleCardClick(card.imageUrl)}
                                >
                                    <img
                                        src={card.imageUrl}
                                        alt={card.name || `Carta Negozio ${index + 1}`}
                                        className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2"
                                        onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore+Immagine"; }}
                                    />
                                    <p className="text-gray-300 text-sm font-semibold">{card.name || 'Carta Sconosciuta'}</p>
                                    {card.baseHp !== undefined && card.baseHp > 0 && (
                                        <p className="text-gray-400 text-xs">HP: {card.baseHp}</p>
                                    )}
                                </div>
                            ))}
                        </div>
                    )}

                    <ZoomModal
                        isOpen={showZoomModal}
                        imageUrl={zoomImageUrl}
                        onClose={() => setShowZoomModal(false)}
                    />
                </div>
            );
        }


        // App component - Main container for the game interface
        function App() {
            // Initialize card state from localStorage or an empty array of 6 slots
            const [cards, setCards] = React.useState(() => {
                const savedCards = localStorage.getItem('gameCards');
                // Ensure isActivePokemon is properly initialized for existing cards
                const initialCards = savedCards ? JSON.parse(savedCards) : Array(6).fill(null);
                // Ensure statuses array has 5 elements initialized and isActivePokemon is set
                return initialCards.map(card => card ? { 
                    ...card, 
                    isActivePokemon: card.isActivePokemon || false,
                    statuses: card.statuses && card.statuses.length === 5 ? card.statuses : Array(5).fill(false) // Ensure statuses is 5-element array
                } : null);
            });

            // State for cards in the Box
            const [boxCards, setBoxCards] = React.useState(() => {
                const savedBoxCards = localStorage.getItem('pokemonBoxCards');
                return savedBoxCards ? JSON.parse(savedBoxCards) : [];
            });

            // NEW: State for cards in the Negozio (replaces backpackCards)
            const [negozioCards, setNegozioCards] = React.useState([]); // Will be fetched from Supabase
            
            // State to control current view ('main', 'box', or 'negozio')
            const [currentView, setCurrentView] = React.useState('main');

            // States for Supabase data
            const [pokemonDbCards, setPokemonDbCards] = React.useState([]); // Renamed from dbCards for clarity
            const [trainersDbCards, setTrainersDbCards] = React.useState([]); // New state for trainer cards
            const [palestreDbCards, setPalestreDbCards] = React.useState([]); // NEW: State for palestre cards
            const [isDbLoading, setIsDbLoading] = React.useState(true);
            const [dbError, setDbError] = React.useState(null);

            // Effect to load cards from Supabase
            React.useEffect(() => {
                async function getSupabaseCards() {
                    try {
                        setIsDbLoading(true);
                        setDbError(null);

                        // Fetch Pokémon cards
                        const { data: pokemonData, error: pokemonError } = await supabase
                            .from('pokemon_cards') // Your table name in Supabase
                            .select('*');

                        if (pokemonError) {
                            throw pokemonError;
                        }

                        // Map Supabase data to the expected card format
                        const mappedPokemonCards = pokemonData.map(card => ({
                            id: card.id,
                            name: card.name,
                            imageUrl: card.image_url, // Supabase uses image_url
                            baseHp: card.base_hp,     // Supabase uses base_hp
                            exp: card.exp,
                            // Add default values for game-specific fields not in DB
                            damageTaken: 0,
                            statuses: Array(5).fill(false),
                            isActivePokemon: false
                        }));
                        setPokemonDbCards(mappedPokemonCards);
                        console.log("Supabase: Fetched Pokémon cards:", mappedPokemonCards.length);


                        // Fetch Trainer cards from 'pokemon_allenatori'
                        const { data: trainersData, error: trainersError } = await supabase
                            .from('pokemon_allenatori') // Changed to pokemon_allenatori
                            .select('*');

                        if (trainersError) {
                            throw trainersError;
                        }
                        
                        // NEW: Log the raw trainersData to help debug column names
                        console.log("Supabase: Raw Trainer data from 'pokemon_allenatori':", trainersData);

                        // Map Supabase data to the expected card format for trainer cards
                        const mappedTrainerCards = trainersData.map(card => ({
                            id: card.id,
                            // Use 'name' if it exists, otherwise fallback to 'card_name'
                            // User must confirm the correct column name for trainer card names
                            name: card.name || card.card_name, 
                            imageUrl: card.image_url, // Assuming 'image_url' for trainer cards
                            baseHp: 0, // Trainer cards don't have HP
                            exp: 0   // Trainer cards don't have EXP
                        }));
                        setTrainersDbCards(mappedTrainerCards);
                        console.log("Supabase: Fetched Trainer cards from 'pokemon_allenatori':", mappedTrainerCards.length);
                        console.log("All Trainers DB Cards (from pokemon_allenatori) after mapping:", mappedTrainerCards); // Log all trainer cards, including their names


                        // NEW: Fetch Palestre cards
                        const { data: palestreData, error: palestreError } = await supabase
                            .from('palestre') // Assuming this is the table name for palestre cards
                            .select('*');

                        if (palestreError) {
                            throw palestreError;
                        }

                        // Map Supabase data to the expected card format for palestre cards
                        const mappedPalestreCards = palestreData.map(card => ({
                            id: card.id,
                            name: card.name || card.card_name, // Assuming 'name' or 'card_name'
                            imageUrl: card.image_url,
                            baseHp: 0, // Palestre cards typically don't have HP
                            exp: 0   // Palestre cards typically don't have EXP
                        }));
                        setPalestreDbCards(mappedPalestreCards);
                        console.log("Supabase: Fetched Palestre cards:", mappedPalestreCards.length);

                        // NEW: Fetch Negozio cards
                        const { data: negozioData, error: negozioError } = await supabase
                            .from('negozio') // Assuming this is the table name for negozio cards
                            .select('*');

                        if (negozioError) {
                            throw negozioError;
                        }

                        const mappedNegozioCards = negozioData.map(card => ({
                            id: card.id,
                            name: card.name || card.card_name,
                            imageUrl: card.image_url,
                            baseHp: card.base_hp || 0,
                            exp: card.exp || 0
                        }));
                        setNegozioCards(mappedNegozioCards);
                        console.log("Supabase: Fetched Negozio cards:", mappedNegozioCards.length);


                        console.log("Supabase: Cards fetched successfully.");
                    } catch (err) {
                        console.error("Supabase: Error fetching cards:", err.message);
                        setDbError(err.message);
                        setPokemonDbCards(localPokemonCardsDatabase); // Fallback to local data for Pokémon cards on error
                        setTrainersDbCards([]); // No local fallback for trainer cards by default
                        setPalestreDbCards([]); // No local fallback for palestre cards by default
                        setNegozioCards([]); // No local fallback for negozio cards by default
                    } finally {
                        setIsDbLoading(false);
                    }
                }

                getSupabaseCards();
            }, []); // Empty dependency array means this effect runs only once after the initial render


            // State for global currency counter
            const [globalCurrency, setGlobalCurrency] = React.useState(() => {
                const savedCurrency = localStorage.getItem('globalCurrency');
                return savedCurrency ? parseInt(savedCurrency) : 0;
            });

            // State for global medals (Gyms)
            const [gymMedals, setGymMedals] = React.useState(() => {
                const savedMedals = localStorage.getItem('gymMedals');
                // Initialize with 8 elements, all false by default
                return savedMedals ? JSON.parse(savedMedals) : Array(8).fill(false); 
            });

            // State for Elite Four medals
            const [eliteFourMedals, setEliteFourMedals] = React.useState(() => {
                const savedEliteFourMedals = localStorage.getItem('eliteFourMedals');
                // Initialize with 4 elements, all false by default
                return savedEliteFourMedals ? JSON.parse(savedEliteFourMedals) : Array(4).fill(false);
            });

            // State for turn indicator
            const [isMyTurn, setIsMyTurn] = React.useState(() => {
                const savedTurnState = localStorage.getItem('isMyTurn');
                return savedTurnState ? JSON.parse(savedTurnState) : false; // Default: not your turn
            });

            // State for coin flip banner (for both asleep and confused)
            const [showCoinFlipBanner, setShowCoinFlipBanner] = React.useState(false);
            const [coinFlipResult, setCoinFlipResult] = React.useState('');
            const [coinFlipType, setCoinFlipType] = React.useState(''); // 'turn' or 'confusion'

            // New state for ATTACK dice roll results
            const [attackDiceResults, setAttackDiceResults] = React.useState([]);
            // New state for RETREAT dice roll results
            const [retreatDiceResults, setRetreatDiceResults] = React.useState([]);
            // State for movement die (removed from UI, but state can remain if needed for other logic)
            const [movementDiceResult, setMovementDiceResult] = React.useState(null);
            const [showMovementDiceBanner, setShowMovementDiceBanner] = React.useState(false);

            // State for the large dice banner (Attack/Retreat/Capture initial roll)
            const [showGlobalDiceBanner, setShowGlobalDiceBanner] = React.useState(false);
            const [globalDiceBannerResults, setGlobalDiceBannerResults] = React.useState([]);

            // Effect to save cards to localStorage whenever they change
            React.useEffect(() => {
                localStorage.setItem('gameCards', JSON.stringify(cards));
            }, [cards]);

            // Effect to save boxCards to localStorage whenever they change
            React.useEffect(() => {
                localStorage.setItem('pokemonBoxCards', JSON.stringify(boxCards));
            }, [boxCards]);

            // Effect to save global currency to localStorage whenever it changes
            React.useEffect(() => {
                localStorage.setItem('globalCurrency', globalCurrency.toString());
            }, [globalCurrency]);

            // Effect to save Gym medals to localStorage whenever they change
            React.useEffect(() => {
                localStorage.setItem('gymMedals', JSON.stringify(gymMedals));
            }, [gymMedals]);

            // Effect to save Elite Four medals to localStorage whenever they change
            React.useEffect(() => {
                localStorage.setItem('eliteFourMedals', JSON.stringify(eliteFourMedals));
            }, [eliteFourMedals]);

            // Effect to save turn state to localStorage
            React.useEffect(() => {
                localStorage.setItem('isMyTurn', JSON.stringify(isMyTurn));
            }, [isMyTurn]);


            /**
             * Updates the card data in a specific slot.
             * @param {number} index - The index of the card slot (0-5).
             * @param {object | null} cardData - The new card data or null to clear the slot.
             */
            const updateCardInSlot = React.useCallback((index, cardData) => {
                setCards(prevCards => {
                    const newCards = [...prevCards];
                    newCards[index] = cardData;
                    return newCards;
                });
            }, []); // No dependencies, as it sets state based on previous state

            /**
             * Handles toggling the "active" status for a Pokémon.
             * Ensures that only one Pokémon is active at a time.
             * @param {number} clickedSlotIndex - The index of the clicked slot.
             */
            const handleActivePokemonToggle = React.useCallback((clickedSlotIndex) => {
                // Determine the currently active card for status checks BEFORE state update
                const currentActiveCard = cards.find(card => card && card.isActivePokemon);
                
                // If there's an active card and it's Paralizzato and it's My Turn, prevent switching
                if (isMyTurn && currentActiveCard && currentActiveCard.statuses[3]) { // statuses[3] is Paralizzato
                    console.log("Cannot change active Pokémon while current active is Paralizzato on your turn.");
                    return; // Block the action
                }

                setCards(prevCards => {
                    return prevCards.map((card, idx) => {
                        if (!card) return null; // Skip if slot is empty

                        const isClickedCard = (idx === clickedSlotIndex);
                        let newIsActive = card.isActivePokemon;
                        let newStatuses = [...card.statuses];

                        if (isClickedCard) {
                            newIsActive = !card.isActivePokemon; // Toggle the clicked card
                            // If the clicked card is becoming INACTIVE, reset its statuses
                            if (!newIsActive) {
                                newStatuses = Array(5).fill(false);
                            }
                        } else if (card.isActivePokemon) {
                            // If another card was active, deactivate it and reset its statuses
                            newIsActive = false;
                            newStatuses = Array(5).fill(false);
                        }

                        return {
                            ...card,
                            isActivePokemon: newIsActive,
                            statuses: newStatuses
                        };
                    });
                });
            }, [isMyTurn, cards]); // Added cards to dependencies for activeCard check


            // Handles manual change of global currency input
            const handleGlobalCurrencyChange = (event) => {
                const value = parseInt(event.target.value) || 0;
                setGlobalCurrency(value);
            };

            // Handles incrementing/decrementing global currency
            const adjustGlobalCurrency = (amount) => {
                setGlobalCurrency(prevCurrency => Math.max(0, prevCurrency + amount));
            };

            // Toggles the state of a Gym medal
            const toggleGymMedal = (index) => {
                setGymMedals(prevMedals => {
                    const newMedals = [...prevMedals];
                    newMedals[index] = !newMedals[index];
                    return newMedals;
                });
            };

            // Toggles the state of an Elite Four medal
            const toggleEliteFourMedal = (index) => {
                setEliteFourMedals(prevMedals => {
                    const newMedals = [...prevMedals];
                    newMedals[index] = !newMedals[index];
                    return newMedals;
                });
            };

            // Determines if dice roll should be disabled (if active Pokémon is asleep or paralyzed)
            const activeCardForDice = cards.find(card => card && card.isActivePokemon); // Use a new const to avoid confusion with activeCard in toggleMyTurn
            const getDiceRollDisableStatus = () => {
                if (!activeCardForDice) return false;
                if (activeCardForDice.statuses[0]) return 'asleep'; // Asleep
                if (activeCardForDice.statuses[2]) return 'confused'; // Confused
                if (activeCardForDice.statuses[3]) return 'paralyzed'; // Paralizzato - NEW
                return false;
            };
            const diceRollDisableStatus = getDiceRollDisableStatus();

            // Function to handle coin flip for "Confused" status
            const handleConfusedRollAttempt = React.useCallback(async () => {
                // Perform coin flip
                const result = Math.random() < 0.5 ? 'Testa' : 'Croce';
                setCoinFlipResult(result);
                setCoinFlipType('confusion'); // Indicate it's a confusion flip
                setShowCoinFlipBanner(true);

                // Hide banner after 3 seconds
                setTimeout(() => {
                    setShowCoinFlipBanner(false);
                    setCoinFlipType('');
                }, 3000);

                if (result === 'Croce') {
                    // Inflict 30 damage if Croce
                    setCards(prevCards => {
                        return prevCards.map((card, idx) => {
                            if (card && card.isActivePokemon) {
                                const newDamageTaken = card.damageTaken + 30;
                                return { ...card, damageTaken: newDamageTaken };
                            }
                            return card;
                        });
                    });
                    return false; // Do not proceed with dice roll
                }
                return true; // Proceed with dice roll
            }, [activeCardForDice, cards]); // Dependencies: activeCardForDice, cards for setCards


            // Toggles turn state AND handles status conditions
            const toggleMyTurn = React.useCallback(() => { // Made useCallback
                setIsMyTurn(prevIsMyTurn => {
                    const newTurnState = !prevIsMyTurn;
                    const currentActiveCardInTurn = cards.find(card => card && card.isActivePokemon); // Get active card at the moment of turn toggle

                    // Logic for "Paralyzed" status when turn passes to opponent - NEW
                    if (!newTurnState && currentActiveCardInTurn && currentActiveCardInTurn.statuses[3]) { // If it becomes opponent's turn AND active Pokémon is Paralizzato
                        setCards(prevCards => {
                            return prevCards.map((card, idx) => {
                                if (card && card.isActivePokemon && idx === cards.indexOf(currentActiveCardInTurn)) { // Ensure we modify the *correct* active card
                                    const newStatuses = [...card.statuses];
                                    newStatuses[3] = false; // Deselect Paralizzato
                                    return { ...card, statuses: newStatuses };
                                }
                                return card;
                            });
                        });
                    }

                    // Coin flip logic for "Asleep" status
                    // Coin is flipped only if there is an active Pokémon AND if it is Asleep
                    if (currentActiveCardInTurn && currentActiveCardInTurn.statuses[0]) { 
                        const result = Math.random() < 0.5 ? 'Testa' : 'Croce';
                        setCoinFlipResult(result);
                        setCoinFlipType('turn'); // Indicate it's a turn flip
                        setShowCoinFlipBanner(true);

                        // Hide banner after 3 seconds
                        setTimeout(() => {
                            setShowCoinFlipBanner(false);
                            setCoinFlipType('');
                        }, 3000);

                        // Apply coin flip effect to active "Asleep" Pokémon
                        if (result === 'Testa') {
                            setCards(prevCards => {
                                return prevCards.map((card, idx) => {
                                    if (card && card.isActivePokemon && idx === cards.indexOf(currentActiveCardInTurn)) { // Find the active Pokémon
                                        const newStatuses = [...card.statuses];
                                        newStatuses[0] = false; // Deselect Asleep (wakes up)
                                        return { ...card, statuses: newStatuses };
                                    }
                                    return card;
                                });
                            });
                        }
                        // If 'Croce' comes up, the Asleep Pokémon remains Asleep, so we do nothing here.
                    } else {
                        // If there is no active asleep Pokémon, ensure the coin banner is hidden
                        setShowCoinFlipBanner(false);
                        setCoinFlipType('');
                    }

                    // Burn damage logic (only when it becomes your turn)
                    if (newTurnState && currentActiveCardInTurn && currentActiveCardInTurn.statuses[1]) { // If it becomes your turn AND active Pokémon is Burned (index 1)
                        setCards(prevCards => {
                            return prevCards.map((card, idx) => {
                                if (card && card.isActivePokemon && idx === cards.indexOf(currentActiveCardInTurn)) {
                                    const newDamageTaken = card.damageTaken + 20;
                                    return { ...card, damageTaken: newDamageTaken };
                                }
                                return card;
                            });
                        });
                    }

                    // Poison damage logic (only when it becomes your turn)
                    if (newTurnState && currentActiveCardInTurn && currentActiveCardInTurn.statuses[4]) { // If it becomes your turn AND active Pokémon is Poisoned (index 4)
                        setCards(prevCards => {
                            return prevCards.map((card, idx) => {
                                if (card && card.isActivePokemon && idx === cards.indexOf(currentActiveCardInTurn)) {
                                    const newDamageTaken = card.damageTaken + 10; // 10 damage for poison
                                    return { ...card, damageTaken: newDamageTaken };
                                }
                                return card;
                            });
                        });
                    }

                    // Clear dice roll results when it becomes MY turn
                    if (newTurnState) { // If it's becoming MY turn
                        setAttackDiceResults([]); // Clear results for Attack dice
                        // Not clearing retreatDiceResults here, as per previous instruction to keep them visible during opponent's turn.
                    } else { // If it's becoming OPPONENT's turn, clear retreat dice
                        setRetreatDiceResults([]);
                    }

                    return newTurnState;
                });
            }, [cards, activeCardForDice, setAttackDiceResults, setRetreatDiceResults]);

            // Function to handle movement die roll (kept for completeness, but not used in UI)
            const handleRollMovementDice = React.useCallback(() => {
                const roll = Math.floor(Math.random() * 6) + 1;
                setMovementDiceResult(roll);
                setShowMovementDiceBanner(true);

                setTimeout(() => {
                    setShowMovementDiceBanner(false);
                    setMovementDiceResult(null);
                }, 5000); // 5 seconds
            }, []);

            // Function to handle displaying the large dice banner (Attack/Retreat initial roll)
            const handleDisplayDiceBanner = React.useCallback((results) => {
                setGlobalDiceBannerResults(results);
                setShowGlobalDiceBanner(true);
                setTimeout(() => {
                    setShowGlobalDiceBanner(false);
                    setGlobalDiceBannerResults([]);
                }, 3000); // Banner visible for 3 seconds
            }, []);

            // Function to send a card from a slot to the box
            const sendCardToBox = React.useCallback((cardToBox, slotIndex) => {
                setBoxCards(prevBoxCards => [...prevBoxCards, cardToBox]);
                updateCardInSlot(slotIndex, null); // Clear the slot after sending to box
            }, [updateCardInSlot]);

            // Function to recall a card from the box and place it into a slot
            // Modified to also handle deletion from BoxView/RecallFromBoxModal
            const recallCardFromBox = React.useCallback((selectedCard, targetSlotIndex, boxCardIndex, isDeleteOnly = false) => {
                if (isDeleteOnly) {
                    setBoxCards(prevBoxCards => {
                        const newBoxCards = [...prevBoxCards];
                        newBoxCards.splice(boxCardIndex, 1); // Remove the card by its index
                        return newBoxCards;
                    });
                } else {
                    // 1. Place the selected card into the target slot
                    updateCardInSlot(targetSlotIndex, {
                        imageUrl: selectedCard.imageUrl,
                        baseHp: selectedCard.baseHp,
                        damageTaken: 0, // Reset damage when recalling from box
                        statuses: Array(5).fill(false), // Reset statuses when recalling from box
                        exp: selectedCard.exp, // Keep exp from the recalled card
                        isActivePokemon: false // Not active by default when recalled
                    });

                    // 2. Remove the card from the box
                    setBoxCards(prevBoxCards => {
                        const newBoxCards = [...prevBoxCards];
                        newBoxCards.splice(boxCardIndex, 1); // Remove the card by its index
                        return newBoxCards;
                    });
                }
            }, [updateCardInSlot, setBoxCards]);

            // Function to delete a card directly from the box (used by BoxView)
            const deleteCardFromBox = React.useCallback((indexToDelete) => {
                setBoxCards(prevBoxCards => {
                    return prevBoxCards.filter((_, i) => i !== indexToDelete);
                });
            }, []);

            // NEW: Function to fetch a random card from a specified Supabase table
            const fetchRandomCardFromTable = React.useCallback(async (tableName) => {
                try {
                    // Get the total count of rows in the table
                    const { count, error: countError } = await supabase
                        .from(tableName)
                        .select('*', { count: 'exact', head: true });

                    if (countError) {
                        throw countError;
                    }

                    if (count === 0) {
                        throw new Error(`La tabella '${tableName}' è vuota.`);
                    }

                    // Generate a random index
                    const randomIndex = Math.floor(Math.random() * count);

                    // Fetch one row at the random index
                    const { data, error: fetchError } = await supabase
                        .from(tableName)
                        .select('*')
                        .range(randomIndex, randomIndex + 1); // Fetch just one record

                    if (fetchError) {
                        throw fetchError;
                    }

                    if (data && data.length > 0) {
                        const randomCard = data[0];
                        // Map Supabase data to the expected card format
                        return {
                            id: randomCard.id,
                            name: randomCard.name || randomCard.card_name || 'Carta Casuale', // Handle different column names
                            imageUrl: randomCard.image_url,
                            baseHp: randomCard.base_hp || 0, // Default to 0 if not present (e.g., for trainer cards)
                            exp: randomCard.exp || 0, // Default to 0 if not present
                            damageTaken: 0,
                            statuses: Array(5).fill(false),
                            isActivePokemon: false
                        };
                    } else {
                        throw new Error("Nessuna carta trovata all'indice casuale.");
                    }
                } catch (error) {
                    console.error("Errore durante il recupero della carta casuale dalla tabella:", error);
                    throw error; // Re-throw to be caught by the calling component
                }
            }, []);

            // NEW: Function to handle Palestre card selection and load corresponding trainer cards
            const handlePalestreCardSelection = React.useCallback(async (palestreCard) => {
                console.log("Palestra card selected:", palestreCard.name);
                const trainerNameBase = palestreCard.name; // e.g., "Brock"
                // Assuming trainer cards related to a Gym are named like "GymLeaderName-1" and "GymLeaderName-2"
                // For example, if palestreCard.name is "Brock", it will look for "Brock-1" and "Brock-2"
                const trainer1Name = trainerNameBase + "-1";
                const trainer2Name = trainerNameBase + "-2";

                console.log("Looking for trainer cards:", trainer1Name, "and", trainer2Name);
                console.log("All Trainers DB Cards (from pokemon_allenatori):", trainersDbCards); // Log all trainer cards for inspection

                const trainerCard1 = trainersDbCards.find(card => card.name === trainer1Name);
                const trainerCard2 = trainersDbCards.find(card => card.name === trainer2Name);

                // Apply card 1 to slot 0
                if (trainerCard1) {
                    console.log("Found trainer card 1:", trainerCard1.name);
                    updateCardInSlot(0, {
                        imageUrl: trainerCard1.imageUrl,
                        baseHp: 0, // Trainer cards usually have 0 HP
                        damageTaken: 0,
                        statuses: Array(5).fill(false),
                        exp: 0, // Trainer cards usually have 0 EXP
                        isActivePokemon: false
                    });
                } else {
                    console.warn(`Carta allenatore ${trainer1Name} non trovata. Impossibile caricare nel primo slot.`);
                    updateCardInSlot(0, null); // Clear slot if not found
                    // Ideally, show a user-facing notification here.
                }

                // Apply card 2 to slot 1
                if (trainerCard2) {
                    console.log("Found trainer card 2:", trainerCard2.name);
                    updateCardInSlot(1, {
                        imageUrl: trainerCard2.imageUrl,
                        baseHp: 0, // Trainer cards usually have 0 HP
                        damageTaken: 0,
                        statuses: Array(5).fill(false),
                        exp: 0, // Trainer cards usually have 0 EXP
                        isActivePokemon: false
                    });
                } else {
                    console.warn(`Carta allenatore ${trainer2Name} non trovata. Impossibile caricare nel secondo slot.`);
                    updateCardInSlot(1, null); // Clear slot if not found
                    // Ideally, show a user-facing notification here.
                }
            }, [trainersDbCards, updateCardInSlot]); // Dependencies: trainersDbCards, updateCardInSlot


            return (
                <>
                    {currentView === 'main' && (
                        <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-green-600 to-blue-700 p-4 relative">
                            {/* Top Controls: All stacked vertically for narrow screens */}
                            <div className="w-full max-w-xs flex flex-col items-center p-4 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 z-10 mb-4">
                                {/* Turn Indicator */}
                                <TurnIndicator isMyTurn={isMyTurn} onToggleTurn={toggleMyTurn} />

                                {/* Container for ATTACK, RETREAT dice (now vertical) */}
                                <div className="flex flex-col items-center gap-4 w-full">
                                    {/* Roll ATTACK Dice */}
                                    <DiceRoller
                                        title="ATTACCA"
                                        isAttackRoller={true}
                                        isDiceRollDisabled={diceRollDisableStatus}
                                        onConfusedRollAttempt={handleConfusedRollAttempt}
                                        isMyTurn={isMyTurn}
                                        onDiceRollComplete={toggleMyTurn}
                                        results={attackDiceResults}
                                        onSetResults={setAttackDiceResults}
                                        onDisplayResultsForBanner={handleDisplayDiceBanner}
                                    />
                                    {/* Roll RETREAT Dice */}
                                    <DiceRoller
                                        title="RITIRATA"
                                        isAttackRoller={false}
                                        results={retreatDiceResults}
                                        onSetResults={setRetreatDiceResults}
                                        onDisplayResultsForBanner={handleDisplayDiceBanner}
                                        onDiceRollComplete={toggleMyTurn} /* Added for Retreat to end turn */
                                        isMyTurn={isMyTurn} /* Pass isMyTurn to DiceRoller */
                                    />
                                </div>
                                
                                {/* Movement Die - Removed */}
                                {/* <MovementDiceRoller onRoll={handleRollMovementDice} /> */}

                                {/* Button to go to Box */}
                                <button
                                    onClick={() => setCurrentView('box')}
                                    className="btn-theme btn-purple px-6 py-3 text-lg mt-4" /* Added mt-4 for spacing */
                                >
                                    VAI AL BOX ({boxCards.length})
                                </button>

                                {/* NEW: Button to go to Negozio (replaces Backpack) */}
                                <button
                                    onClick={() => setCurrentView('negozio')}
                                    className="btn-theme btn-orange px-6 py-3 text-lg mt-4" /* Added mt-4 for spacing */
                                >
                                    NEGOZIO
                                </button>

                                {/* Coin flip banner (for turn or confusion) */}
                                {showCoinFlipBanner && (
                                    <div className={`fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-400 text-gray-800 px-4 py-2 rounded-lg font-bold text-lg shadow-xl border-2 border-yellow-700 z-20 ${coinFlipType === 'confusion' ? 'animate-fade-in-out-confusion' : 'animate-fade-in-out-coin'}`}>
                                        {coinFlipType === 'confusion' ? `Confusione: ${coinFlipResult}! ${coinFlipType === 'confusion' && coinFlipResult === 'Testa' ? '🪙' : '❌'}` : `${coinFlipResult}! 🪙`}
                                    </div>
                                )}
                            </div>

                            {/* Large banner for Movement die (removed from UI, but banner state can remain) */}
                            {showMovementDiceBanner && movementDiceResult && (
                                <div className="fixed inset-0 flex justify-center items-center bg-gray-900 bg-opacity-90 z-40">
                                    <div className="p-8 rounded-xl shadow-2xl bg-gray-700 border-4 border-yellow-400 text-white text-8xl font-extrabold animate-fade-in-out-movement-dice">
                                        {diceFaces[movementDiceResult]}
                                    </div>
                                </div>
                            )}

                            {/* Large banner for ATTACK/RETREAT initial dice roll */}
                            {showGlobalDiceBanner && globalDiceBannerResults.length > 0 && (
                                <div className="fixed inset-0 flex justify-center items-center bg-gray-900 bg-opacity-90 z-40">
                                    <div className="p-8 rounded-xl shadow-2xl bg-gray-700 border-4 border-yellow-400 text-white text-8xl font-extrabold animate-fade-in-out-dice-roll flex gap-4 justify-center flex-wrap">
                                        {globalDiceBannerResults.map((result, index) => (
                                            <span key={index}>{diceFaces[result]}</span>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {/* Contenitore per gli slot delle carte */}
                            {/* Sempre una colonna per schermi verticali */}
                            <div className="grid grid-cols-1 gap-8 w-full max-w-xs mt-8 pb-8"> 
                                {cards.map((cardData, index) => (
                                    <CardSlot
                                        key={index} 
                                        slotIndex={index}
                                        cardData={cardData} 
                                        onUpdateCard={updateCardInSlot}
                                        onToggleActivePokemon={handleActivePokemonToggle} 
                                        isMyTurn={isMyTurn} 
                                        activeCardParalyzed={isMyTurn && activeCardForDice && activeCardForDice.statuses[3]}
                                        onSendToBox={sendCardToBox} /* Pass the new function */
                                        onRecallFromBox={recallCardFromBox} /* Pass the new recall function */
                                        boxCards={boxCards} /* Pass boxCards for the recall modal */
                                        pokemonDbCards={pokemonDbCards} /* Passed Pokémon cards here */
                                        trainersDbCards={trainersDbCards} /* Passed trainers cards here */
                                        palestreDbCards={palestreDbCards} /* NEW: Passed palestre cards here */
                                        isDbLoading={isDbLoading} /* Passed from App to CardSlot */
                                        dbError={dbError} /* Passed from App to CardSlot */
                                        onSelectTableAndFetchRandom={fetchRandomCardFromTable} /* New prop for random fetch */
                                        onSelectPalestreCard={handlePalestreCardSelection} /* NEW: Pass the new function for Palestre cards */
                                    />
                                ))}
                            </div>
                        </div>
                    )}

                    {currentView === 'box' && (
                        <BoxView 
                            boxCards={boxCards} 
                            onBackToMain={() => setCurrentView('main')} 
                            onDeleteCardFromBox={deleteCardFromBox} /* Pass the new delete function */
                        />
                    )}

                    {currentView === 'negozio' && (
                        <NegozioView
                            negozioCards={negozioCards}
                            onBackToMain={() => setCurrentView('main')}
                            isDbLoading={isDbLoading}
                            dbError={dbError}
                        />
                    )}
                </>
            );
        }

        // Renderizza il componente App di React nell'elemento 'root'
        window.onload = function() {
            ReactDOM.createRoot(document.getElementById('root')).render(<App />);
        };
    </script>
</body>
</html>
