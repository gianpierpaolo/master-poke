<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaccia Gioco di Carte Pokémon</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background: linear-gradient(to bottom right, #4CAF50, #2E7D32); /* Sfondo a tema Pokémon */
            color: #E0E0E0;
        }
        .camera-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .camera-modal-content {
            background-color: #333;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        .camera-video-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            padding-top: calc(4 / 3 * 100%);
            height: 0;
            overflow: hidden;
            background-color: black;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        .capture-frame-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 192px;
            height: 256px;
            border: 3px dashed rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        .camera-canvas {
            display: none;
        }
        .btn-theme {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease-in-out;
            border: 2px solid;
            background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
        }
        .btn-theme:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .btn-theme:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .btn-red {
            --tw-gradient-stops: #EF4444, #DC2626;
            border-color: #B91C1C;
            color: white;
        }
        .btn-green {
            --tw-gradient-stops: #22C55E, #16A34A;
            border-color: #15803D;
            color: white;
        }
        .btn-blue {
            --tw-gradient-stops: #3B82F6, #2563EB;
            border-color: #1D4ED8;
            color: white;
        }
        .btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA;
            border-color: #7E22CE;
            color: white;
        }
        .btn-yellow {
            --tw-gradient-stops: #FACC15, #EAB308;
            border-color: #CA8A04;
            color: #333;
        }
        .btn-orange {
            --tw-gradient-stops: #F97316, #EA580C;
            border-color: #C2410C;
            color: white;
        }
        .btn-gray {
            --tw-gradient-stops: #6B7280, #4B5563;
            border-color: #374151;
            color: white;
        }
        .btn-cyan {
            --tw-gradient-stops: #22D3EE, #06B6D4;
            border-color: #0891B2;
            color: white;
        }
        .counter-label {
            font-size: 1.125rem;
            font-weight: 600;
            color: #F0F0F0;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
        }
        .counter-value {
            font-size: 1.5rem;
            font-weight: 800;
            text-shadow: 2px 2px 3px rgba(0,0,0,0.5);
        }
        .icon-btn {
            @apply flex items-center justify-center w-12 h-12 rounded-full text-2xl shadow-md transition-all duration-200 ease-in-out border-2;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
        }
        .icon-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
        }
        .icon-btn:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .icon-btn.btn-blue {
             --tw-gradient-stops: #3B82F6, #2563EB;
            border-color: #1D4ED8;
            color: white;
        }
        .icon-btn.btn-purple {
            --tw-gradient-stops: #A855F7, #9333EA;
            border-color: #7E22CE;
            color: white;
        }
        .medal-icon {
            @apply w-24 h-24 rounded-full flex items-center justify-center text-7xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md;
        }
        .medal-icon.active {
            @apply scale-110 ring-4 ring-offset-2 ring-offset-green-700;
        }
        .elite-four-icon {
            @apply w-24 h-24 rounded-full flex items-center justify-center text-7xl cursor-pointer transition-all duration-200 ease-in-out border-2 border-gray-600 shadow-md;
            background: linear-gradient(to bottom, #4A5568, #2D3748);
            color: #CBD5E0;
        }
        .elite-four-icon.active {
            @apply scale-110 ring-4 ring-offset-2 ring-offset-yellow-400;
            background: linear-gradient(to bottom, #FACC15, #EAB308);
            color: #333;
        }
        .hm-icon {
            @apply w-28 h-28 rounded-full flex items-center justify-center text-7xl transition-all duration-300 ease-in-out border-2 border-gray-600 shadow-lg;
            background: linear-gradient(to bottom, #4A5568, #2D3748);
            color: #A0AEC0;
        }
        .hm-icon.active {
            @apply scale-110 ring-4 ring-offset-2 ring-offset-gray-800;
        }
        .hm-icon.fly-active {
            background: linear-gradient(to bottom, #60A5FA, #3B82F6);
            border-color: #1D4ED8;
            color: white;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
        }
        .hm-icon.surf-active {
            background: linear-gradient(to bottom, #38BDF8, #0EA5E9);
            border-color: #0284C7;
            color: white;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
        }
        input[type='number']::-webkit-inner-spin-button,
        input[type='number']::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type='number'] {
            -moz-appearance: textfield;
        }
        @keyframes fadeInOutCoin {
            0% { opacity: 0; transform: translateY(-50%) translateX(20px); }
            10% { opacity: 1; transform: translateY(-50%) translateX(0); }
            90% { opacity: 1; transform: translateY(-50%) translateX(0); }
            100% { opacity: 0; transform: translateY(-50%) translateX(20px); }
        }
        .animate-fade-in-out-coin {
            animation: fadeInOutCoin 3s ease-in-out forwards;
        }
        @keyframes fadeInOutConfusion {
            0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
            10% { opacity: 1; transform: translateY(-50%) scale(1); }
            90% { opacity: 1; transform: translateY(-50%) scale(1); }
            100% { opacity: 0; transform: translateY(-50%) scale(0.8); }
        }
        .animate-fade-in-out-confusion {
            animation: fadeInOutConfusion 3s ease-in-out forwards;
        }
        @keyframes fadeInOutMovementDice {
            0% { opacity: 0; transform: scale(0.5); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        .animate-fade-in-out-movement-dice {
            animation: fadeInOutMovementDice 5s ease-out forwards;
        }
        .exp-dot {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background-color: #4B5563;
            border: 2px solid #374151;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-out;
        }
        .exp-dot.active-yellow {
            background-color: #FACC15;
            border-color: #EAB308;
            transform: scale(1.1);
        }
        .exp-dot.active-blue {
            background-color: #3B82F6;
            border-color: #2563EB;
            transform: scale(1.1);
        }
        .exp-dot.active-pink {
            background-color: #EC4899;
            border-color: #BE185D;
            transform: scale(1.1);
        }
        .exp-dot.active-green-total {
            background-color: #22C55E;
            border-color: #15803D;
            transform: scale(1.1);
        }
        .exp-dot.active-blue-total {
            background-color: #3B82F6;
            border-color: #1D4ED8;
            transform: scale(1.1);
        }
        .exp-dot.active-yellow-total {
            background-color: #FACC15;
            border-color: #CA8A04;
            transform: scale(1.1);
        }
        .exp-dot.active-red-total {
            background-color: #EF4444;
            border-color: #B91C1C;
            transform: scale(1.1);
        }
        @keyframes fadeInOutDiceRoll {
            0% { opacity: 0; transform: scale(0.7); }
            10% { opacity: 1; transform: scale(1); }
            90% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.7); }
        }
        .animate-fade-in-out-dice-roll {
            animation: fadeInOutDiceRoll 3s ease-out forwards;
        }
        .capture-coin-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .capture-coin-modal-content {
            background-color: #333;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            border: 4px solid #FACC15;
        }
        .capture-coin-modal-content h2 {
            font-size: 2.5rem;
            font-weight: 800;
            color: #FACC15;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .capture-coin-modal-content button {
            padding: 1rem 2.5rem;
            border-radius: 9999px;
            font-size: 1.5rem;
            font-weight: 700;
            background-image: linear-gradient(to bottom, #3B82F6, #2563EB);
            border: 2px solid #1D4ED8;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease-in-out;
        }
        .capture-coin-modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.4);
        }
        .capture-coin-modal-content button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .capture-coin-result {
            font-size: 4rem;
            font-weight: 900;
            margin-top: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6);
        }
        .capture-coin-result.success {
            color: #22C55E;
        }
        .capture-coin-result.fail {
            color: #EF4444;
        }
        .zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .zoom-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .zoom-modal-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }
        .zoom-modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease-in-out;
        }
        .zoom-modal-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <!-- React, ReactDOM, and Babel for JSX transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
     <!-- Supabase Client Library CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>


   <script type="text/babel">
        // Credenziali Supabase
        const SUPABASE_URL = 'https://wcarhpvygqbjekacizlb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjYXJocHZ5Z3FiamVrYWNpemxiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ0OTAzMTYsImV4cCI6MjA3MDA2NjMxNn0.xc7_wXB16kaAVOdcucP_7zzvUQ8f2S6IYKBjIs0ffEU';


        // Inizializza il client Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);


        if (SUPABASE_ANON_KEY === 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndjYXJocHZ5Z3FiamVrYWNpembiLCJyb2xlIjoiYW5vbiIsImiaWF0IjoxNzU0NDkwMzE2LCJleHAiOjIwNzAwNjYzMTZ9.xc7_wXB16kaAVOdcucP_7zzvUQ8f2S6IYKBjIs0ffEU') {
            console.warn("ATTENZIONE: Stai utilizzando una chiave API Supabase di esempio. Sostituiscila con la tua vera chiave 'anon (Public)' per connetterti al tuo database.");
        }


        // Mapping dei numeri ai simboli dei dadi
        const diceFaces = {
            1: '⚀', 2: '⚁', 3: '⚂', 4: '⚃', 5: '⚄', 6: '⚅',
        };


        // Database locale di fallback
        const localPokemonCardsDatabase = [
            { id: 'db-local-001', name: 'Pikachu', imageUrl: 'https://placehold.co/192x256/FFD700/000000?text=Pikachu', baseHp: 60, exp: 0 },
            { id: 'db-local-002', name: 'Charmander', imageUrl: 'https://placehold.co/192x256/FF4500/FFFFFF?text=Charmander', baseHp: 50, exp: 0 },
            { id: 'db-local-003', name: 'Squirtle', imageUrl: 'https://placehold.co/192x256/1E90FF/FFFFFF?text=Squirtle', baseHp: 60, exp: 0 },
            { id: 'db-local-004', name: 'Bulbasaur', imageUrl: 'https://placehold.co/192x256/7CFC00/000000?text=Bulbasaur', baseHp: 70, exp: 0 },
        ];


        // Componente CameraModal
        function CameraModal({ isOpen, onClose, onCapture }) {
            const videoRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const [currentStream, setCurrentStream] = React.useState(null);
            const [error, setError] = React.useState(null);
            const [availableCameras, setAvailableCameras] = React.useState([]);
            const [selectedCameraId, setSelectedCameraId] = React.useState('');
            const [cameraStatusMessage, setCameraStatusMessage] = React.useState("Inizializzazione fotocamera...");
            const [isFrontCamera, setIsFrontCamera] = React.useState(false);


            const stopCurrentStream = React.useCallback((s) => {
                if (s) {
                    s.getTracks().forEach(track => track.stop());
                }
                setCurrentStream(null);
                if (videoRef.current) {
                    videoRef.current.srcObject = null;
                }
            }, []);


            const startCamera = React.useCallback(async (deviceIdToUse, facingMode = 'environment', fallback = false) => {
                setCameraStatusMessage("Avvio fotocamera...");
                setError(null);


                if (currentStream) {
                    stopCurrentStream(currentStream);
                }
                setCurrentStream(null);


                try {
                    const constraints = {
                        video: deviceIdToUse ? { deviceId: { exact: deviceIdToUse } } : { facingMode: facingMode }
                    };
                    const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    if (videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                        videoRef.current.onloadedmetadata = () => {
                            setCameraStatusMessage("Attendere il video...");
                            videoRef.current.play().then(() => {
                                setCameraStatusMessage("");
                            }).catch(playErr => {
                                setError("Errore nella riproduzione del video della fotocamera.");
                                setCameraStatusMessage("Errore riproduzione video.");
                            });
                        };
                        if (videoRef.current.readyState >= 2) {
                             videoRef.current.play().catch(playErr => console.error("Error playing video:", playErr));
                        }
                    }
                    setCurrentStream(mediaStream);


                    const videoTrack = mediaStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    setIsFrontCamera(settings.facingMode === 'user');


                } catch (err) {
                    setCameraStatusMessage("Errore nell'accesso alla fotocamera.");
                    if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") {
                        setError("Accesso alla fotocamera negato. Controlla i permessi del browser.");
                    } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                        if (!fallback && availableCameras.length > 0) { 
                            startCamera(availableCameras[0].deviceId, 'environment', true);
                            return; 
                        }
                        setError("Nessuna fotocamera disponibile.");
                    } else {
                        setError("Impossibile accedere alla fotocamera: " + err.message);
                    }
                    stopCurrentStream(null);
                }
            }, [stopCurrentStream, currentStream, availableCameras]); 


            React.useEffect(() => {
                if (!isOpen) {
                    stopCurrentStream(currentStream);
                    setAvailableCameras([]);
                    setSelectedCameraId('');
                    setError(null);
                    setCameraStatusMessage("Inizializzazione fotocamera...");
                    return;
                }


                const setupDevicesAndStartInitialCamera = async () => {
                    setCameraStatusMessage("Ricerca fotocamere...");
                    try {
                        const devices = await navigator.mediaDevices.enumerateDevices();
                        const videoInputs = devices.filter(device => device.kind === 'videoinput');
                        setAvailableCameras(videoInputs);


                        if (videoInputs.length === 0) {
                            setError("Nessuna fotocamera trovata.");
                            setCameraStatusMessage("Nessuna fotocamera trovata.");
                            return;
                        }


                        let targetDeviceId = selectedCameraId; 
                        let targetFacingMode = 'environment';
                        if (!targetDeviceId || !videoInputs.some(device => device.deviceId === targetDeviceId)) { 
                            const rearCamera = videoInputs.find(d => d.label.toLowerCase().includes('back'));
                            targetDeviceId = rearCamera ? rearCamera.deviceId : videoInputs[0].deviceId; 
                            targetFacingMode = rearCamera ? 'environment' : 'user';
                        } else {
                            const selectedCamera = videoInputs.find(d => d.deviceId === targetDeviceId);
                            if (selectedCamera) {
                                targetFacingMode = selectedCamera.label.toLowerCase().includes('front') ? 'user' : 'environment';
                            }
                        }
                        
                        setSelectedCameraId(targetDeviceId); 
                        startCamera(targetDeviceId, targetFacingMode); 


                    } catch (err) { 
                        setError("Impossibile enumerare o avviare la fotocamera.");
                        setCameraStatusMessage("Errore configurazione fotocamera.");
                    }
                };


                setupDevicesAndStartInitialCamera();


                return () => {
                    stopCurrentStream(currentStream);
                };
            }, [isOpen]);


            React.useEffect(() => {
                if (isOpen && selectedCameraId && currentStream && currentStream.getVideoTracks()[0]?.getSettings().deviceId !== selectedCameraId) {
                    const selectedCam = availableCameras.find(cam => cam.deviceId === selectedCameraId);
                    const facingMode = selectedCam ? (selectedCam.label.toLowerCase().includes('front') ? 'user' : 'environment') : 'environment';
                    startCamera(selectedCameraId, facingMode);
                }
            }, [selectedCameraId, isOpen, startCamera, currentStream, availableCameras]);


            const takePhoto = () => {
                if (!videoRef.current || videoRef.current.readyState < 3 || !currentStream) {
                    setError("Errore: Video non pronto.");
                    return;
                }


                const video = videoRef.current;
                const canvas = canvasRef.current;
                const targetWidth = 192;
                const targetHeight = 256;
                const videoRatio = video.videoWidth / video.videoHeight;
                const targetRatio = targetWidth / targetHeight;


                let sx, sy, sWidth, sHeight;


                if (videoRatio > targetRatio) {
                    sHeight = video.videoHeight;
                    sWidth = sHeight * targetRatio;
                    sx = (video.videoWidth - sWidth) / 2;
                    sy = 0;
                } else {
                    sWidth = video.videoWidth;
                    sHeight = sWidth / targetRatio;
                    sx = 0;
                    sy = (video.videoHeight - sHeight) / 2;
                }


                canvas.width = targetWidth;
                canvas.height = targetHeight;


                const context = canvas.getContext('2d');
                context.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);


                const imageDataUrl = canvas.toDataURL('image/png');
                onCapture(imageDataUrl);
                onClose();
            };


            if (!isOpen) return null;


            return (
                <div className="camera-modal-overlay">
                    <div className="camera-modal-content">
                        <h2 className="text-xl font-bold text-blue-400 mb-4">Cattura Immagine</h2>
                        {error && <p className="text-red-500 mb-4">{error}</p>}
                        {!error && <p className="text-blue-300 mb-4">{cameraStatusMessage}</p>}


                        {availableCameras.length > 1 && (
                            <div className="mb-4 w-full max-w-xs">
                                <label htmlFor="camera-select" className="block text-gray-300 text-sm font-bold mb-2">
                                    Seleziona Fotocamera:
                                </label>
                                <select
                                    id="camera-select"
                                    value={selectedCameraId || ''}
                                    onChange={(e) => setSelectedCameraId(e.target.value)}
                                    className="block w-full p-2 rounded-md bg-gray-600 text-white border border-gray-500"
                                >
                                    {availableCameras.map(camera => (
                                        <option key={camera.deviceId} value={camera.deviceId}>
                                            {camera.label || `Fotocamera ${camera.deviceId.substring(0, 5)}...`}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        )}


                        <div className="camera-video-container">
                            <video 
                                ref={videoRef} 
                                className="camera-video" 
                                autoPlay 
                                playsInline 
                                muted 
                                style={{ transform: isFrontCamera ? 'scaleX(-1)' : 'scaleX(1)' }}
                            ></video>
                            <div className="capture-frame-overlay"></div>
                            {(!currentStream || error || videoRef.current?.readyState < 2) && (
                                <div className="absolute inset-0 flex justify-center items-center bg-gray-900 bg-opacity-80 text-gray-400 text-center p-4">
                                    {error || cameraStatusMessage || "Attendere il video..."}
                                </div>
                            )}
                        </div>
                        
                        <canvas ref={canvasRef} className="camera-canvas"></canvas>
                        <div className="flex space-x-4 mt-4">
                            <button
                                onClick={takePhoto}
                                className="px-6 py-3 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors shadow-lg font-bold disabled:opacity-50"
                                disabled={!currentStream || !videoRef.current || videoRef.current.videoWidth === 0 || videoRef.current.readyState < 3} 
                            >
                                Scatta Foto
                            </button>
                            <button
                                onClick={onClose}
                                className="px-6 py-3 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-lg font-bold"
                            >
                                Chiudi
                            </button>
                        </div>
                    </div>
                </div>
            );
        }


        function ZoomModal({ isOpen, imageUrl, onClose }) {
            if (!isOpen || !imageUrl) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content" onClick={(e) => e.stopPropagation()}>
                        <img src={imageUrl} alt="Carta ingrandita" />
                        <button className="zoom-modal-close-btn" onClick={onClose}>×</button>
                    </div>
                </div>
            );
        }


        function RecallFromBoxModal({ isOpen, onClose, boxCards, onSelectCardFromBox, onDeleteCardFromBox }) {
            const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = React.useState(false);
            const [cardToDeleteIndex, setCardToDeleteIndex] = React.useState(null);


            const handleDeleteClick = (index, e) => {
                e.stopPropagation();
                setCardToDeleteIndex(index);
                setIsDeleteConfirmOpen(true);
            };


            const confirmDelete = () => {
                if (cardToDeleteIndex !== null) {
                    onDeleteCardFromBox(cardToDeleteIndex);
                    setIsDeleteConfirmOpen(false);
                    setCardToDeleteIndex(null);
                }
            };


            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Box</h2>
                        {boxCards.length === 0 ? (
                            <p className="text-gray-400 text-lg">Il box è vuoto.</p>
                        ) : (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {boxCards.map((card, index) => (
                                    <div
                                        key={index}
                                        className="relative bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromBox(card, index)}
                                    >
                                        <img
                                            src={card.imageUrl}
                                            alt={`Carta nel Box ${index + 1}`}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs">HP: {card.baseHp}</p>
                                        <p className="text-gray-300 text-xs">EXP: {card.exp}</p>
                                        <button
                                            onClick={(e) => handleDeleteClick(index, e)}
                                            className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700"
                                            title="Elimina dal Box"
                                        >
                                            X
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button
                            onClick={onClose}
                            className="btn-theme btn-red mt-6 px-6 py-2 text-lg"
                        >
                            Chiudi
                        </button>


                        {isDeleteConfirmOpen && (
                            <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-30 rounded-lg p-6">
                                <p className="text-white text-center mb-6 text-xl font-bold">
                                    Sei sicuro di voler eliminare questa carta dal Box?
                                </p>
                                <div className="flex space-x-4">
                                    <button onClick={confirmDelete} className="btn-theme btn-red text-base md:text-lg">Sì</button>
                                    <button onClick={() => setIsDeleteConfirmOpen(false)} className="btn-theme btn-gray text-base md:text-lg">No</button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }


        function SelectFromDatabaseModal({ isOpen, onClose, onSelectCardFromDatabase, cardsData, isLoading, error, title }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;


            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">{title || 'Seleziona dal Database'}</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta trovata.</p>
                        )}


                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromDatabase(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {card.baseHp !== undefined && card.baseHp > 0 && (
                                            <p className="text-gray-400 text-xs">HP: {card.baseHp}</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={onClose} className="btn-theme btn-red mt-6 px-6 py-2 text-lg">Chiudi</button>
                    </div>
                </div>
            );
        }


        function SelectFromSupabaseTableModal({ isOpen, onClose, onSelectTableAndFetchRandom }) {
            const tableOptions = ['rosa', 'verde', 'blu', 'giallo', 'rosso', 'oro'];
            const [selectedTable, setSelectedTable] = React.useState('');
            const [isLoadingRandomCard, setIsLoadingRandomCard] = React.useState(false);
            const [randomCardError, setRandomCardError] = React.useState(null);


            const handleSelect = async () => {
                if (selectedTable) {
                    setIsLoadingRandomCard(true);
                    setRandomCardError(null);
                    try {
                        await onSelectTableAndFetchRandom(selectedTable);
                        onClose();
                    } catch (error) {
                        setRandomCardError("Errore nel recupero della carta casuale: " + error.message);
                    } finally {
                        setIsLoadingRandomCard(false);
                    }
                }
            };


            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Scegli Tabella per Carta Casuale</h2>
                        <select
                            value={selectedTable}
                            onChange={(e) => setSelectedTable(e.target.value)}
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4"
                        >
                            <option value="">Seleziona una tabella</option>
                            {tableOptions.map(table => (
                                <option key={table} value={table}>{table.charAt(0).toUpperCase() + table.slice(1)}</option>
                            ))}
                        </select>


                        <button
                            onClick={handleSelect}
                            className="btn-theme btn-green px-6 py-3 text-lg disabled:opacity-50"
                            disabled={!selectedTable || isLoadingRandomCard}
                        >
                            {isLoadingRandomCard ? 'Caricamento...' : 'Scegli e Carica Casuale'}
                        </button>


                        {randomCardError && <p className="text-red-500 mt-4">{randomCardError}</p>}


                        <button onClick={onClose} className="btn-theme btn-red mt-6 px-6 py-2 text-lg">Annulla</button>
                    </div>
                </div>
            );
        }


        function SelectFromPalestreModal({ isOpen, onClose, onSelectCardFromPalestre, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;


            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Seleziona dal Database Palestre</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta palestra..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte palestra...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta palestra trovata.</p>
                        )}


                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectCardFromPalestre(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={onClose} className="btn-theme btn-red mt-6 px-6 py-2 text-lg">Chiudi</button>
                    </div>
                </div>
            );
        }


        function SelectFromTrainersCardDatabaseModal({ isOpen, onClose, onSelectTrainerCard, cardsData, isLoading, error }) {
            const [searchTerm, setSearchTerm] = React.useState('');
            
            const cardsToDisplay = searchTerm 
                ? cardsData.filter(card => card.name.toLowerCase().includes(searchTerm.toLowerCase()))
                : cardsData;


            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-4">Aggiungi Carta Allenatore</h2>
                        <input
                            type="text"
                            placeholder="Cerca carta allenatore..."
                            className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 mb-4"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                        {isLoading && <p className="text-blue-300 text-lg mb-4">Caricamento carte allenatore...</p>}
                        {error && <p className="text-red-500 text-lg mb-4">Errore: {error}</p>}
                        
                        {!isLoading && !error && cardsToDisplay.length === 0 && (
                            <p className="text-gray-400 text-lg col-span-full">Nessuna carta allenatore trovata.</p>
                        )}


                        {!isLoading && !error && cardsToDisplay.length > 0 && (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 overflow-y-auto max-h-80vh p-2">
                                {cardsToDisplay.map((card) => (
                                    <div
                                        key={card.id}
                                        className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors flex flex-col items-center"
                                        onClick={() => onSelectTrainerCard(card)}
                                    >
                                        <img
                                            src={card.imageUrl} 
                                            alt={card.name}
                                            className="w-24 h-32 object-cover rounded-md border border-gray-500 mb-1"
                                            onError={(e) => { e.target.onerror = null; e.target.src = "https://placehold.co/96x128/444/bbb?text=Errore"; }}
                                        />
                                        <p className="text-gray-300 text-xs font-semibold">{card.name}</p>
                                        {card.cost !== undefined && (
                                            <p className="text-yellow-400 text-xs font-bold">Costo: {card.cost} 💰</p>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={onClose} className="btn-theme btn-red mt-6 px-6 py-2 text-lg">Chiudi</button>
                    </div>
                </div>
            );
        }


        function AddCardChoiceModal({ isOpen, onClose, onChooseNew, onChooseFromBox, onChooseFromDatabase, onChooseFromSupabaseTable, onChooseFromPalestre }) {
            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center">
                        <h2 className="text-2xl font-bold text-yellow-300 mb-6 text-center">Come vuoi aggiungere la carta?</h2>
                        <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                            <button onClick={onChooseNew} className="btn-theme btn-green px-6 py-3 text-lg">Nuova Carta 📸</button>
                            <button onClick={onChooseFromBox} className="btn-theme btn-blue px-6 py-3 text-lg">Dal Box 📦</button>
                            <button onClick={onChooseFromDatabase} className="btn-theme btn-yellow px-6 py-3 text-lg">Dal Database 📚</button>
                            <button onClick={onChooseFromSupabaseTable} className="btn-theme btn-orange px-6 py-3 text-lg">Casuale da Tabella 🎲</button>
                            <button onClick={onChooseFromPalestre} className="btn-theme btn-purple px-6 py-3 text-lg">Da Palestre 🏛️</button>
                        </div>
                        <button onClick={onClose} className="btn-theme btn-red mt-8 px-6 py-2 text-lg">Annulla</button>
                    </div>
                </div>
            );
        }


        // Componente CardSlot
        function CardSlot({ slotIndex, cardData, onUpdateCard, onToggleActivePokemon, isMyTurn, activeCardParalyzed, onSendToBox, onRecallFromBox, boxCards, pokemonDbCards, trainersDbCards, palestreDbCards, isDbLoading, dbError, onSelectTableAndFetchRandom, onSelectPalestreCard, role, showTemporaryCard, isBoardEmpty, onOpenHealingModal, isTonicEvolveActive, onEvolutionComplete }) {
            const [baseHp, setBaseHp] = React.useState(cardData ? cardData.baseHp : 0);
            const [damageTaken, setDamageTaken] = React.useState(cardData ? cardData.damageTaken : 0);
            const [statuses, setStatuses] = React.useState(cardData ? cardData.statuses : Array(5).fill(false));
            const [cardImage, setCardImage] = React.useState(cardData ? cardData.imageUrl : null);
            const [currentExp, setCurrentExp] = React.useState(cardData ? cardData.exp : 0);
            const [isActivePokemon, setIsActivePokemon] = React.useState(cardData ? cardData.isActivePokemon : false);


            const [isConfirmModalOpen, setIsConfirmModal] = React.useState(false);
            const [confirmAction, setConfirmAction] = React.useState(null);


            const fileInputRef = React.useRef(null);
            const [showCameraModal, setShowCameraModal] = React.useState(false);
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [showRecallFromBoxModal, setShowRecallFromBoxModal] = React.useState(false);
            const [showAddCardChoiceModal, setShowAddCardChoiceModal] = React.useState(false);
            const [showSelectFromDatabaseModal, setShowSelectFromDatabaseModal] = React.useState(false);
            const [showSelectFromSupabaseTableModal, setShowSelectFromSupabaseTableModal] = React.useState(false);
            const [showSelectFromPalestreModal, setShowSelectFromPalestreModal] = React.useState(false);
            const [showEvolveModal, setShowEvolveModal] = React.useState(false);


            const [zoomLevel, setZoomLevel] = React.useState(1.0);
            const [panX, setPanX] = React.useState(0);
            const [panY, setPanY] = React.useState(0);


            const resetCardView = React.useCallback(() => {
                setZoomLevel(1.0);
                setPanX(0);
                setPanY(0);
            }, []);


            React.useEffect(() => {
                if (cardData) {
                    setBaseHp(cardData.baseHp);
                    setDamageTaken(cardData.damageTaken);
                    setStatuses(cardData.statuses);
                    setCardImage(cardData.imageUrl);
                    setCurrentExp(cardData.exp);
                    setIsActivePokemon(cardData.isActivePokemon);
                } else {
                    setBaseHp(0);
                    setDamageTaken(0);
                    setStatuses(Array(5).fill(false));
                    setCardImage(null);
                    setCurrentExp(0);
                    setIsActivePokemon(false);
                    resetCardView();
                }
            }, [cardData]);


            const updateParentCardData = React.useCallback((newBaseHp, newDamageTaken, newStatuses, newImageUrl, newExpValue, newIsActivePokemon) => {
                onUpdateCard(slotIndex, {
                    imageUrl: newImageUrl,
                    baseHp: newBaseHp,
                    damageTaken: newDamageTaken,
                    statuses: newStatuses,
                    exp: newExpValue,
                    isActivePokemon: newIsActivePokemon
                });
            }, [onUpdateCard, slotIndex]);


            const handleNewImageSelection = (imageUrl, cardDetailsFromDb = {}) => {
                const isPokemon = (cardDetailsFromDb.baseHp !== undefined && cardDetailsFromDb.baseHp > 0) || (baseHp > 0 && cardDetailsFromDb.baseHp === undefined);
                
                if (cardImage) {
                    setConfirmAction({ type: 'replace_image', imageUrl: imageUrl, cardDetailsFromDb: cardDetailsFromDb });
                    setIsConfirmModal(true);
                } else {
                    const newCardData = {
                        imageUrl: imageUrl,
                        baseHp: cardDetailsFromDb.baseHp !== undefined ? cardDetailsFromDb.baseHp : baseHp,
                        exp: cardDetailsFromDb.exp !== undefined ? cardDetailsFromDb.exp : 0,
                        damageTaken: 0,
                        statuses: Array(5).fill(false),
                        isActivePokemon: isBoardEmpty && isPokemon
                    };
                    onUpdateCard(slotIndex, newCardData);
                }
                resetCardView();
            };


            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => handleNewImageSelection(reader.result);
                    reader.readAsDataURL(file);
                }
                resetCardView();
            };


            const handleConfirmAction = (actionType, shouldResetDataForImageReplace = false) => {
                setIsConfirmModal(false);


                if (actionType === 'confirm_replace_image' && confirmAction?.type === 'replace_image') {
                    const { imageUrl, cardDetailsFromDb = {} } = confirmAction;
                    if (shouldResetDataForImageReplace) {
                        const newBaseHp = cardDetailsFromDb.baseHp ?? 0;
                        const newExp = cardDetailsFromDb.exp ?? 0;
                        updateParentCardData(newBaseHp, 0, Array(5).fill(false), imageUrl, newExp, false);
                    } else {
                        updateParentCardData(baseHp, damageTaken, statuses, imageUrl, currentExp, isActivePokemon);
                    }
                } else if (actionType === 'reset_full_slot' && confirmAction?.type === 'reset_full_slot') {
                    onUpdateCard(slotIndex, null);
                } else if (actionType === 'send_to_box' && confirmAction?.type === 'send_to_box') {
                    if (cardData) onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                } else if (actionType.startsWith('save_and_') && confirmAction) {
                    if (shouldResetDataForImageReplace) {
                        onSendToBox({ imageUrl: cardImage, baseHp: baseHp, exp: currentExp }, slotIndex);
                    }
                    if (actionType.includes('recall_from_box')) setShowRecallFromBoxModal(true);
                    if (actionType.includes('select_from_db')) setShowSelectFromDatabaseModal(true);
                    if (actionType.includes('select_from_supabase_table')) setShowSelectFromSupabaseTableModal(true);
                    if (actionType.includes('select_from_palestre')) setShowSelectFromPalestreModal(true);
                }
                setConfirmAction(null);
            };


            const handleBaseHpChange = (event) => {
                const value = parseInt(event.target.value) || 0;
                updateParentCardData(value, damageTaken, statuses, cardImage, currentExp, isActivePokemon);
            };


            const handleDamageChange = (amount) => {
                const newDamage = Math.max(0, damageTaken + amount);
                updateParentCardData(baseHp, newDamage, statuses, cardImage, currentExp, isActivePokemon); 
            };


            const toggleStatus = (index) => {
                if (!isActivePokemon) return;
                const newStatuses = Array(5).fill(false);
                if (!statuses[index]) {
                    newStatuses[index] = true;
                }
                updateParentCardData(baseHp, damageTaken, newStatuses, cardImage, currentExp, isActivePokemon);
            };


            const requestFullSlotReset = () => {
                setConfirmAction({ type: 'reset_full_slot' });
                setIsConfirmModal(true);
            };


            const handleSendToBox = () => {
                if (cardData) {
                    setConfirmAction({ type: 'send_to_box' });
                    setIsConfirmModal(true);
                }
            };
            
            const handleAddCardPlaceholderClick = () => setShowAddCardChoiceModal(true);
            const handleChooseNewCard = () => { setShowAddCardChoiceModal(false); setShowCameraModal(true); };
            const handleChooseFromBox = () => { setShowAddCardChoiceModal(false); setShowRecallFromBoxModal(true); };


            const createChoiceHandler = (modalSetter, actionType) => () => {
                setShowAddCardChoiceModal(false);
                if (cardData) {
                    setConfirmAction({ type: actionType });
                    setIsConfirmModal(true);
                } else {
                    modalSetter(true);
                }
            };


            const handleChooseFromDatabase = createChoiceHandler(setShowSelectFromDatabaseModal, 'save_and_select_from_db');
            const handleChooseFromSupabaseTable = createChoiceHandler(setShowSelectFromSupabaseTableModal, 'save_and_select_from_supabase_table');
            const handleChooseFromPalestre = createChoiceHandler(setShowSelectFromPalestreModal, 'save_and_select_from_palestre');


            const handleSelectCardFromDatabase = (selectedCard) => {
                setShowSelectFromDatabaseModal(false);
                showTemporaryCard(selectedCard.imageUrl, () => {
                    handleNewImageSelection(selectedCard.imageUrl, { baseHp: selectedCard.baseHp, exp: selectedCard.exp });
                    resetCardView();
                });
            };


            const handleSelectRandomCardFromTable = async (tableName) => {
                try {
                    await onSelectTableAndFetchRandom(tableName);
                    setShowSelectFromSupabaseTableModal(false);
                } catch (error) {
                    console.error("Errore durante il recupero:", error);
                } 
                resetCardView();
            };


            const handleSelectCardFromPalestreCallback = (selectedCard) => {
                setShowSelectFromPalestreModal(false);
                showTemporaryCard(selectedCard.imageUrl, () => onSelectPalestreCard(selectedCard));
            };

            const handleEvolve = () => {
                setShowEvolveModal(true);
            };

            const handleSelectEvolution = (selectedCard) => {
                onUpdateCard(slotIndex, {
                    imageUrl: selectedCard.imageUrl,
                    baseHp: selectedCard.baseHp,
                    damageTaken: 0,
                    statuses: Array(5).fill(false),
                    exp: currentExp, // Inherit EXP
                    isActivePokemon: isActivePokemon, // Inherit active status
                });
                setShowEvolveModal(false);
                if (isTonicEvolveActive) {
                    onEvolutionComplete();
                }
            };


            React.useEffect(() => {
                setIsActivePokemon(cardData?.isActivePokemon ?? false);
            }, [cardData?.isActivePokemon]);


            const isStarButtonDisabled = !isMyTurn || (activeCardParalyzed && !isActivePokemon) || (isActivePokemon && statuses[3]);
            const isPlayerSlotDisabled = role !== 'player';
            const statusColors = ['bg-lime-500', 'bg-rose-500', 'bg-sky-500', 'bg-yellow-500', 'bg-purple-500'];
            const currentHpValue = baseHp - damageTaken;


            const getHpColorClasses = () => {
                if (baseHp === 0) return { border: 'border-green-600', label: 'text-green-300', value: 'text-green-500' };
                const percentage = (currentHpValue / baseHp) * 100;
                if (percentage <= 33.3) return { border: 'border-red-500', label: 'text-red-300', value: 'text-red-500' };
                if (percentage <= 66.6) return { border: 'border-yellow-500', label: 'text-yellow-300', value: 'text-yellow-500' };
                return { border: 'border-green-600', label: 'text-green-300', value: 'text-green-500' };
            };
            const hpColorClasses = getHpColorClasses();


            return (
                <div className={`relative p-6 rounded-xl shadow-2xl flex flex-col items-center border-4 ${isActivePokemon ? 'border-blue-400 bg-blue-900 bg-opacity-70' : 'border-yellow-400 bg-gray-800'}`}>
                    <input type="file" accept="image/*" onChange={handleFileUpload} ref={fileInputRef} className="hidden" />
                    <div className="flex items-center justify-between w-full mb-4">
                        <div className={`flex items-center space-x-2 text-2xl bg-gray-900 p-2 rounded-lg border-2 ${hpColorClasses.border} shadow-md flex-grow`}>
                            <span className={`counter-label ${hpColorClasses.label}`}>HP:</span>
                            <span className={`counter-value ${hpColorClasses.value}`}>{currentHpValue}</span>
                        </div>
                        <button onClick={() => onToggleActivePokemon(slotIndex)} className={`ml-4 flex items-center justify-center w-12 h-12 rounded-full text-3xl shadow-md border-2 ${isActivePokemon ? 'bg-yellow-400 border-yellow-600 text-gray-800' : 'bg-gray-600 border-gray-700 text-gray-300 hover:bg-gray-500'} ${isStarButtonDisabled ? 'opacity-50 cursor-not-allowed' : ''}`} title={isActivePokemon ? 'Pokémon Attivo' : 'Rendi Attivo'} disabled={isStarButtonDisabled}>⭐</button>
                    </div>
                    {currentHpValue <= 0 && cardImage && (
                        <div className="absolute top-36 w-48 bg-red-700 text-white text-center font-extrabold text-2xl py-2 rounded-lg border-2 border-red-400 z-10 animate-pulse">ESAUSTO</div>
                    )}
                    {cardImage ? (
                        <div className="relative w-48 h-64 overflow-hidden rounded-lg border-2 border-gray-600 mb-6 bg-gray-900 shadow-inner">
                            <img src={cardImage} alt={`Carta ${slotIndex + 1}`} className="w-full h-full object-cover cursor-pointer" onClick={() => setShowZoomModal(true)} onError={(e) => { e.target.src = "https://placehold.co/192x256/444/bbb?text=Errore"; }} />
                        </div>
                    ) : (
                        <div className="w-48 h-64 bg-gray-900 flex justify-center items-center text-gray-400 text-xl cursor-pointer rounded-lg border-4 border-dashed border-gray-600 mb-6 hover:bg-gray-800" onClick={handleAddCardPlaceholderClick}>
                            <span className="text-center font-bold">Aggiungi Carta</span>
                        </div>
                    )}
                    {(cardData || cardImage) && (
                        <>
                            <div className="flex space-x-4 mb-6 w-full justify-center">
                                <button onClick={() => fileInputRef.current.click()} className="icon-btn btn-blue" title="Carica da File">📁</button>
                                <button onClick={() => setShowCameraModal(true)} className="icon-btn btn-purple" title="Carica da Fotocamera">📸</button>
                            </div>
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-red-300">HP Base:</span>
                                <input type="number" value={baseHp} onChange={handleBaseHpChange} className="w-24 px-3 py-2 bg-gray-900 border-2 border-red-500 rounded-lg text-center text-red-200 font-extrabold" min="0" />
                            </div>
                            <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                <span className="counter-label text-orange-300">Danni:</span>
                                <button onClick={() => handleDamageChange(-10)} className="btn-theme btn-yellow px-4 py-2 text-xl">-10</button>
                                <span className="counter-value text-red-500">{damageTaken}</span>
                                <button onClick={() => handleDamageChange(10)} className="btn-theme btn-orange px-4 py-2 text-xl">+10</button>
                            </div>
                            {role === 'player' && (
                                <div className="flex items-center space-x-4 mb-4 text-xl w-full justify-center">
                                    <span className="counter-label text-blue-300">EXP:</span>
                                    <div className="flex space-x-1">
                                        {[...Array(6)].map((_, i) => (<div key={i} className={`exp-dot ${i < currentExp ? (isActivePokemon ? 'active-blue' : 'active-yellow') : ''}`}></div>))}
                                    </div>
                                </div>
                            )}
                            <div className="flex space-x-3 mb-6">
                                {statuses.map((isActive, index) => {
                                    const statusSymbols = ['😴', '🔥', '😵', '🛑', '💀'];
                                    const statusTitles = ['Addormentato', 'Bruciato', 'Confuso', 'Paralizzato', 'Avvelenato'];
                                    return (<div key={index} className={`w-10 h-10 rounded-full flex justify-center items-center font-bold text-3xl border-2 border-gray-600 ${isActive ? `${statusColors[index]} scale-110 ring-2 ring-offset-2 ring-offset-gray-800` : 'bg-gray-600 text-gray-300'} ${isActivePokemon ? 'cursor-pointer' : 'cursor-not-allowed opacity-50'}`} onClick={() => toggleStatus(index)} title={statusTitles[index]}>{statusSymbols[index]}</div>);
                                })}
                            </div>
                            <div className="w-full mt-4 max-w-xs">
                                {role === 'player' ? (
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={handleSendToBox} className={`btn-theme btn-purple text-xs w-full py-2 px-1 ${!cardData ? 'opacity-50 cursor-not-allowed' : ''}`} title="Invia al Box" disabled={!cardData}>INVIA AL BOX</button>
                                        <button 
                                            onClick={handleEvolve}
                                            className={`btn-theme btn-cyan text-xs w-full py-2 px-1 ${!cardData || !(isTonicEvolveActive || (currentExp >= 3 && currentExp % 3 === 0)) ? 'opacity-50 cursor-not-allowed' : ''}`}
                                            title="Evolvi Pokémon"
                                            disabled={!cardData || !(isTonicEvolveActive || (currentExp >= 3 && currentExp % 3 === 0))}
                                        >
                                            EVOLVI
                                        </button>
                                        <button onClick={() => onOpenHealingModal(slotIndex)} className={`btn-theme btn-green text-xs w-full py-2 px-1 ${!cardData ? 'opacity-50 cursor-not-allowed' : ''}`} disabled={!cardData}>CURA</button>
                                        <button onClick={requestFullSlotReset} className={`btn-theme btn-red text-xs w-full py-2 px-1 ${!cardData ? 'opacity-50 cursor-not-allowed' : ''}`} title="Resetta Slot" disabled={!cardData}>RESET</button>
                                    </div>
                                ) : (
                                    <div className="flex justify-center">
                                         <button onClick={requestFullSlotReset} className={`btn-theme btn-red w-full ${!cardData ? 'opacity-50 cursor-not-allowed' : ''}`} title="Resetta Slot" disabled={!cardData}>RESETTA SLOT</button>
                                    </div>
                                )}
                            </div>
                        </>
                    )}
                    {isConfirmModalOpen && (
                        <div className="absolute inset-0 bg-gray-900 bg-opacity-95 flex flex-col justify-center items-center z-20 rounded-lg p-6">
                            <p className="text-white text-center mb-6 text-xl font-bold">
                                {confirmAction?.type === 'reset_full_slot' ? 'Sei sicuro di voler resettare questo slot?' :
                                 confirmAction?.type === 'send_to_box' ? 'Inviare al Box?' :
                                 confirmAction?.type.startsWith('save_and_') ? 'Salvare la carta attuale nel Box prima di sostituirla?' :
                                 'Mantenere i dati della carta precedente o azzerarli?'}
                            </p>
                            <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-6 w-full justify-center">
                                {confirmAction?.type === 'replace_image' && <button onClick={() => handleConfirmAction('confirm_replace_image', false)} className="btn-theme btn-green">Mantieni Dati</button>}
                                <button onClick={() => handleConfirmAction(confirmAction.type, true)} className="btn-theme btn-red">{confirmAction?.type === 'replace_image' ? 'Azzera Dati' : 'Sì'}</button>
                                {confirmAction?.type !== 'replace_image' && <button onClick={() => setIsConfirmModal(false)} className="btn-theme btn-gray">No</button>}
                            </div>
                        </div>
                    )}
                    <CameraModal isOpen={showCameraModal} onClose={() => setShowCameraModal(false)} onCapture={handleNewImageSelection} />
                    <ZoomModal isOpen={showZoomModal} imageUrl={cardImage} onClose={() => setShowZoomModal(false)} />
                    <RecallFromBoxModal isOpen={showRecallFromBoxModal} onClose={() => setShowRecallFromBoxModal(false)} boxCards={boxCards} onSelectCardFromBox={(card, index) => { onRecallFromBox(card, slotIndex, index); setShowRecallFromBoxModal(false); resetCardView(); }} onDeleteCardFromBox={(index) => onRecallFromBox(null, null, index, true)} />
                    <SelectFromDatabaseModal isOpen={showSelectFromDatabaseModal} onClose={() => setShowSelectFromDatabaseModal(false)} onSelectCardFromDatabase={handleSelectCardFromDatabase} cardsData={pokemonDbCards} isLoading={isDbLoading} error={dbError} />
                    <SelectFromDatabaseModal isOpen={showEvolveModal} onClose={() => setShowEvolveModal(false)} onSelectCardFromDatabase={handleSelectEvolution} cardsData={pokemonDbCards} isLoading={isDbLoading} error={dbError} title="Seleziona Evoluzione" />
                    <SelectFromSupabaseTableModal isOpen={showSelectFromSupabaseTableModal} onClose={() => setShowSelectFromSupabaseTableModal(false)} onSelectTableAndFetchRandom={handleSelectRandomCardFromTable} />
                    <SelectFromPalestreModal isOpen={showSelectFromPalestreModal} onClose={() => setShowSelectFromPalestreModal(false)} onSelectCardFromPalestre={handleSelectCardFromPalestreCallback} cardsData={palestreDbCards} isLoading={isDbLoading} error={dbError} />
                    <AddCardChoiceModal isOpen={showAddCardChoiceModal} onClose={() => setShowAddCardChoiceModal(false)} onChooseNew={handleChooseNewCard} onChooseFromBox={handleChooseFromBox} onChooseFromDatabase={handleChooseFromDatabase} onChooseFromSupabaseTable={handleChooseFromSupabaseTable} onChooseFromPalestre={handleChooseFromPalestre} />
                </div>
            );
        }
        
        // Altri componenti (MedalDisplay, DiceRoller, etc.)
        function MedalDisplay({ gymMedals, onToggleMedal }) { 
            const medalSymbols = ['⚫', '💧', '⚡', '🌈', '❤️', '🟠', '🌋', '🌿']; 
            const medalTitles = ['Roccia', 'Cascata', 'Saetta', 'Arcobaleno', 'Anima', 'Terra', 'Vulcano', 'Foglia'];
            return (
                <div className="flex flex-col items-center p-3 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 max-w-sm w-full">
                    <h3 className="text-xl font-bold text-yellow-300 mb-4">PALESTRE</h3>
                    <div className="flex flex-wrap justify-center gap-2">
                        {gymMedals.map((isActive, index) => (
                            <div key={index} className={`medal-icon ${isActive ? "bg-yellow-300 text-gray-800 ring-yellow-500 active" : "bg-gray-600 text-gray-300 hover:bg-gray-500"}`} onClick={() => onToggleMedal(index)} title={medalTitles[index]}>{medalSymbols[index]}</div>
                        ))}
                    </div>
                </div>
            );
        }

        function HMDisplay({ gymMedals }) {
            const isFlyActive = gymMedals[2];
            const isSurfActive = gymMedals[4];

            return (
                 <div className="flex flex-col items-center p-3 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 max-w-sm w-full mt-4">
                    <h3 className="text-xl font-bold text-yellow-300 mb-4">MN</h3>
                    <div className="flex justify-center gap-4">
                        <div className={`hm-icon ${isFlyActive ? 'fly-active active' : ''}`} title="Volo">🕊️</div>
                        <div className={`hm-icon ${isSurfActive ? 'surf-active active' : ''}`} title="Surf">🌊</div>
                    </div>
                </div>
            );
        }


        function EliteFourDisplay({ eliteFourMedals, onToggleMedal }) { 
            const eliteFourSymbols = ['❄️', '✊', '👻', '🐉']; 
            const eliteFourTitles = ['Lorelei', 'Bruno', 'Agatha', 'Lance'];
            return (
                <div className="flex flex-col items-center p-3 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 max-w-sm w-full mt-8"> 
                    <h3 className="text-xl font-bold text-yellow-300 mb-4">SUPERQUATTRO</h3>
                    <div className="flex flex-wrap justify-center gap-2">
                        {eliteFourMedals.map((isActive, index) => (
                            <div key={index} className={`elite-four-icon ${isActive ? "active" : ""}`} onClick={() => onToggleMedal(index)} title={eliteFourTitles[index]}>{eliteFourSymbols[index]}</div>
                        ))}
                    </div>
                </div>
            );
        }


        function DiceRoller({ title, isAttackRoller, isDiceRollDisabled, onConfusedRollAttempt, isMyTurn, onDiceRollComplete, onDisplayGlobalBanner, isCaptureRoller, onCaptureCoinFlipNeeded, wildPokemonHpStatus, onWildPokemonHpChange, role, onOpenSelectBallModal, selectedBall }) {
            const [numberOfDice, setNumberOfDice] = React.useState(1);
            const [diceResults, setDiceResults] = React.useState([]);
            const [rollOutcome, setRollOutcome] = React.useState(null);

            React.useEffect(() => {
                if (isCaptureRoller && selectedBall) {
                    let diceCount = 1;
                    if (selectedBall.includes('poké ball')) {
                        if (wildPokemonHpStatus === 'green') diceCount = 4;
                        else if (wildPokemonHpStatus === 'yellow') diceCount = 3;
                        else if (wildPokemonHpStatus === 'red') diceCount = 1;
                    } else if (selectedBall.includes('mega ball')) {
                        if (wildPokemonHpStatus === 'green') diceCount = 3;
                        else if (wildPokemonHpStatus === 'yellow') diceCount = 2;
                        else if (wildPokemonHpStatus === 'red') diceCount = 1;
                    } else if (selectedBall.includes('ultra ball')) {
                        if (wildPokemonHpStatus === 'green') diceCount = 2;
                        else if (wildPokemonHpStatus === 'yellow') diceCount = 1;
                        else if (wildPokemonHpStatus === 'red') diceCount = 0;
                    }
                    setNumberOfDice(diceCount);
                } else if (isCaptureRoller) {
                    setNumberOfDice(1);
                }
            }, [isCaptureRoller, selectedBall, wildPokemonHpStatus]);
            
            const handleRoll = async () => {
                setDiceResults([]);
                setRollOutcome(null);

                if (isAttackRoller) {
                    if (isDiceRollDisabled === 'paralyzed') {
                        onDisplayGlobalBanner("Pokémon Paralizzato!", 'info', 3000);
                        return; 
                    }
                    if (isDiceRollDisabled === 'confused') { 
                        if (!await onConfusedRollAttempt()) return;
                    }
                }

                if (isCaptureRoller && numberOfDice === 0) {
                    onCaptureCoinFlipNeeded();
                    return;
                }

                const newResults = Array.from({ length: numberOfDice }, () => Math.floor(Math.random() * 6) + 1);
                setDiceResults(newResults);


                const onesCount = newResults.filter(r => r === 1).length;


                if (isAttackRoller) {
                    const foursCount = newResults.filter(r => r === 4).length;
                    const isCritical = (numberOfDice <= 3 && foursCount >= 2) || (numberOfDice > 3 && foursCount >= 3);
                    if (isCritical) {
                        onDisplayGlobalBanner("Attacco Critico!", 'attack_critical', 3000);
                        setRollOutcome("Critico!");
                    } else if (onesCount >= 1) {
                        onDisplayGlobalBanner("Attacco Fallito!", 'attack_failed', 3000);
                        setRollOutcome("Fallito!");
                    } else {
                        onDisplayGlobalBanner("Attacco Riuscito!", 'attack_success', 3000);
                        setRollOutcome("Riuscito!");
                    }
                    onDiceRollComplete(); 
                } else if (isCaptureRoller) {
                    if (onesCount >= 1) {
                        onDisplayGlobalBanner("Cattura Fallita!", 'capture_fail', 3000);
                        onDiceRollComplete(); 
                    } else {
                        onCaptureCoinFlipNeeded();
                    }
                } else { // Retreat
                    if (onesCount >= 1) {
                        onDisplayGlobalBanner("Ritirata Fallita!", 'retreat_failed', 3000);
                        setRollOutcome("Fallita!");
                    } else {
                        onDisplayGlobalBanner("Ritirata Riuscita!", 'retreat_success', 3000);
                        setRollOutcome("Riuscita!");
                    }
                    onDiceRollComplete(); 
                }
            };


            let isDisabled = !isMyTurn || (isAttackRoller && (isDiceRollDisabled === 'asleep' || isDiceRollDisabled === 'paralyzed'));


            return (
                <div className="bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col items-center justify-center border-4 border-yellow-400 gap-4 flex-1 max-w-xs w-full mb-4"> 
                    <h2 className="text-lg font-bold text-yellow-300">{title}</h2>
                    <div className="flex items-center space-x-2">
                        <label className="counter-label text-white text-sm">N°:</label>
                        <select 
                            value={numberOfDice} 
                            onChange={(e) => setNumberOfDice(parseInt(e.target.value))} 
                            className="bg-gray-700 text-white rounded-md p-1 text-sm border border-gray-600"
                            disabled={isCaptureRoller && !!selectedBall}
                        >
                            {[0, 1, 2, 3, 4, 5, 6].map(num => (<option key={num} value={num}>{num}</option>))}
                        </select>
                    </div>
                    <button onClick={handleRoll} className="btn-theme btn-green text-base px-3 py-1 disabled:opacity-50 w-full" disabled={isDisabled}>Lancia</button>
                    
                    {isCaptureRoller && role === 'player' && (
                        <div className="mt-4 w-full flex flex-col items-center border-t-2 border-gray-700 pt-3 space-y-3">
                            <div>
                                <h3 className="counter-label text-white text-sm mb-2 text-center">HP Pokémon Selvatico</h3>
                                <div className="flex space-x-4">
                                    <button
                                        onClick={() => onWildPokemonHpChange('green')}
                                        className={`w-8 h-8 rounded-full border-2 transition-transform duration-200 bg-green-500 ${
                                            wildPokemonHpStatus === 'green' ? 'ring-2 ring-offset-2 ring-offset-gray-800 ring-white scale-110' : 'border-gray-600'
                                        }`}
                                        aria-label="HP Pieni"
                                    ></button>
                                    <button
                                        onClick={() => onWildPokemonHpChange('yellow')}
                                        className={`w-8 h-8 rounded-full border-2 transition-transform duration-200 bg-yellow-500 ${
                                            wildPokemonHpStatus === 'yellow' ? 'ring-2 ring-offset-2 ring-offset-gray-800 ring-white scale-110' : 'border-gray-600'
                                        }`}
                                         aria-label="HP Metà"
                                    ></button>
                                    <button
                                        onClick={() => onWildPokemonHpChange('red')}
                                        className={`w-8 h-8 rounded-full border-2 transition-transform duration-200 bg-red-500 ${
                                            wildPokemonHpStatus === 'red' ? 'ring-2 ring-offset-2 ring-offset-gray-800 ring-white scale-110' : 'border-gray-600'
                                        }`}
                                         aria-label="HP Bassi"
                                    ></button>
                                </div>
                            </div>
                             <button 
                                onClick={onOpenSelectBallModal}
                                className="btn-theme btn-cyan w-full text-sm"
                            >
                                Seleziona Poké Ball
                            </button>
                        </div>
                    )}


                    {diceResults.length > 0 && <div className="flex flex-wrap justify-center gap-2 text-3xl font-extrabold text-white mt-2">{diceResults.map((r, i) => (<span key={i} className="bg-gray-900 p-2 rounded-md border-2 border-yellow-500">{diceFaces[r]}</span>))}</div>}
                    {rollOutcome && (
                        <p className={`text-2xl font-bold mt-2 ${
                            rollOutcome.includes('Fallit') ? 'text-red-500' : 
                            rollOutcome.includes('Critico') ? 'text-yellow-400' : 'text-green-500'
                        }`}>
                            {rollOutcome}
                        </p>
                    )}
                </div>
            );
        }


        function TurnIndicator({ isMyTurn, onToggleTurn }) { 
            return (<button onClick={onToggleTurn} className={`flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md border-4 ${isMyTurn ? 'bg-green-500 border-green-700' : 'bg-red-500 border-red-700'} hover:scale-105 active:scale-95 mb-4`} title={isMyTurn ? 'Tuo turno' : 'Turno avversario'}>{isMyTurn ? '🏁' : '🚩'}</button>);
        }


        function CaptureCoinFlipModal({ isOpen, onFlipCoin, coinResult, finalOutcome }) {
            if (!isOpen) return null;
            return (
                <div className="capture-coin-modal-overlay">
                    <div className="capture-coin-modal-content">
                        {!coinResult ? (
                            <><h2>Lancio Moneta di Cattura!</h2><button onClick={onFlipCoin}>Lancia</button></>
                        ) : (
                            <><h2>Risultato: {coinResult.toUpperCase()}</h2><p className={`capture-coin-result ${finalOutcome === 'PRESO' ? 'success' : 'fail'}`}>{finalOutcome}</p></>
                        )}
                    </div>
                </div>
            );
        }
        
        function SelectBallModal({ isOpen, onClose, zainoCards, onUseBall }) {
            if (!isOpen) return null;


            const ballCards = zainoCards.filter(card => card.name.toLowerCase().includes('ball'));


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-cyan-400 flex flex-col items-center w-full max-w-lg">
                        <h2 className="text-3xl font-bold text-cyan-300 mb-6 text-center">Seleziona Poké Ball</h2>
                        {ballCards.length === 0 ? (
                            <p className="text-gray-400 text-lg">Nessuna Poké Ball nello zaino.</p>
                        ) : (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full mb-6 overflow-y-auto max-h-[60vh] p-2">
                                {ballCards.map(card => (
                                    <div key={card.id} className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 flex flex-col items-center text-center">
                                        <img src={card.imageUrl} alt={card.name} className="w-24 h-32 object-cover rounded-md mb-2" />
                                        <p className="text-white text-sm font-semibold">{card.name}</p>
                                        <p className="text-gray-400 text-xs mb-2">Qtà: {card.quantity}</p>
                                        <button
                                            onClick={() => onUseBall(card.id)}
                                            className="btn-theme btn-blue text-sm px-4 py-1"
                                        >
                                            Usa
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={onClose} className="btn-theme btn-red mt-4 px-6 py-2 text-lg">Chiudi</button>
                    </div>
                </div>
            );
        }


        function HealingItemModal({ isOpen, onClose, zainoCards, onUseItem, targetSlot }) {
            if (!isOpen) return null;


            const healingCards = zainoCards.filter(card => 
                card.name.toLowerCase().includes('pozione') || 
                card.name.toLowerCase().includes('cura') ||
                card.name.toLowerCase().includes('caramella') ||
                card.name.toLowerCase().includes('revitalizzante')
            );


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-green-400 flex flex-col items-center w-full max-w-lg">
                        <h2 className="text-3xl font-bold text-green-300 mb-6 text-center">Usa Oggetto di Cura</h2>
                        {healingCards.length === 0 ? (
                            <p className="text-gray-400 text-lg">Nessun oggetto di cura nello zaino.</p>
                        ) : (
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full mb-6 overflow-y-auto max-h-[60vh] p-2">
                                {healingCards.map(card => (
                                    <div key={card.id} className="bg-gray-700 p-2 rounded-lg shadow-md border border-gray-600 flex flex-col items-center text-center">
                                        <img src={card.imageUrl} alt={card.name} className="w-24 h-32 object-cover rounded-md mb-2" />
                                        <p className="text-white text-sm font-semibold">{card.name}</p>
                                        <p className="text-gray-400 text-xs mb-2">Qtà: {card.quantity}</p>
                                        <button
                                            onClick={() => onUseItem(card, targetSlot)}
                                            className="btn-theme btn-green text-sm px-4 py-1"
                                        >
                                            Usa
                                        </button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={onClose} className="btn-theme btn-red mt-4 px-6 py-2 text-lg">Chiudi</button>
                    </div>
                </div>
            );
        }


        // Componenti di visualizzazione (BoxView, NegozioView, etc.)
        function BoxView({ boxCards, onBackToMain, onDeleteCardFromBox, role }) { 
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);


            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };


            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-gray-700 to-gray-900 p-4">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8">{role === 'player' ? 'ZAINO POKÉMON' : 'BOX POKÉMON'}</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    {boxCards.length === 0 ? <p className="text-gray-400 text-xl mt-8">Vuoto.</p> : (
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-6 w-full max-w-4xl">
                            {boxCards.map((card, index) => (
                                <div key={index} className="relative bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center cursor-pointer hover:bg-gray-700" onClick={() => handleCardClick(card.imageUrl)}>
                                    <img src={card.imageUrl} alt={`Carta ${index + 1}`} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2" onError={(e) => { e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm">HP: {card.baseHp}</p>
                                    <p className="text-gray-300 text-sm">EXP: {card.exp}</p>
                                    {role === 'master' && <button onClick={(e) => {e.stopPropagation(); onDeleteCardFromBox(index);}} className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold hover:bg-red-700">X</button>}
                                </div>
                            ))}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                </div>
            );
        }


        function NegozioView({ negozioCards, onBackToMain, isDbLoading, dbError }) { 
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);


            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };


            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-indigo-700 to-purple-900 p-4">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8">NEGOZIO</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    {isDbLoading && <p className="text-blue-300 text-xl mt-8">Caricamento...</p>}
                    {dbError && <p className="text-red-500 text-xl mt-8">Errore: {dbError}</p>}
                    {!isDbLoading && !dbError && negozioCards.length === 0 ? <p className="text-gray-400 text-xl mt-8">Negozio vuoto.</p> : (
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-6 w-full max-w-4xl">
                            {negozioCards.map((card, index) => (
                                <div key={card.id || index} className="bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center cursor-pointer hover:bg-gray-700" onClick={() => handleCardClick(card.imageUrl)}>
                                    <img src={card.imageUrl} alt={card.name} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2" onError={(e) => { e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm font-semibold">{card.name}</p>
                                    {card.baseHp > 0 && <p className="text-gray-400 text-xs">HP: {card.baseHp}</p>}
                                    {card.cost !== undefined && <p className="text-yellow-400 text-base font-bold mt-1">Costo: {card.cost} 💰</p>}
                                </div>
                            ))}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                </div>
            );
        }


        function ZainoView({ playerZainoCards, onBackToMain, onAddCardToZaino, onUpdateZainoCardQuantity, onDeleteZainoCard, trainersCardDbCards, isDbLoading, dbError, onUseEvolutionTonic, isMyTurn, hasUsedTonicThisTurn }) {
            const [showZoomModal, setShowZoomModal] = React.useState(false);
            const [zoomImageUrl, setZoomImageUrl] = React.useState(null);
            const [showAddTrainerCardModal, setShowAddTrainerCardModal] = React.useState(false);


            const handleCardClick = (imageUrl) => {
                setZoomImageUrl(imageUrl);
                setShowZoomModal(true);
            };


            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-indigo-700 to-teal-900 p-4">
                    <h2 className="text-4xl font-extrabold text-yellow-300 mb-8">ZAINO</h2>
                    <button onClick={onBackToMain} className="btn-theme btn-blue mb-8 px-6 py-3 text-lg">Torna al Gioco</button>
                    <button onClick={() => setShowAddTrainerCardModal(true)} className="btn-theme btn-green px-6 py-3 text-lg mb-8">Shop</button>
                    {playerZainoCards.length === 0 ? <p className="text-gray-400 text-xl mt-8">Zaino vuoto.</p> : (
                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-6 w-full max-w-4xl">
                            {playerZainoCards.map((card) => {
                                const isTonic = card.name.toLowerCase().includes('tonico evolutivo');
                                return (
                                <div key={card.id} className="bg-gray-800 p-4 rounded-xl shadow-lg border-2 border-gray-600 flex flex-col items-center">
                                    <img src={card.imageUrl} alt={card.name} className="w-32 h-44 object-cover rounded-lg border border-gray-700 mb-2 cursor-pointer" onClick={() => handleCardClick(card.imageUrl)} onError={(e) => { e.target.src = "https://placehold.co/128x176/444/bbb?text=Errore"; }} />
                                    <p className="text-gray-300 text-sm font-semibold text-center">{card.name}</p>
                                    <div className="flex items-center mt-2 space-x-2">
                                        <button onClick={() => onUpdateZainoCardQuantity(card.id, -1)} className="btn-theme btn-red px-2 py-0.5 text-base" disabled={card.quantity <= 1}>-</button>
                                        <span className="text-white text-lg font-bold">Qtà: {card.quantity}</span>
                                        <button onClick={() => onUpdateZainoCardQuantity(card.id, 1)} className="btn-theme btn-green px-2 py-0.5 text-base">+</button>
                                    </div>
                                    {isTonic && (
                                        <button 
                                            onClick={() => onUseEvolutionTonic(card.id)} 
                                            className="btn-theme btn-cyan text-sm mt-2 px-3 py-1 disabled:opacity-50"
                                            disabled={!isMyTurn || hasUsedTonicThisTurn}
                                        >
                                            Usa
                                        </button>
                                    )}
                                    <button onClick={() => onDeleteZainoCard(card.id)} className="btn-theme btn-gray text-xs mt-2 px-3 py-1">Rimuovi</button>
                                </div>
                                );
                            })}
                        </div>
                    )}
                    <ZoomModal isOpen={showZoomModal} imageUrl={zoomImageUrl} onClose={() => setShowZoomModal(false)} />
                    <SelectFromTrainersCardDatabaseModal isOpen={showAddTrainerCardModal} onClose={() => setShowAddTrainerCardModal(false)} onSelectTrainerCard={(card) => { onAddCardToZaino(card); setShowAddTrainerCardModal(false); }} cardsData={trainersCardDbCards} isLoading={isDbLoading} error={dbError} />
                </div>
            );
        }


        function CoinFlipper() {
            const [numCoins, setNumCoins] = React.useState(1);
            const [results, setResults] = React.useState([]);
            
            const handleFlip = () => {
                setResults(Array.from({ length: numCoins }, () => Math.random() < 0.5 ? 'Testa' : 'Croce'));
            };


            return (
                <div className="bg-gray-800 p-4 rounded-xl shadow-2xl flex flex-col items-center border-4 border-yellow-400 gap-4 flex-1 max-w-xs w-full mb-4">
                    <h2 className="text-lg font-bold text-yellow-300">LANCIO MONETE</h2>
                    <div className="flex items-center space-x-2">
                        <label className="counter-label text-white text-sm">N°:</label>
                        <select value={numCoins} onChange={(e) => setNumCoins(parseInt(e.target.value))} className="bg-gray-700 text-white rounded-md p-1 text-sm border border-gray-600">
                            {[1, 2, 3, 4, 5].map(num => (<option key={num} value={num}>{num}</option>))}
                        </select>
                    </div>
                    <button onClick={handleFlip} className="btn-theme btn-yellow text-base px-3 py-1 w-full">Lancia</button>
                    {results.length > 0 && <div className="mt-4 flex flex-wrap justify-center gap-2 text-xl font-bold">{results.map((r, i) => (<span key={i} className={`px-3 py-1 rounded-full text-white ${r === 'Testa' ? 'bg-green-600' : 'bg-red-600'}`}>🪙 {r[0]}</span>))}</div>}
                </div>
            );
        }


        function GlobalEventBanner({ isVisible, message, type }) {
            if (!isVisible) return null;
            const typeClasses = {
                'attack_success': 'bg-green-700 border-green-400',
                'status_woke_up': 'bg-green-700 border-green-400', 'retreat_success': 'bg-green-700 border-green-400', 'capture_success': 'bg-green-700 border-green-400', 'attack_critical': 'bg-green-700 border-green-400', 'confusion_miss': 'bg-green-700 border-green-400', 'purchase_success': 'bg-green-700 border-green-400',
                'status_cleared': 'bg-blue-700 border-blue-400', 'info': 'bg-blue-700 border-blue-400',
                'damage_burn': 'bg-red-700 border-red-400', 'damage_poison': 'bg-red-700 border-red-400', 'attack_failed': 'bg-red-700 border-red-400', 'retreat_failed': 'bg-red-700 border-red-400', 'capture_fail': 'bg-red-700 border-red-400', 'confusion_hit': 'bg-red-700 border-red-400', 'purchase_fail': 'bg-red-700 border-red-400',
            };
            return <div className={`fixed top-0 left-1/2 -translate-x-1/2 w-11/12 max-w-lg p-4 mt-4 rounded-xl shadow-2xl text-center text-white font-extrabold text-2xl z-50 border-4 ${typeClasses[type] || 'bg-gray-700 border-gray-400'}`}>{message}</div>;
        }
        
        function TemporaryCardDisplay({ imageUrl }) {
            if (!imageUrl) return null;
            return (
                <div className="zoom-modal-overlay z-[2000] bg-opacity-98">
                    <div className="zoom-modal-content">
                        <img src={imageUrl} alt="Anteprima Carta" className="max-h-[80vh] max-w-[80vw] rounded-2xl border-4 border-yellow-400" />
                    </div>
                </div>
            );
        }


        function PrizePreviewDisplay({ prizeData }) {
            if (!prizeData) return null;
            return (
                <div className="zoom-modal-overlay z-[2000] bg-opacity-98">
                    <div className="flex flex-col items-center justify-center">
                        <h2 className="text-5xl font-extrabold text-yellow-300 mb-4 drop-shadow-lg">PREMIO!</h2>
                        <div className="flex space-x-4">
                            {prizeData.cards.map((card, index) => (
                                <img key={index} src={card.imageUrl} alt={`Premio ${index + 1}`} className="h-[50vh] max-h-[350px] rounded-lg border-3 border-yellow-400" />
                            ))}
                        </div>
                        <h3 className="text-4xl font-bold text-green-400 mt-4 drop-shadow-md">+{prizeData.currency} $</h3>
                    </div>
                </div>
            );
        }


        function DefeatPreviewDisplay({ defeatData }) {
            if (!defeatData) return null;
            return (
                <div className="zoom-modal-overlay z-[2000] bg-opacity-98">
                    <div className="flex flex-col items-center justify-center">
                        <h2 className="text-5xl font-extrabold text-red-500 mb-4 drop-shadow-lg">{defeatData.type === 'fuga' ? 'FUGA!' : 'SCONFITTA'}</h2>
                        <h3 className="text-4xl font-bold text-red-400 mt-4 drop-shadow-md">-{defeatData.currency} $</h3>
                    </div>
                </div>
            );
        }


        function VictoryDefeatModal({ isOpen, onClose, onVictoryClick, onDefeatClick }) {
            const [outcome, setOutcome] = React.useState(null);
            React.useEffect(() => { if (!isOpen) setOutcome(null); }, [isOpen]);
            if (!isOpen) return null;


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-yellow-400 flex flex-col items-center w-full max-w-md">
                        <h2 className="text-3xl font-bold text-yellow-300 mb-6 text-center">{outcome ? (outcome === 'victory' ? 'Vittoria!' : 'Sconfitta') : 'Seleziona Esito'}</h2>
                        {!outcome ? (
                            <div className="flex space-x-4">
                                <button onClick={() => setOutcome('victory')} className="btn-theme btn-green px-8 py-4 text-2xl">Vittoria</button>
                                <button onClick={() => setOutcome('defeat')} className="btn-theme btn-red px-8 py-4 text-2xl">Sconfitta</button>
                            </div>
                        ) : outcome === 'victory' ? (
                            <div className="flex flex-col space-y-3 w-full">
                                <button onClick={() => onVictoryClick({ currency: 1, prizes: 0, exp: 1 })} className="btn-theme btn-blue w-full">Cattura Pokemon Selvatico</button>
                                <button onClick={() => onVictoryClick({ currency: 1, prizes: 1, exp: 1 })} className="btn-theme btn-blue w-full">Sconfitta Pokemon Selvatico</button>
                                <button onClick={() => onVictoryClick({ currency: 2, prizes: 1, exp: 1 })} className="btn-theme btn-blue w-full">Vittoria vs Allenatore</button>
                                <button onClick={() => onVictoryClick({ currency: 4, prizes: 2, exp: 2 })} className="btn-theme btn-blue w-full">Vittoria vs Palestra/Superquattro</button>
                                <button onClick={() => onVictoryClick({ currency: 8, prizes: 2, exp: 2 })} className="btn-theme btn-blue w-full">Vittoria vs Altro Giocatore</button>
                            </div>
                        ) : (
                            <div className="flex flex-col space-y-3 w-full">
                                <button onClick={() => onDefeatClick({ currency: 2, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Allenatore</button>
                                <button onClick={() => onDefeatClick({ currency: 3, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Palestra/Superquattro</button>
                                <button onClick={() => onDefeatClick({ currency: 6, type: 'sconfitta' })} className="btn-theme btn-purple w-full">Sconfitta vs Altro Giocatore</button>
                                <button onClick={() => onDefeatClick({ currency: 1, type: 'fuga' })} className="btn-theme btn-gray w-full">Fuga</button>
                            </div>
                        )}
                        <button onClick={() => outcome ? setOutcome(null) : onClose()} className="btn-theme btn-gray mt-8 px-6 py-2 text-lg">{outcome ? 'Indietro' : 'Annulla'}</button>
                    </div>
                </div>
            );
        }
        
        function AssignExpModal({ isOpen, onClose, onConfirm, cards }) {
            const [selectedIndices, setSelectedIndices] = React.useState([]);
            const toggleIndex = (index) => setSelectedIndices(p => p.includes(index) ? p.filter(i => i !== index) : [...p, index]);
            React.useEffect(() => { if (!isOpen) setSelectedIndices([]); }, [isOpen]);
            if (!isOpen) return null;


            const participatingPokemon = cards.map((card, index) => ({ card, index })).filter(item => item.card?.baseHp > 0);


            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-blue-400 flex flex-col items-center w-full max-w-2xl">
                        <h2 className="text-3xl font-bold text-blue-300 mb-6">Assegna Punti Esperienza</h2>
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full mb-6">
                            {participatingPokemon.map(({ card, index }) => (
                                <div key={index} className={`relative p-2 rounded-lg cursor-pointer ${selectedIndices.includes(index) ? 'bg-blue-700 ring-4 ring-blue-400' : 'bg-gray-700'}`} onClick={() => toggleIndex(index)}>
                                    <img src={card.imageUrl} alt={`Pokemon ${index + 1}`} className="w-24 h-32 object-cover rounded-md mx-auto" />
                                    {selectedIndices.includes(index) && <div className="absolute top-1 right-1 w-6 h-6 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>}
                                </div>
                            ))}
                        </div>
                        <button onClick={() => { onConfirm(selectedIndices); onClose(); }} className="btn-theme btn-green px-8 py-3 text-xl">Conferma</button>
                    </div>
                </div>
            );
        }


        function MovementModal({ isOpen, onClose, onRoll }) {
            if (!isOpen) return null;
            return (
                <div className="zoom-modal-overlay">
                    <div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-cyan-400 flex flex-col items-center w-full max-w-md">
                        <h2 className="text-3xl font-bold text-cyan-300 mb-6">Movimento</h2>
                        <p className="text-white text-lg mb-6">Usi la bici?</p>
                        <div className="flex space-x-4">
                            <button onClick={() => onRoll(true)} className="btn-theme btn-green px-8 py-3 text-xl">Sì</button>
                            <button onClick={() => onRoll(false)} className="btn-theme btn-red px-8 py-3 text-xl">No</button>
                        </div>
                        <button onClick={onClose} className="btn-theme btn-gray mt-8 px-6 py-2 text-lg">Annulla</button>
                    </div>
                </div>
            );
        }


        function MovementResultDisplay({ result }) {
            if (!result) return null;
            return (
                <div className="zoom-modal-overlay z-[2000] bg-opacity-98">
                    <div className="flex flex-col items-center justify-center text-white text-9xl">{diceFaces[result] || result}</div>
                </div>
            );
        }


        // Componenti App (PlayerApp, MasterApp)
        function PlayerApp({ onSwitchRole, displayGlobalBanner, clearGlobalBanner, showTemporaryCard, showPrizePreview, showDefeatPreview, showMovementResultPreview }) {
            const rolePrefix = 'player';
            const useLocalStorageState = (key, defaultValue) => {
                const [state, setState] = React.useState(() => {
                    try {
                        const item = localStorage.getItem(key);
                        return item ? JSON.parse(item) : defaultValue;
                    } catch (error) {
                        return defaultValue;
                    }
                });
                React.useEffect(() => {
                    localStorage.setItem(key, JSON.stringify(state));
                }, [key, state]);
                return [state, setState];
            };


            const [cards, setCards] = useLocalStorageState(`${rolePrefix}_gameCards`, Array(6).fill(null));
            const [boxCards, setBoxCards] = useLocalStorageState(`${rolePrefix}_pokemonBoxCards`, []);
            const [playerZainoCards, setPlayerZainoCards] = useLocalStorageState(`${rolePrefix}_playerZainoCards`, []);
            const [globalCurrency, setGlobalCurrency] = useLocalStorageState(`${rolePrefix}_globalCurrency`, 0);
            const [gymMedals, setGymMedals] = useLocalStorageState(`${rolePrefix}_gymMedals`, Array(8).fill(false));
            const [eliteFourMedals, setEliteFourMedals] = useLocalStorageState(`${rolePrefix}_eliteFourMedals`, Array(4).fill(false));
            const [isMyTurn, setIsMyTurn] = useLocalStorageState(`${rolePrefix}_isMyTurn`, false);
            const [playerOverallExp, setPlayerOverallExp] = useLocalStorageState(`${rolePrefix}_playerOverallExp`, 0);
            const [wildPokemonHpStatus, setWildPokemonHpStatus] = useLocalStorageState(`${rolePrefix}_wildPokemonHpStatus`, 'green');
            const [hasUsedTonicThisTurn, setHasUsedTonicThisTurn] = useLocalStorageState(`${rolePrefix}_hasUsedTonicThisTurn`, false);
            const [selectedBall, setSelectedBall] = useLocalStorageState(`${rolePrefix}_selectedBall`, null);
            const [isTonicEvolveActive, setIsTonicEvolveActive] = useLocalStorageState(`${rolePrefix}_isTonicEvolveActive`, false);
            const [pendingExpAmount, setPendingExpAmount] = useLocalStorageState(`${rolePrefix}_pendingExpAmount`, 0);


            const [negozioCards, setNegozioCards] = React.useState([]);
            const [pokemonDbCards, setPokemonDbCards] = React.useState([]);
            const [trainersDbCards, setTrainersDbCards] = React.useState([]);
            const [palestreDbCards, setPalestreDbCards] = React.useState([]);
            const [trainersCardDbCards, setTrainersCardDbCards] = React.useState([]);
            const [isDbLoading, setIsDbLoading] = React.useState(true);
            const [dbError, setDbError] = React.useState(null);
            
            const [currentView, setCurrentView] = React.useState('main');
            const [showVictoryDefeatModal, setShowVictoryDefeatModal] = React.useState(false);
            const [showAssignExpModal, setShowAssignExpModal] = React.useState(false);
            const [pendingPrize, setPendingPrize] = React.useState(null);
            const [showMovementModal, setShowMovementModal] = React.useState(false);
            const [showClearConfirm, setShowClearConfirm] = React.useState(false);
            const [showCaptureCoinFlipModal, setShowCaptureCoinFlipModal] = React.useState(false);
            const [captureCoinFlipResult, setCaptureCoinFlipResult] = React.useState(null);
            const [captureFinalOutcome, setCaptureFinalOutcome] = React.useState(null);
            const [showSelectBallModal, setShowSelectBallModal] = React.useState(false);
            const [isHealingModalOpen, setIsHealingModalOpen] = React.useState(false);
            const [healingTargetSlot, setHealingTargetSlot] = React.useState(null);


            React.useEffect(() => {
                async function getSupabaseData() {
                    try {
                        setIsDbLoading(true);
                        const tables = ['pokemon_cards', 'pokemon_allenatori', 'palestre', 'trainers_card', 'negozio'];
                        const promises = tables.map(table => supabase.from(table).select('*'));
                        const [pokemonRes, allenatoriRes, palestreRes, trainersCardRes, negozioRes] = await Promise.all(promises);


                        if (pokemonRes.error) throw pokemonRes.error;
                        setPokemonDbCards(pokemonRes.data.map(c => ({...c, baseHp: c.hp, imageUrl: c.image_url})));
                        if (allenatoriRes.error) throw allenatoriRes.error;
                        setTrainersDbCards(allenatoriRes.data.map(c => ({...c, imageUrl: c.image_url})));
                        if (palestreRes.error) throw palestreRes.error;
                        setPalestreDbCards(palestreRes.data.map(c => ({...c, imageUrl: c.image_url})));
                        if (trainersCardRes.error) throw trainersCardRes.error;
                        setTrainersCardDbCards(trainersCardRes.data.map(c => ({...c, imageUrl: c.image_url})));
                        if (negozioRes.error) throw negozioRes.error;
                        setNegozioCards(negozioRes.data.map(c => ({...c, imageUrl: c.image_url, baseHp: c.base_hp})));
                        
                    } catch (err) {
                        setDbError(err.message);
                        setPokemonDbCards(localPokemonCardsDatabase); // Fallback
                    } finally {
                        setIsDbLoading(false);
                    }
                }
                getSupabaseData();
            }, []);


            const updateCardInSlot = (index, cardData) => setCards(p => { const n = [...p]; n[index] = cardData; return n; });
            const handleActivePokemonToggle = (clickedSlotIndex) => {
                const active = cards.find(c => c?.isActivePokemon);
                if (isMyTurn && active?.statuses[3]) {
                    displayGlobalBanner("Pokémon Paralizzato non può essere sostituito!", 'info');
                    return;
                }
                setCards(p => p.map((c, i) => c ? { ...c, isActivePokemon: i === clickedSlotIndex ? !c.isActivePokemon : false, statuses: Array(5).fill(false) } : null));
            };
            
            const toggleMyTurn = React.useCallback(() => {
                clearGlobalBanner();
                setHasUsedTonicThisTurn(false);
                setIsTonicEvolveActive(false);
                setSelectedBall(null);
                setIsMyTurn(prev => {
                    const newTurn = !prev;
                    const active = cards.find(c => c?.isActivePokemon);
                    if (active) {
                        if (!newTurn && active.statuses[3]) { // Paralysis wears off at end of turn
                            setCards(p => p.map(c => c?.isActivePokemon ? {...c, statuses: [c.statuses[0], c.statuses[1], c.statuses[2], false, c.statuses[4]]} : c));
                            displayGlobalBanner("Non più paralizzato!", 'status_cleared');
                        }
                        if (active.statuses[0] && Math.random() < 0.5) { // 50% chance to wake up
                            setCards(p => p.map(c => c?.isActivePokemon ? {...c, statuses: [false, c.statuses[1], c.statuses[2], c.statuses[3], c.statuses[4]]} : c));
                            displayGlobalBanner("Si è svegliato!", 'status_woke_up');
                        }
                        if (newTurn && active.statuses[1]) { // Burn damage at start of turn
                            setCards(p => p.map(c => c?.isActivePokemon ? {...c, damageTaken: c.damageTaken + 20} : c));
                            displayGlobalBanner("Danni da bruciatura!", 'damage_burn');
                        }
                        if (newTurn && active.statuses[4]) { // Poison damage at start of turn
                            setCards(p => p.map(c => c?.isActivePokemon ? {...c, damageTaken: c.damageTaken + 10} : c));
                            displayGlobalBanner("Danni da veleno!", 'damage_poison');
                        }
                    }
                    return newTurn;
                });
            }, [cards, clearGlobalBanner, displayGlobalBanner, setCards, setIsMyTurn]);
            
            const handleConfusedRollAttempt = React.useCallback(() => {
                const result = Math.random() < 0.5; // true = success, false = fail
                if (!result) {
                    setCards(p => p.map(c => c?.isActivePokemon ? { ...c, damageTaken: c.damageTaken + 30 } : c));
                    displayGlobalBanner("Confusione: Colpito da solo!", 'confusion_hit');
                    setTimeout(toggleMyTurn, 2000);
                } else {
                    displayGlobalBanner("Confusione: Attacco riuscito!", 'confusion_miss');
                }
                return result;
            }, [cards, displayGlobalBanner, setCards, toggleMyTurn]);
            
            const handleCaptureCoinFlipNeeded = () => { setShowCaptureCoinFlipModal(true); setCaptureCoinFlipResult(null); setCaptureFinalOutcome(null); };
            const performCaptureCoinFlip = () => {
                const result = Math.random() < 0.5 ? 'testa' : 'croce';
                setCaptureCoinFlipResult(result);
                const final = result === 'croce' ? 'PRESO' : 'FALLITA';
                setCaptureFinalOutcome(final);
                displayGlobalBanner(final === 'PRESO' ? 'Pokémon Catturato!' : 'Cattura Fallita!', final === 'PRESO' ? 'capture_success' : 'capture_fail');
                setTimeout(() => { setShowCaptureCoinFlipModal(false); toggleMyTurn(); }, 2000); 
            };


            const sendCardToBox = (card, slot) => { setBoxCards(p => [...p, card]); updateCardInSlot(slot, null); };
            const recallCardFromBox = (card, slot, boxIndex, delOnly) => {
                if (!delOnly) updateCardInSlot(slot, {...card, damageTaken: 0, statuses: Array(5).fill(false), isActivePokemon: false});
                setBoxCards(p => p.filter((_, i) => i !== boxIndex));
            };
            const deleteCardFromBox = (index) => setBoxCards(p => p.filter((_, i) => i !== index));
            
            const addCardToZaino = (card, isPrize = false) => {
                if (!isPrize && globalCurrency < card.cost) { displayGlobalBanner(`Non hai abbastanza soldi!`, 'purchase_fail'); return; }
                if (!isPrize) setGlobalCurrency(p => p - card.cost);
                setPlayerZainoCards(p => {
                    const existing = p.find(c => c.id === card.id);
                    return existing ? p.map(c => c.id === card.id ? {...c, quantity: c.quantity + 1} : c) : [...p, {...card, quantity: 1}];
                });
                if (!isPrize) displayGlobalBanner(`Hai acquistato ${card.name}!`, 'purchase_success');
            };
            const updateZainoCardQuantity = (id, amount) => {
                setPlayerZainoCards(p => {
                    const card = p.find(c => c.id === id);
                    if (amount > 0) {
                        const cardCost = trainersCardDbCards.find(db => db.id === id)?.cost || 0;
                        if (globalCurrency < cardCost) { displayGlobalBanner(`Non hai abbastanza soldi!`, 'purchase_fail'); return p; }
                        setGlobalCurrency(curr => curr - cardCost);
                        displayGlobalBanner(`Acquistata un'altra copia!`, 'purchase_success');
                    }
                    return p.map(c => c.id === id ? {...c, quantity: c.quantity + amount} : c).filter(c => c.quantity > 0);
                });
            };
            const onDeleteZainoCard = (id) => setPlayerZainoCards(p => p.filter(c => c.id !== id));
            
            const handleSelectBallForCapture = (ballId) => {
                const card = playerZainoCards.find(c => c.id === ballId);
                if (card) {
                    const cardNameLower = card.name.toLowerCase();

                    setPlayerZainoCards(prev => {
                        return prev.map(c =>
                            c.id === ballId ? { ...c, quantity: c.quantity - 1 } : c
                        ).filter(c => c.quantity > 0);
                    });
                    setShowSelectBallModal(false);

                    if (cardNameLower.includes('master ball')) {
                        displayGlobalBanner('Pokémon Catturato!', 'capture_success');
                        setTimeout(toggleMyTurn, 2000);
                    } else {
                        displayGlobalBanner(`${card.name} selezionata!`, 'info');
                        setSelectedBall(cardNameLower);
                    }
                }
            };


            const handleOpenHealingModal = (slotIndex) => {
                setHealingTargetSlot(slotIndex);
                setIsHealingModalOpen(true);
            };


            const handleUseHealingItem = (item, targetSlot) => {
                setIsHealingModalOpen(false);
                const itemName = item.name.toLowerCase();
                const cardToUpdate = cards[targetSlot];
                if (!cardToUpdate) return;
                const currentHp = cardToUpdate.baseHp - cardToUpdate.damageTaken;

                let itemUsed = false;

                if (itemName.includes('revitalizzante')) {
                    if (currentHp > 0) {
                        displayGlobalBanner("Puoi usare i Revitalizzanti solo su Pokémon esausti!", 'info');
                        return;
                    }
                    if (itemName.includes('max')) {
                        setCards(prev => {
                            const newCards = [...prev];
                            newCards[targetSlot] = { ...newCards[targetSlot], damageTaken: 0 };
                            return newCards;
                        });
                    } else {
                        setCards(prev => {
                            const newCards = [...prev];
                            const halfHealth = Math.floor(newCards[targetSlot].baseHp / 2);
                            const roundedHealth = Math.floor(halfHealth / 10) * 10;
                            newCards[targetSlot] = { ...newCards[targetSlot], damageTaken: newCards[targetSlot].baseHp - roundedHealth };
                            return newCards;
                        });
                    }
                    itemUsed = true;
                } else if (itemName.includes('cura totale')) {
                     if (currentHp <= 0) {
                        displayGlobalBanner("Non puoi usare questo su un Pokémon esausto!", 'info');
                        return;
                    }
                    setCards(prev => {
                        const newCards = [...prev];
                        if (newCards[targetSlot]) {
                            newCards[targetSlot] = { ...newCards[targetSlot], statuses: Array(5).fill(false) };
                        }
                        return newCards;
                    });
                    itemUsed = true;
                } else if (itemName.includes('pozione')) {
                    if (currentHp <= 0) {
                        displayGlobalBanner("Non puoi curare un Pokémon esausto con questo!", 'info');
                        return;
                    }
                    const cardToHeal = trainersCardDbCards.find(c => c.id === item.id);
                    const healAmount = cardToHeal ? cardToHeal.cura : 0;
                    setCards(prev => {
                        const newCards = [...prev];
                        if (newCards[targetSlot]) {
                            newCards[targetSlot] = { ...newCards[targetSlot], damageTaken: Math.max(0, newCards[targetSlot].damageTaken - healAmount) };
                        }
                        return newCards;
                    });
                    itemUsed = true;
                } else if (itemName.includes('caramella')) {
                     setCards(prev => {
                        const newCards = [...prev];
                        if (newCards[targetSlot]) {
                            newCards[targetSlot] = { ...newCards[targetSlot], exp: Math.min(6, newCards[targetSlot].exp + 1) };
                        }
                        return newCards;
                    });
                    itemUsed = true;
                }

                if (itemUsed) {
                    setPlayerZainoCards(prev => 
                        prev.map(card => 
                            card.id === item.id ? { ...card, quantity: card.quantity - 1 } : card
                        ).filter(card => card.quantity > 0)
                    );
                    displayGlobalBanner(`${item.name} usata!`, 'info');
                }
            };

            const handleUseEvolutionTonic = (cardId) => {
                if (hasUsedTonicThisTurn) {
                    displayGlobalBanner("Puoi usare un solo tonico per turno!", 'info');
                    return;
                }

                const card = playerZainoCards.find(c => c.id === cardId);
                if (card && card.name.toLowerCase().includes('tonico evolutivo')) {
                    displayGlobalBanner("Scegli un Pokémon da evolvere!", 'info');
                    setHasUsedTonicThisTurn(true);
                    setIsTonicEvolveActive(true);
                    setPlayerZainoCards(prev => {
                        return prev.map(c =>
                            c.id === cardId ? { ...c, quantity: c.quantity - 1 } : c
                        ).filter(c => c.quantity > 0);
                    });
                    setCurrentView('main');
                }
            };


            const handleVictory = ({ currency, prizes, exp }) => {
                setShowVictoryDefeatModal(false);
                setPlayerOverallExp(p => Math.min(15, p + 1));
                setGlobalCurrency(p => p + currency);
                setPendingExpAmount(exp);
                if (prizes > 0 && trainersCardDbCards.length > 0) {
                    const prizeCards = Array.from({ length: prizes }, () => trainersCardDbCards[Math.floor(Math.random() * trainersCardDbCards.length)]);
                    setPendingPrize(prizeCards);
                    showPrizePreview(prizeCards, currency, () => setShowAssignExpModal(true));
                } else {
                    setShowAssignExpModal(true);
                }
            };
            const handleConfirmExpAssignment = (selectedIndices) => {
                setCards(p => p.map((c, i) => (selectedIndices.includes(i) && c) ? { ...c, exp: Math.min(6, c.exp + pendingExpAmount) } : c));
                if (pendingPrize) {
                    pendingPrize.forEach(card => addCardToZaino(card, true));
                    setPendingPrize(null);
                }
                setShowAssignExpModal(false);
                setPendingExpAmount(0);
            };
            const handleDefeat = ({ currency, type }) => {
                setGlobalCurrency(p => Math.max(0, p - currency));
                showDefeatPreview(type, currency, () => setShowVictoryDefeatModal(false));
            };
            const handleMovementRoll = (isBiking) => {
                setShowMovementModal(false);
                showMovementResultPreview(isBiking ? Math.floor(Math.random() * 6) + 1 : Math.floor(Math.random() * 3) + 1);
            };
            
            const handlePalestreCardSelection = (palestreCard, wasBoardEmpty) => {
                const trainer1 = trainersDbCards.find(c => c.name === `${palestreCard.name}-1`);
                const trainer2 = trainersDbCards.find(c => c.name === `${palestreCard.name}-2`);
                updateCardInSlot(0, trainer1 ? {...trainer1, baseHp: trainer1.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: wasBoardEmpty } : null);
                updateCardInSlot(1, trainer2 ? {...trainer2, baseHp: trainer2.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false } : null);
            };


            const fetchRandomCardFromTable = async (tableName) => {
                const wasBoardEmpty = cards.every(c => c === null);
                try {
                    const { count, error: countError } = await supabase.from(tableName).select('*', { count: 'exact', head: true });
                    if (countError || count === 0) throw new Error(`Tabella '${tableName}' vuota o non trovata.`);
                    const randomIndex = Math.floor(Math.random() * count);
                    const { data, error } = await supabase.from(tableName).select('*, hp, tipo').range(randomIndex, randomIndex);
                    if (error || !data || data.length === 0) throw new Error("Nessuna carta trovata.");
                    
                    const randomCard = data[0];
                    showTemporaryCard(randomCard.image_url, () => {
                        if (randomCard.tipo === 'a') {
                            handlePalestreCardSelection(randomCard, wasBoardEmpty);
                        } else {
                            updateCardInSlot(0, { imageUrl: randomCard.image_url, baseHp: randomCard.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: randomCard.exp || 0, isActivePokemon: wasBoardEmpty });
                        }
                    });
                } catch (error) {
                    displayGlobalBanner(`Errore: ${error.message}`, 'purchase_fail');
                    throw error;
                }
            };
            
            const handleFullReset = () => {
                setCards(Array(6).fill(null));
                setBoxCards([]);
                setPlayerZainoCards([]);
                setGlobalCurrency(0);
                setGymMedals(Array(8).fill(false));
                setEliteFourMedals(Array(4).fill(false));
                setPlayerOverallExp(0);
                setShowClearConfirm(false);
            };


            const activeCardForDice = cards.find(c => c?.isActivePokemon);
            const diceRollDisableStatus = activeCardForDice ? (activeCardForDice.statuses[0] ? 'asleep' : (activeCardForDice.statuses[2] ? 'confused' : (activeCardForDice.statuses[3] ? 'paralyzed' : false))) : false;
            const getOverallExpDotColorClass = (i) => {
                if (i >= playerOverallExp) return '';
                if (i <= 2) return 'active-pink'; if (i <= 5) return 'active-green-total'; if (i <= 8) return 'active-blue-total'; if (i <= 11) return 'active-yellow-total'; return 'active-red-total';
            };


            return (
                <>
                    {currentView === 'main' ? (
                        <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-green-600 to-blue-700 p-4">
                            <h1 className="text-5xl font-extrabold text-white mb-8 text-center drop-shadow-lg">POKÉMON DUEL (PLAYER)</h1>
                            <button onClick={() => onSwitchRole('master')} className="btn-theme btn-gray px-6 py-3 text-lg mb-4">Passa a Master</button>
                            <div className="w-full max-w-xs flex flex-col items-center p-4 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 z-10 mb-4">
                                <div className="flex flex-col items-center mb-4 w-full">
                                    <h3 className="text-xl font-bold text-yellow-300 mb-2">EXP Totali</h3>
                                    <div className="flex items-center space-x-2 mb-2">
                                        <button onClick={() => setPlayerOverallExp(p => Math.max(0, p-1))} className="btn-theme btn-red px-2 py-0.5 text-xl">-</button>
                                        <div className="flex flex-wrap justify-center gap-1 w-48">{[...Array(15)].map((_, i) => (<div key={i} className={`exp-dot ${getOverallExpDotColorClass(i)}`}></div>))}</div>
                                        <button onClick={() => setPlayerOverallExp(p => Math.min(15, p+1))} className="btn-theme btn-green px-2 py-0.5 text-xl">+</button>
                                    </div>
                                    <span className="text-xl font-bold text-white">{playerOverallExp}/15</span>
                                </div>
                                <div className="flex items-center justify-center space-x-4 mb-4">
                                    <TurnIndicator isMyTurn={isMyTurn} onToggleTurn={toggleMyTurn} />
                                    <button onClick={() => setShowMovementModal(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md border-4 bg-cyan-500 border-cyan-700 hover:scale-105 active:scale-95" title="Movimento">🎲</button>
                                </div>
                                <CoinFlipper />
                                <DiceRoller title="ATTACCA" isAttackRoller={true} isDiceRollDisabled={diceRollDisableStatus} onConfusedRollAttempt={handleConfusedRollAttempt} isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                                <DiceRoller title="RITIRATA" isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                                <DiceRoller 
                                    title="CATTURA" 
                                    isCaptureRoller={true} 
                                    isMyTurn={isMyTurn} 
                                    onDiceRollComplete={() => {}} 
                                    onCaptureCoinFlipNeeded={handleCaptureCoinFlipNeeded} 
                                    onDisplayGlobalBanner={displayGlobalBanner} 
                                    wildPokemonHpStatus={wildPokemonHpStatus}
                                    onWildPokemonHpChange={setWildPokemonHpStatus}
                                    role="player"
                                    onOpenSelectBallModal={() => setShowSelectBallModal(true)}
                                    selectedBall={selectedBall}
                                />
                                <div className="bg-yellow-400 p-2 rounded-full shadow-lg flex items-center justify-center border-4 border-yellow-700 w-full max-w-xs mt-4">
                                    <span className="text-xl font-extrabold text-gray-800 mr-1">$</span>
                                    <button onClick={() => setGlobalCurrency(p => Math.max(0, p-1))} className="btn-theme btn-red px-2 py-0.5 text-base">-</button>
                                    <input type="number" value={globalCurrency} onChange={(e) => setGlobalCurrency(parseInt(e.target.value) || 0)} className="w-16 px-1 py-0.5 bg-yellow-200 border-2 border-yellow-600 rounded-lg text-center text-gray-900 font-extrabold text-base mx-1" min="0" />
                                    <button onClick={() => setGlobalCurrency(p => p+1)} className="btn-theme btn-green px-2 py-0.5 text-base">+</button>
                                </div>
                                <button onClick={() => setCurrentView('box')} className="btn-theme btn-purple px-6 py-3 text-lg mt-4">BOX ({boxCards.length})</button>
                                <button onClick={() => setCurrentView('zaino')} className="btn-theme btn-orange px-6 py-3 text-lg mt-4">ZAINO ({playerZainoCards.length})</button>
                                <button onClick={() => setShowVictoryDefeatModal(true)} className="btn-theme btn-yellow px-6 py-3 text-lg mt-4">Vittoria/Sconfitta</button>
                            </div>
                            <VictoryDefeatModal isOpen={showVictoryDefeatModal} onClose={() => setShowVictoryDefeatModal(false)} onVictoryClick={handleVictory} onDefeatClick={handleDefeat} />
                            <AssignExpModal isOpen={showAssignExpModal} onClose={() => setShowAssignExpModal(false)} onConfirm={handleConfirmExpAssignment} cards={cards} />
                            <MovementModal isOpen={showMovementModal} onClose={() => setShowMovementModal(false)} onRoll={handleMovementRoll} />
                            <CaptureCoinFlipModal isOpen={showCaptureCoinFlipModal} onFlipCoin={performCaptureCoinFlip} coinResult={captureCoinFlipResult} finalOutcome={captureFinalOutcome} />
                            <SelectBallModal 
                                isOpen={showSelectBallModal}
                                onClose={() => setShowSelectBallModal(false)}
                                zainoCards={playerZainoCards}
                                onUseBall={handleSelectBallForCapture}
                            />
                            <HealingItemModal 
                                isOpen={isHealingModalOpen}
                                onClose={() => setIsHealingModalOpen(false)}
                                zainoCards={playerZainoCards}
                                onUseItem={handleUseHealingItem}
                                targetSlot={healingTargetSlot}
                            />
                            <div className="grid grid-cols-1 gap-8 w-full max-w-xs mt-8 pb-8"> 
                                {cards.map((card, i) => <CardSlot key={i} slotIndex={i} cardData={card} onUpdateCard={updateCardInSlot} onToggleActivePokemon={handleActivePokemonToggle} isMyTurn={isMyTurn} activeCardParalyzed={diceRollDisableStatus === 'paralyzed'} onSendToBox={sendCardToBox} onRecallFromBox={recallCardFromBox} boxCards={boxCards} pokemonDbCards={pokemonDbCards} trainersDbCards={trainersDbCards} palestreDbCards={palestreDbCards} isDbLoading={isDbLoading} dbError={dbError} onSelectTableAndFetchRandom={fetchRandomCardFromTable} onSelectPalestreCard={handlePalestreCardSelection} role="player" showTemporaryCard={showTemporaryCard} isBoardEmpty={cards.every(c => !c)} onOpenHealingModal={handleOpenHealingModal} isTonicEvolveActive={isTonicEvolveActive} onEvolutionComplete={() => setIsTonicEvolveActive(false)} />)}
                            </div>
                            <div className="w-full flex justify-center mt-8"><MedalDisplay gymMedals={gymMedals} onToggleMedal={(i) => setGymMedals(p => {const n=[...p]; n[i]=!n[i]; return n;})} /></div>
                            <div className="w-full flex justify-center mt-4"><HMDisplay gymMedals={gymMedals} /></div>
                            <div className="w-full flex justify-center mt-8 pb-20"><EliteFourDisplay eliteFourMedals={eliteFourMedals} onToggleMedal={(i) => setEliteFourMedals(p => {const n=[...p]; n[i]=!n[i]; return n;})} /></div>
                            <div className="w-full flex justify-center mt-8 pb-20"><button onClick={() => setShowClearConfirm(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md border-4 bg-red-600 border-red-800 hover:scale-105 active:scale-95" title="Resetta dati giocatore">🗑️</button></div>
                            {showClearConfirm && <div className="zoom-modal-overlay"><div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-red-500"><h3 className="text-2xl font-bold text-red-400 mb-6 text-center">Resettare tutti i dati del giocatore?</h3><div className="flex space-x-4"><button onClick={handleFullReset} className="btn-theme btn-red">Sì</button><button onClick={() => setShowClearConfirm(false)} className="btn-theme btn-gray">No</button></div></div></div>}
                        </div>
                    ) : currentView === 'box' ? <BoxView boxCards={boxCards} onBackToMain={() => setCurrentView('main')} onDeleteCardFromBox={deleteCardFromBox} role="player" />
                      : currentView === 'zaino' ? <ZainoView 
                            playerZainoCards={playerZainoCards} 
                            onBackToMain={() => setCurrentView('main')} 
                            onAddCardToZaino={addCardToZaino} 
                            onUpdateZainoCardQuantity={updateZainoCardQuantity} 
                            onDeleteZainoCard={onDeleteZainoCard} 
                            trainersCardDbCards={trainersCardDbCards} 
                            isDbLoading={isDbLoading} 
                            dbError={dbError}
                            onUseEvolutionTonic={handleUseEvolutionTonic}
                            isMyTurn={isMyTurn}
                            hasUsedTonicThisTurn={hasUsedTonicThisTurn}
                        />
                      : <NegozioView negozioCards={negozioCards} onBackToMain={() => setCurrentView('main')} isDbLoading={isDbLoading} dbError={dbError} />}
                </>
            );
        }
        
        function MasterApp({ onSwitchRole, displayGlobalBanner, clearGlobalBanner, showTemporaryCard }) {
            const rolePrefix = 'master';
            const useLocalStorageState = (key, defaultValue) => { /* ... same as PlayerApp ... */
                const [state, setState] = React.useState(() => JSON.parse(localStorage.getItem(key) ?? 'null') ?? defaultValue);
                React.useEffect(() => { localStorage.setItem(key, JSON.stringify(state)); }, [key, state]);
                return [state, setState];
            };


            const [cards, setCards] = useLocalStorageState(`${rolePrefix}_gameCards`, Array(6).fill(null));
            const [isMyTurn, setIsMyTurn] = useLocalStorageState(`${rolePrefix}_isMyTurn`, true);
            
            const [pokemonDbCards, setPokemonDbCards] = React.useState([]);
            const [trainersDbCards, setTrainersDbCards] = React.useState([]);
            const [palestreDbCards, setPalestreDbCards] = React.useState([]);
            const [isDbLoading, setIsDbLoading] = React.useState(true);
            const [dbError, setDbError] = React.useState(null);


            const [currentView, setCurrentView] = React.useState('main');
            const [showClearConfirm, setShowClearConfirm] = React.useState(false);


            React.useEffect(() => {
                async function getSupabaseData() { /* ... same as PlayerApp, minus negozio/trainers_card ... */
                    try {
                        setIsDbLoading(true);
                        const [pokemonRes, allenatoriRes, palestreRes] = await Promise.all([
                            supabase.from('pokemon_cards').select('*'),
                            supabase.from('pokemon_allenatori').select('*'),
                            supabase.from('palestre').select('*')
                        ]);
                        if (pokemonRes.error) throw pokemonRes.error;
                        setPokemonDbCards(pokemonRes.data.map(c => ({...c, baseHp: c.hp, imageUrl: c.image_url})));
                        if (allenatoriRes.error) throw allenatoriRes.error;
                        setTrainersDbCards(allenatoriRes.data.map(c => ({...c, imageUrl: c.image_url})));
                        if (palestreRes.error) throw palestreRes.error;
                        setPalestreDbCards(palestreRes.data.map(c => ({...c, imageUrl: c.image_url})));
                    } catch (err) {
                        setDbError(err.message);
                    } finally {
                        setIsDbLoading(false);
                    }
                }
                getSupabaseData();
            }, []);


            const updateCardInSlot = (index, cardData) => setCards(p => { const n = [...p]; n[index] = cardData; return n; });
            const handleActivePokemonToggle = (clickedSlotIndex) => setCards(p => p.map((c, i) => c ? { ...c, isActivePokemon: i === clickedSlotIndex ? !c.isActivePokemon : false, statuses: Array(5).fill(false) } : null));
            const toggleMyTurn = () => setIsMyTurn(p => !p);


            const handlePalestreCardSelection = (palestreCard, wasBoardEmpty) => {
                const trainer1 = trainersDbCards.find(c => c.name === `${palestreCard.name}-1`);
                const trainer2 = trainersDbCards.find(c => c.name === `${palestreCard.name}-2`);
                updateCardInSlot(0, trainer1 ? {...trainer1, baseHp: trainer1.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: wasBoardEmpty } : null);
                updateCardInSlot(1, trainer2 ? {...trainer2, baseHp: trainer2.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: false } : null);
            };


            const fetchRandomCardFromTable = async (tableName) => {
                const wasBoardEmpty = cards.every(c => c === null);
                try {
                    const { count, error: countError } = await supabase.from(tableName).select('*', { count: 'exact', head: true });
                    if (countError || count === 0) throw new Error(`Tabella '${tableName}' vuota.`);
                    const randomIndex = Math.floor(Math.random() * count);
                    const { data, error } = await supabase.from(tableName).select('*, hp, tipo').range(randomIndex, randomIndex);
                    if (error || !data || data.length === 0) throw new Error("Nessuna carta trovata.");
                    
                    const randomCard = data[0];
                    showTemporaryCard(randomCard.image_url, () => {
                        if (randomCard.tipo === 'a') {
                            handlePalestreCardSelection(randomCard, wasBoardEmpty);
                        } else {
                            updateCardInSlot(0, { imageUrl: randomCard.image_url, baseHp: randomCard.hp || 0, damageTaken: 0, statuses: Array(5).fill(false), exp: 0, isActivePokemon: wasBoardEmpty });
                        }
                    });
                } catch (error) {
                    displayGlobalBanner(`Errore: ${error.message}`, 'purchase_fail');
                    throw error;
                }
            };


            const activeCardForDice = cards.find(c => c?.isActivePokemon);
            const diceRollDisableStatus = activeCardForDice ? (activeCardForDice.statuses[3] ? 'paralyzed' : false) : false;


            return (
                <div className="min-h-screen flex flex-col items-center bg-gradient-to-br from-red-600 to-purple-700 p-4">
                    <h1 className="text-5xl font-extrabold text-white mb-8 text-center drop-shadow-lg">POKÉMON DUEL (MASTER)</h1>
                    <button onClick={() => onSwitchRole('player')} className="btn-theme btn-gray px-6 py-3 text-lg mb-4">Passa a Player</button>
                    <div className="w-full max-w-xs flex flex-col items-center p-4 bg-gray-800 rounded-xl shadow-lg border-4 border-yellow-400 z-10 mb-4">
                        <div className="flex items-center justify-center space-x-4 mb-4">
                            <TurnIndicator isMyTurn={isMyTurn} onToggleTurn={toggleMyTurn} />
                            <button onClick={() => setShowClearConfirm(true)} className="flex items-center justify-center w-16 h-16 rounded-full text-4xl shadow-md border-4 bg-red-600 border-red-800 hover:scale-105 active:scale-95" title="Svuota slot">🗑️</button>
                        </div>
                        <CoinFlipper />
                        <DiceRoller title="ATTACCA" isAttackRoller={true} isDiceRollDisabled={diceRollDisableStatus} isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                        <DiceRoller title="RITIRATA" isMyTurn={isMyTurn} onDiceRollComplete={toggleMyTurn} onDisplayGlobalBanner={displayGlobalBanner} />
                    </div>
                    {showClearConfirm && <div className="zoom-modal-overlay"><div className="zoom-modal-content bg-gray-800 p-6 rounded-xl border-4 border-red-500"><h3 className="text-2xl font-bold text-red-400 mb-6 text-center">Svuotare tutti gli slot?</h3><div className="flex space-x-4"><button onClick={() => {setCards(Array(6).fill(null)); setShowClearConfirm(false);}} className="btn-theme btn-red">Sì</button><button onClick={() => setShowClearConfirm(false)} className="btn-theme btn-gray">No</button></div></div></div>}
                    <div className="grid grid-cols-1 gap-8 w-full max-w-xs mt-8 pb-8"> 
                        {cards.map((card, i) => <CardSlot key={i} slotIndex={i} cardData={card} onUpdateCard={updateCardInSlot} onToggleActivePokemon={handleActivePokemonToggle} isMyTurn={isMyTurn} activeCardParalyzed={diceRollDisableStatus} role="master" pokemonDbCards={pokemonDbCards} trainersDbCards={trainersDbCards} palestreDbCards={palestreDbCards} isDbLoading={isDbLoading} dbError={dbError} onSelectTableAndFetchRandom={fetchRandomCardFromTable} onSelectPalestreCard={handlePalestreCardSelection} showTemporaryCard={showTemporaryCard} isBoardEmpty={cards.every(c => !c)} />)}
                    </div>
                </div>
            );
        }
        
        function MainAppContainer() {
            const [currentRole, setCurrentRole] = React.useState('player');
            const [globalBanner, setGlobalBanner] = React.useState({ isVisible: false, message: '', type: '' });
            const bannerTimeoutRef = React.useRef(null);
            const [temporaryCard, setTemporaryCard] = React.useState(null);
            const [prizePreview, setPrizePreview] = React.useState(null);
            const [defeatPreview, setDefeatPreview] = React.useState(null);
            const [movementResult, setMovementResult] = React.useState(null);


            const displayGlobalBanner = React.useCallback((message, type = 'info', duration = 3000) => {
                if (bannerTimeoutRef.current) clearTimeout(bannerTimeoutRef.current);
                setGlobalBanner({ isVisible: true, message, type });
                if (duration > 0) {
                    bannerTimeoutRef.current = setTimeout(() => setGlobalBanner({ isVisible: false, message: '', type: '' }), duration);
                }
            }, []);
            const clearGlobalBanner = React.useCallback(() => {
                if (bannerTimeoutRef.current) clearTimeout(bannerTimeoutRef.current);
                setGlobalBanner({ isVisible: false, message: '', type: '' });
            }, []);
            const showTemporaryCard = React.useCallback((imageUrl, callback) => {
                setTemporaryCard(imageUrl);
                setTimeout(() => { setTemporaryCard(null); if (callback) callback(); }, 3000);
            }, []);
            const showPrizePreview = React.useCallback((cards, currency, callback) => {
                setPrizePreview({ cards, currency });
                setTimeout(() => { setPrizePreview(null); if (callback) callback(); }, 2000);
            }, []);
            const showDefeatPreview = React.useCallback((type, currency, callback) => {
                setDefeatPreview({ type, currency });
                setTimeout(() => { setDefeatPreview(null); if (callback) callback(); }, 2000);
            }, []);
            const showMovementResultPreview = React.useCallback((result) => {
                setMovementResult(result);
                setTimeout(() => setMovementResult(null), 3000);
            }, []);


            return (
                <div className="min-h-screen flex flex-col items-center bg-gray-900">
                    <GlobalEventBanner {...globalBanner} />
                    <TemporaryCardDisplay imageUrl={temporaryCard} />
                    <PrizePreviewDisplay prizeData={prizePreview} />
                    <DefeatPreviewDisplay defeatData={defeatPreview} />
                    <MovementResultDisplay result={movementResult} />
                    {currentRole === 'player' ? (
                        <PlayerApp onSwitchRole={setCurrentRole} {...{displayGlobalBanner, clearGlobalBanner, showTemporaryCard, showPrizePreview, showDefeatPreview, showMovementResultPreview}} />
                    ) : (
                        <MasterApp onSwitchRole={setCurrentRole} {...{displayGlobalBanner, clearGlobalBanner, showTemporaryCard}} />
                    )}
                </div>
            );
        }


        ReactDOM.createRoot(document.getElementById('root')).render(<MainAppContainer />);
    </script>
</body>
</html>
